var _JupiterRouteLimiter_allDexes, _JupiterBase_PRICE_API, _JupiterBase_jupiterAccessToken, _JupiterBase_timeoutInMs, _JupiterConnectorV6_jupiterAPI, _JupiterConnectorV6_maxAccounts, _JupiterConnectorV6_allowRestrictIntermediateTokensFunction, _JupiterConnectorV6_routeLimiter, _JupiterConnectorV4_jupiterAPI;
import { __classPrivateFieldGet, __classPrivateFieldSet } from "tslib";
// import { writeFileSync } from "fs";
// import markets from "./markets.json";
import { TOKEN_PROGRAM_ID, WRAPPED_SOL_MINT } from "@debridge-finance/solana-utils";
import { AddressLookupTableAccount, ComputeBudgetProgram, PublicKey, SystemProgram, TransactionInstruction, VersionedTransaction, } from "@solana/web3.js";
import { compiledInstructionToInstruction, parseTransactionAccounts, } from "@debridge-finance/solana-transaction-parser";
import { ChainId } from "../common.types";
import { parseALT } from "../solana/utils";
import ALTs from "./ammAlt.json";
import { SwapConnector } from ".";
import { SwapConnectorError } from "./errors/swap-connector.error";
import { SwapConnectorErrorType } from "./errors/swap-connector-error.type";
import { SwapConnectorLogger } from "./swap-connector.logger";
export class JupiterRouteLimiter {
    constructor() {
        _JupiterRouteLimiter_allDexes.set(this, [
            "Crema",
            "Saros",
            "Lifinity V2",
            "FluxBeam",
            "Mercurial",
            "Meteora",
            "Phoenix",
            "Saber (Decimals)",
            "Openbook",
            "Orca V1",
            "Oasis",
            "Perps",
            "Helium Network",
            "Cropper",
            "Raydium CLMM",
            "Aldrin",
            "Token Swap",
            "Raydium",
            "GooseFX",
            "Bonkswap",
            "StepN",
            "Invariant",
            "Meteora DLMM",
            "Orca V2",
            "Lifinity V1",
            "Balansol",
            "Saber",
            "Penguin",
            "Jupiter LO",
            "Whirlpool",
            "Marinade",
            "Sanctum",
            "Aldrin V2",
        ]);
    }
    /**
     * Fetches DEXes supported by Jupiter
     * @returns current list of all supported DEXes by jupiter
     */
    async getAllDexes() {
        //TODO: Should use baseURL!
        const result = (await fetch("https://quote-api.jup.ag/v6/program-id-to-label").then((r) => r.json()));
        __classPrivateFieldSet(this, _JupiterRouteLimiter_allDexes, Object.values(result), "f");
        return __classPrivateFieldGet(this, _JupiterRouteLimiter_allDexes, "f");
    }
    /**
     * Exclude list of DEXes from route
     * @param dexesToExclude
     * @returns excludeDexes list
     */
    blacklist(dexesToExclude) {
        return dexesToExclude;
    }
    /**
     * Exclude all except dexesToInclude from route
     * @param dexesToInclude
     * @returns excludeDexes list
     */
    whitelist(dexesToInclude) {
        const result = [];
        for (const dex of __classPrivateFieldGet(this, _JupiterRouteLimiter_allDexes, "f")) {
            if (!dexesToInclude.includes(dex)) {
                result.push(dex);
            }
        }
        return result;
    }
}
_JupiterRouteLimiter_allDexes = new WeakMap();
/**
 * @internal
 */
class JupiterBase extends SwapConnector {
    constructor(connection, jupiterAccessToken, timeoutInMs) {
        super();
        this.connection = connection;
        this.NATIVE_MINT = "1".repeat(32);
        _JupiterBase_PRICE_API.set(this, "https://price.jup.ag/v3/price");
        _JupiterBase_jupiterAccessToken.set(this, void 0);
        _JupiterBase_timeoutInMs.set(this, void 0);
        __classPrivateFieldSet(this, _JupiterBase_jupiterAccessToken, jupiterAccessToken, "f");
        this.maskCredentialFunction = jupiterAccessToken
            ? (text) => text.replaceAll(jupiterAccessToken, "<API KEY>")
            : (text) => text;
        this.ALTMap = new Map(Object.entries(ALTs));
        __classPrivateFieldSet(this, _JupiterBase_timeoutInMs, timeoutInMs, "f");
    }
    getSupportedChains() {
        return [ChainId.Solana];
    }
    /** wrapUnwrapSol default is true
     * We might want to set it to false when source/destination token is wrapped sol
     **/
    fixWSolAddress(fromTokenAddress, toTokenAddress) {
        let inputMint = new PublicKey(fromTokenAddress).toBase58();
        let outputMint = new PublicKey(toTokenAddress).toBase58();
        let wrapUnwrapSOL = true;
        const wsol = WRAPPED_SOL_MINT.toBase58();
        if (inputMint === wsol) {
            wrapUnwrapSOL = false;
        }
        else if (outputMint === wsol) {
            wrapUnwrapSOL = false;
        }
        if (inputMint === this.NATIVE_MINT)
            inputMint = wsol;
        if (outputMint === this.NATIVE_MINT)
            outputMint = wsol;
        return [inputMint, outputMint, wrapUnwrapSOL];
    }
    async filterExistingWallets(connection, wallets) {
        if (wallets.length === 0) {
            return [];
        }
        const accountsInfo = await connection.getMultipleAccountsInfo(wallets);
        const accountExists = (info) => info != null && info.lamports !== 0;
        return accountsInfo.reduce((result, info, idx) => {
            if (accountExists(info) && info?.owner.equals(TOKEN_PROGRAM_ID)) {
                result.push(wallets[idx]);
            }
            return result;
        }, []);
    }
    async getTokenPriceInSol(tokenAddress, context) {
        const logger = new SwapConnectorLogger(context.logger, JupiterBase.name, this.maskCredentialFunction);
        let token = new PublicKey(tokenAddress).toBase58();
        if (token === this.NATIVE_MINT)
            token = WRAPPED_SOL_MINT.toBase58();
        const queryParams = new URLSearchParams({
            ids: token,
            vsToken: "So11111111111111111111111111111111111111112",
        });
        const response = await this.callJupiter(__classPrivateFieldGet(this, _JupiterBase_PRICE_API, "f"), __classPrivateFieldGet(this, _JupiterBase_PRICE_API, "f"), queryParams, logger);
        if (response === null)
            throw new SwapConnectorError(JupiterBase.name, SwapConnectorErrorType.InternalError, `Failed to get price for token: ${token}`);
        logger.verbose("getTokenPriceInSol res:", JSON.stringify(response));
        return response.data[token]?.price;
    }
    async callJupiter(basicUrl, path, query, logger, body) {
        let method = "GET";
        const headers = {};
        if (body) {
            method = "POST";
            headers["Content-Type"] = "application/json";
        }
        if (__classPrivateFieldGet(this, _JupiterBase_jupiterAccessToken, "f")) {
            query.append("token", __classPrivateFieldGet(this, _JupiterBase_jupiterAccessToken, "f"));
        }
        try {
            return await this.call({
                basicUrl,
                path,
                query,
                headers,
                method,
                body,
                timeoutInMs: __classPrivateFieldGet(this, _JupiterBase_timeoutInMs, "f"),
            }, {
                logger,
            });
        }
        catch (e) {
            const error = e;
            throw new SwapConnectorError(JupiterBase.name, SwapConnectorErrorType.InternalError, error.message);
        }
    }
}
_JupiterBase_PRICE_API = new WeakMap(), _JupiterBase_jupiterAccessToken = new WeakMap(), _JupiterBase_timeoutInMs = new WeakMap();
export class JupiterConnectorV6 extends JupiterBase {
    constructor(config) {
        super(config.connection, config.jupiterAccessToken, config.timeoutInMs);
        _JupiterConnectorV6_jupiterAPI.set(this, void 0);
        _JupiterConnectorV6_maxAccounts.set(this, void 0);
        _JupiterConnectorV6_allowRestrictIntermediateTokensFunction.set(this, void 0);
        _JupiterConnectorV6_routeLimiter.set(this, void 0);
        __classPrivateFieldSet(this, _JupiterConnectorV6_jupiterAPI, config.customApiURL || "https://quote-api.jup.ag/v6", "f");
        __classPrivateFieldSet(this, _JupiterConnectorV6_maxAccounts, config.maxAccounts, "f");
        __classPrivateFieldSet(this, _JupiterConnectorV6_routeLimiter, config.routeLimiter, "f");
        __classPrivateFieldSet(this, _JupiterConnectorV6_allowRestrictIntermediateTokensFunction, config.allowRestrictIntermediateTokensFunction, "f");
    }
    setMaxAccounts(count) {
        __classPrivateFieldSet(this, _JupiterConnectorV6_maxAccounts, count, "f");
    }
    /*
    calculateMaxAccounts(mode: "create" | "fulfill", tokenFrom: Address, tokenTo: Address, hasCalldata: boolean): number {
      const stringifiedAddress = new PublicKey(tokenTo).toBase58();
      const isSol = stringifiedAddress === this.NATIVE_MINT;
      const isWSol = stringifiedAddress === WRAPPED_SOL_MINT.toBase58();
      if (hasCalldata) {
        if (isSol) {
          return 16;
        } else if (isWSol) {
          return 16;
        } else {
          return 18;
        }
      } else {
        if (isSol) {
          return 16;
        } else if (isWSol) {
          return 16;
        } else {
          return 18;
        }
      }
    }
    */
    async getEstimate(request, context) {
        if (!this.getSupportedChains().includes(request.chainId)) {
            const message = `Chain ${ChainId[request.chainId]} is not supported`;
            throw new SwapConnectorError(JupiterConnectorV6.name, SwapConnectorErrorType.UnsupportedChain, message);
        }
        const [inputMint, outputMint, wrapUnwrapSOL] = this.fixWSolAddress(request.fromTokenAddress, request.toTokenAddress);
        const queryParams = new URLSearchParams({
            inputMint,
            outputMint,
            swapMode: "ExactIn",
            wrapAndUnwrapSol: wrapUnwrapSOL.toString(),
            slippageBps: request.slippageBps.toString(),
            amount: request.amountIn.toString(),
        });
        const excludedDexes = (await __classPrivateFieldGet(this, _JupiterConnectorV6_routeLimiter, "f")?.getExcludedDexes(request)) ?? [];
        if (excludedDexes.length > 0) {
            queryParams.set("excludeDexes", excludedDexes.join(","));
        }
        if (request.affiliateFeeBps !== undefined) {
            queryParams.set("platformFeeBps", request.affiliateFeeBps.toString());
        }
        if (__classPrivateFieldGet(this, _JupiterConnectorV6_maxAccounts, "f")) {
            queryParams.set("maxAccounts", __classPrivateFieldGet(this, _JupiterConnectorV6_maxAccounts, "f").toString());
        }
        if (__classPrivateFieldGet(this, _JupiterConnectorV6_allowRestrictIntermediateTokensFunction, "f") !== undefined) {
            queryParams.set("restrictIntermediateTokens", __classPrivateFieldGet(this, _JupiterConnectorV6_allowRestrictIntermediateTokensFunction, "f").call(this, request).toString());
        }
        const logger = new SwapConnectorLogger(context.logger, JupiterConnectorV6.name, this.maskCredentialFunction);
        const response = await this.callJupiter(__classPrivateFieldGet(this, _JupiterConnectorV6_jupiterAPI, "f"), `/quote`, queryParams, logger);
        const result = {
            amountIn: request.amountIn,
            amountOut: BigInt(response.outAmount),
            chainId: ChainId.Solana,
            fromTokenAddress: request.fromTokenAddress,
            toTokenAddress: request.toTokenAddress,
            rawConnectorResponse: {
                ...response,
                wrapAndUnwrapSol: wrapUnwrapSOL,
            },
        };
        return result;
    }
    async getSwap(request, context) {
        if (!this.getSupportedChains().includes(request.chainId)) {
            const message = `Chain ${ChainId[request.chainId]} is not supported`;
            throw new SwapConnectorError(JupiterConnectorV6.name, SwapConnectorErrorType.UnsupportedChain, message);
        }
        const logger = new SwapConnectorLogger(context.logger, JupiterConnectorV6.name, this.maskCredentialFunction);
        if (!request.fromAddress)
            throw new SwapConnectorError(JupiterConnectorV6.name, SwapConnectorErrorType.InputValidationError, "From address is required for solana swaps");
        if ((request.affiliateFeeBps === undefined && request.affiliateFeeRecipient !== undefined) ||
            (request.affiliateFeeBps !== undefined && request.affiliateFeeRecipient === undefined)) {
            throw new SwapConnectorError(JupiterConnectorV6.name, SwapConnectorErrorType.InputValidationError, "only one of affiliateFeeRecipient & affiliateFeeBps params is set, both required");
        }
        let feeAccount = null;
        const prefixInstructions = [];
        if (request.affiliateFeeRecipient) {
            const [, tokenOut] = this.fixWSolAddress(request.fromTokenAddress, request.toTokenAddress);
            const realSwapTokenOut = new PublicKey(tokenOut);
            const refPubkey = new PublicKey("REFER4ZgmyYx9c6He5XfaTMiGfdLwRnkV4RPp9t9iF3");
            const feeBeneficiar = new PublicKey(request.affiliateFeeRecipient);
            // get the feeAccount.
            [feeAccount] = PublicKey.findProgramAddressSync([
                Buffer.from("referral_ata"),
                request.affiliateFeeRecipient,
                realSwapTokenOut.toBuffer(), // the token mint, output mint for ExactIn, input mint for ExactOut.
            ], refPubkey);
            const [beneficiarInfo, feeAccountInfo] = await this.connection.getMultipleAccountsInfo([
                feeBeneficiar,
                feeAccount,
            ]);
            if (!beneficiarInfo || beneficiarInfo.lamports === 0) {
                throw new Error(`Fee beneficiar is not initialized, please check jupiter fee docs`);
            }
            if (!feeAccountInfo || feeAccountInfo?.lamports === 0) {
                prefixInstructions.push(new TransactionInstruction({
                    programId: refPubkey,
                    keys: [
                        {
                            //name: "payer";
                            pubkey: new PublicKey(request.fromAddress),
                            isWritable: true,
                            isSigner: true,
                        },
                        {
                            // name: "project",
                            pubkey: new PublicKey("45ruCyfdRkWpRNGEqWzjCiXRHkZs8WXCLQ67Pnpye7Hp"),
                            isWritable: false,
                            isSigner: false,
                        },
                        {
                            //name: "referralAccount";
                            pubkey: feeBeneficiar,
                            isWritable: false,
                            isSigner: false,
                        },
                        {
                            //name: "referralTokenAccount";
                            pubkey: feeAccount,
                            isWritable: true,
                            isSigner: false,
                        },
                        {
                            //name: "mint",
                            pubkey: realSwapTokenOut,
                            isWritable: false,
                            isSigner: false,
                        },
                        {
                            //name: "systemProgram",
                            pubkey: SystemProgram.programId,
                            isWritable: false,
                            isSigner: false,
                        },
                        {
                            pubkey: TOKEN_PROGRAM_ID,
                            isWritable: false,
                            isSigner: false,
                        },
                    ],
                    data: Buffer.from("7d12465f56b3ddbe", "hex"), // Referral: Initialize Referral Token Account
                }));
            }
        }
        const estimate = request.routeHint ?? (await this.getEstimate(request, context));
        const quoteResponse = estimate.rawConnectorResponse;
        // override quote's slippage with the new value
        quoteResponse.slippageBps = request.slippageBps;
        const swapRequest = {
            quoteResponse,
            wrapAndUnwrapSol: quoteResponse.wrapAndUnwrapSol,
            userPublicKey: new PublicKey(request.fromAddress).toBase58(),
            feeAccount: feeAccount ? feeAccount.toBase58() : undefined,
        };
        const response = await this.callJupiter(__classPrivateFieldGet(this, _JupiterConnectorV6_jupiterAPI, "f"), `/swap`, new URLSearchParams(), logger, JSON.stringify(swapRequest));
        const vtx = VersionedTransaction.deserialize(Buffer.from(response.swapTransaction, "base64"));
        const ALTs = vtx.message.addressTableLookups.map((alt) => alt.accountKey);
        const fetchedALTs = await this.connection.getMultipleAccountsInfo(ALTs);
        const parsedALTs = fetchedALTs
            .map((fetched, i) => fetched
            ? new AddressLookupTableAccount({ state: AddressLookupTableAccount.deserialize(fetched.data), key: ALTs[i] })
            : null)
            .filter((x) => x != null);
        const parsedAccountsForTx = parseTransactionAccounts(vtx.message, parseALT(vtx.message, parsedALTs));
        const instructions = vtx.message.compiledInstructions.map((ci) => compiledInstructionToInstruction(ci, parsedAccountsForTx));
        const priorityFeeIxs = context.removePriorityFeeIxs ?? true
            ? []
            : instructions.filter((ix) => ix.programId.equals(ComputeBudgetProgram.programId));
        const filtered = instructions.filter((ix) => !ix.programId.equals(ComputeBudgetProgram.programId));
        const result = {
            amountIn: request.amountIn,
            amountOut: BigInt(quoteResponse.outAmount),
            fromToken: request.fromTokenAddress,
            toToken: request.toTokenAddress,
            engine: "solana",
            swapInstructions: [...priorityFeeIxs, ...prefixInstructions, ...filtered],
            ALTs: parsedALTs,
            rawConnectorResponse: response,
            prioritizationFeeLamports: response.prioritizationFeeLamports,
        };
        return result;
    }
    get connectorName() {
        return "jupiter-v6";
    }
}
_JupiterConnectorV6_jupiterAPI = new WeakMap(), _JupiterConnectorV6_maxAccounts = new WeakMap(), _JupiterConnectorV6_allowRestrictIntermediateTokensFunction = new WeakMap(), _JupiterConnectorV6_routeLimiter = new WeakMap();
export class JupiterConnectorV4 extends JupiterBase {
    constructor(connection, routeFilter = () => true, customApiURL, jupiterAccessToken, timeoutInMs) {
        super(connection, jupiterAccessToken, timeoutInMs);
        this.routeFilter = routeFilter;
        _JupiterConnectorV4_jupiterAPI.set(this, void 0);
        __classPrivateFieldSet(this, _JupiterConnectorV4_jupiterAPI, customApiURL || "https://quote-api.jup.ag/v4", "f");
    }
    async getEstimate(request, context) {
        if (!this.getSupportedChains().includes(request.chainId)) {
            const message = `Chain ${ChainId[request.chainId]} is not supported`;
            throw new SwapConnectorError(JupiterConnectorV4.name, SwapConnectorErrorType.UnsupportedChain, message);
        }
        const [inputMint, outputMint, wrapUnwrapSOL] = this.fixWSolAddress(request.fromTokenAddress, request.toTokenAddress);
        const queryParams = new URLSearchParams({
            inputMint,
            outputMint,
            swapMode: "ExactIn",
            wrapUnwrapSOL: wrapUnwrapSOL.toString(),
            slippageBps: (request?.slippageBps || 100).toString(),
            amount: request.amountIn.toString(),
        });
        const logger = new SwapConnectorLogger(context.logger, JupiterConnectorV4.name, this.maskCredentialFunction);
        const quoteResponse = await this.callJupiter(__classPrivateFieldGet(this, _JupiterConnectorV4_jupiterAPI, "f"), `/quote`, queryParams, logger);
        const blacklist = ["serum"];
        const filtered = quoteResponse.data
            .filter(this.routeFilter)
            .filter((iroute) => iroute.marketInfos.find((market) => {
            // iterate over all route markets, try to find bad routes
            const label = market.label.toLowerCase();
            return blacklist.filter((item) => label.includes(item)).length !== 0; // check if market is in the blacklist
        }) === undefined)
            .map((okRoute) => ({ ...okRoute, wrapUnwrapSOL }));
        // allowed routes not found
        if (filtered.length === 0)
            throw new SwapConnectorError(JupiterConnectorV4.name, SwapConnectorErrorType.InternalError, `Failed to get swap routes for: ${inputMint} -> ${outputMint}`);
        return {
            amountIn: request.amountIn,
            amountOut: BigInt(filtered[0].outAmount),
            chainId: ChainId.Solana,
            fromTokenAddress: request.fromTokenAddress,
            toTokenAddress: request.toTokenAddress,
            rawConnectorResponse: filtered,
        };
    }
    async getSwap(request, context) {
        if (!this.getSupportedChains().includes(request.chainId)) {
            const message = `Chain ${ChainId[request.chainId]} is not supported`;
            throw new SwapConnectorError(JupiterConnectorV4.name, SwapConnectorErrorType.UnsupportedChain, message);
        }
        const quote = await this.getEstimate(request, context);
        const routes = quote.rawConnectorResponse;
        const route = routes[0];
        const requestData = {
            route,
            userPublicKey: new PublicKey(request.fromAddress).toBase58(),
            wrapUnwrapSOL: route.wrapUnwrapSOL,
        };
        const logger = new SwapConnectorLogger(context.logger, JupiterConnectorV4.name, this.maskCredentialFunction);
        const response = await this.callJupiter(__classPrivateFieldGet(this, _JupiterConnectorV4_jupiterAPI, "f"), "/swap", new URLSearchParams(), logger, JSON.stringify(requestData));
        const versionedTxs = [response?.setupTransaction, response.swapTransaction, response?.cleanupTransaction]
            .filter((serialized) => serialized !== undefined && serialized !== "")
            .map((serialized) => VersionedTransaction.deserialize(Buffer.from(serialized, "base64")))
            .flatMap((tx) => tx);
        const computeBudgetProgramId = "ComputeBudget111111111111111111111111111111";
        const ALTs = versionedTxs.flatMap((vtx) => vtx.message.addressTableLookups.map((alt) => alt.accountKey));
        const fetchedALTs = await this.connection.getMultipleAccountsInfo(ALTs);
        const parsedALTs = fetchedALTs
            .map((fetched, i) => fetched
            ? new AddressLookupTableAccount({ state: AddressLookupTableAccount.deserialize(fetched.data), key: ALTs[i] })
            : null)
            .filter((x) => x != null);
        const loadedAddressesForTx = versionedTxs.map((vtx) => parseALT(vtx.message, parsedALTs));
        const parsedAccountsForTx = versionedTxs.map((vtx, i) => parseTransactionAccounts(vtx.message, loadedAddressesForTx[i]));
        const instructions = versionedTxs.flatMap((vtx, txI) => vtx.message.compiledInstructions.map((ci) => compiledInstructionToInstruction(ci, parsedAccountsForTx[txI])));
        const filtered = instructions.filter((ix) => ix.programId.toBase58() !== computeBudgetProgramId);
        // Enrich ALTs by marketId alt map
        const ALTsFromTx = ALTs.map((pk) => pk.toBase58());
        const ALTsByIds = route.marketInfos
            .flatMap((info) => info.id.split("-"))
            .map((id) => this.ALTMap.get(id))
            .filter((addr) => addr !== undefined);
        const totlaALTs = Array.from(new Set([...ALTsByIds, ...ALTsFromTx]).values());
        const result = {
            ALTs: totlaALTs.map((alt) => new PublicKey(alt)),
            amountIn: BigInt(route.amount),
            amountOut: BigInt(route.outAmount),
            fromToken: request.fromTokenAddress,
            toToken: request.toTokenAddress,
            swapInstructions: filtered,
            engine: "solana",
            rawConnectorResponse: response,
            prioritizationFeeLamports: 1000,
        };
        return result;
    }
    get connectorName() {
        return "jupiter-v4";
    }
}
_JupiterConnectorV4_jupiterAPI = new WeakMap();
//# sourceMappingURL=jupiter.connector.js.map
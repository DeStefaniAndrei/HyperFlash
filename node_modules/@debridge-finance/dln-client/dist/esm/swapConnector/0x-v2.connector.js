var _ZeroXV2SwapConnector_instances, _ZeroXV2SwapConnector_apiKey, _ZeroXV2SwapConnector_excludeSources, _ZeroXV2SwapConnector_maskCredentialFunction, _ZeroXV2SwapConnector_tradeSurplusRecipient, _ZeroXV2SwapConnector_basicUrl, _ZeroXV2SwapConnector_timeoutInMs, _ZeroXV2SwapConnector_call0x, _ZeroXV2SwapConnector_nativeAddressToEvmFormat, _ZeroXV2SwapConnector_fixEvmNativeAddress;
import { __classPrivateFieldGet, __classPrivateFieldSet } from "tslib";
import { helpers } from "@debridge-finance/solana-utils";
import { ChainId } from "../common.types";
import { SwapConnector, } from "./swap.connector";
import { SwapConnectorErrorType } from "./errors/swap-connector-error.type";
import { SwapConnectorError } from "./errors/swap-connector.error";
import { SwapConnectorLogger } from "./swap-connector.logger";
var ZeroXSupportedChainId;
(function (ZeroXSupportedChainId) {
    ZeroXSupportedChainId[ZeroXSupportedChainId["Ethereum"] = 1] = "Ethereum";
    ZeroXSupportedChainId[ZeroXSupportedChainId["BSC"] = 56] = "BSC";
    ZeroXSupportedChainId[ZeroXSupportedChainId["Arbitrum"] = 42161] = "Arbitrum";
    ZeroXSupportedChainId[ZeroXSupportedChainId["Avalanche"] = 43114] = "Avalanche";
    ZeroXSupportedChainId[ZeroXSupportedChainId["Optimism"] = 10] = "Optimism";
    ZeroXSupportedChainId[ZeroXSupportedChainId["Polygon"] = 137] = "Polygon";
    ZeroXSupportedChainId[ZeroXSupportedChainId["Base"] = 8453] = "Base";
    ZeroXSupportedChainId[ZeroXSupportedChainId["Linea"] = 59144] = "Linea";
})(ZeroXSupportedChainId || (ZeroXSupportedChainId = {}));
export class ZeroXV2SwapConnector extends SwapConnector {
    constructor(config) {
        super();
        _ZeroXV2SwapConnector_instances.add(this);
        _ZeroXV2SwapConnector_apiKey.set(this, void 0);
        _ZeroXV2SwapConnector_excludeSources.set(this, void 0);
        _ZeroXV2SwapConnector_maskCredentialFunction.set(this, void 0);
        _ZeroXV2SwapConnector_tradeSurplusRecipient.set(this, void 0);
        _ZeroXV2SwapConnector_basicUrl.set(this, "https://api.0x.org");
        _ZeroXV2SwapConnector_timeoutInMs.set(this, void 0);
        __classPrivateFieldSet(this, _ZeroXV2SwapConnector_tradeSurplusRecipient, config.tradeSurplusRecipient, "f");
        __classPrivateFieldSet(this, _ZeroXV2SwapConnector_apiKey, config.apiKey, "f");
        __classPrivateFieldSet(this, _ZeroXV2SwapConnector_excludeSources, config.excludeSources || [], "f");
        __classPrivateFieldSet(this, _ZeroXV2SwapConnector_maskCredentialFunction, (text) => text.replaceAll(config.apiKey, "<API KEY>"), "f");
        __classPrivateFieldSet(this, _ZeroXV2SwapConnector_timeoutInMs, config.timeoutInMs, "f");
    }
    getSupportedChains() {
        return Object.values(ZeroXSupportedChainId)
            .filter((v) => typeof v === "number")
            .map((_) => Number(_));
    }
    async getEstimate(request, context) {
        const logger = new SwapConnectorLogger(context.logger, ZeroXV2SwapConnector.name, __classPrivateFieldGet(this, _ZeroXV2SwapConnector_maskCredentialFunction, "f"));
        if (!this.getSupportedChains().includes(request.chainId)) {
            const message = `Chain ${ChainId[request.chainId]} is not supported`;
            throw new SwapConnectorError(ZeroXV2SwapConnector.name, SwapConnectorErrorType.UnsupportedChain, message);
        }
        const params = new URLSearchParams({
            chainId: request.chainId.toString(),
            buyToken: __classPrivateFieldGet(this, _ZeroXV2SwapConnector_instances, "m", _ZeroXV2SwapConnector_nativeAddressToEvmFormat).call(this, request.toTokenAddress),
            sellToken: __classPrivateFieldGet(this, _ZeroXV2SwapConnector_instances, "m", _ZeroXV2SwapConnector_nativeAddressToEvmFormat).call(this, request.fromTokenAddress),
            sellAmount: request.amountIn.toString(),
            slippageBps: request.slippageBps.toString(),
        });
        if (__classPrivateFieldGet(this, _ZeroXV2SwapConnector_tradeSurplusRecipient, "f")) {
            params.append("tradeSurplusRecipient", __classPrivateFieldGet(this, _ZeroXV2SwapConnector_tradeSurplusRecipient, "f"));
        }
        if (__classPrivateFieldGet(this, _ZeroXV2SwapConnector_excludeSources, "f").length) {
            params.append("excludedSources", __classPrivateFieldGet(this, _ZeroXV2SwapConnector_excludeSources, "f").join(","));
        }
        const response = await __classPrivateFieldGet(this, _ZeroXV2SwapConnector_instances, "m", _ZeroXV2SwapConnector_call0x).call(this, "/swap/allowance-holder/price", params, logger);
        return {
            amountIn: BigInt(response.sellAmount),
            amountOut: BigInt(response.buyAmount),
            chainId: Number(request.chainId),
            fromTokenAddress: __classPrivateFieldGet(this, _ZeroXV2SwapConnector_instances, "m", _ZeroXV2SwapConnector_fixEvmNativeAddress).call(this, response.sellToken),
            toTokenAddress: __classPrivateFieldGet(this, _ZeroXV2SwapConnector_instances, "m", _ZeroXV2SwapConnector_fixEvmNativeAddress).call(this, response.buyToken),
            rawConnectorResponse: response,
        };
    }
    async getSwap(request, context) {
        if (!this.getSupportedChains().includes(request.chainId)) {
            const message = `Chain ${ChainId[request.chainId]} is not supported`;
            throw new SwapConnectorError(ZeroXV2SwapConnector.name, SwapConnectorErrorType.UnsupportedChain, message);
        }
        const logger = new SwapConnectorLogger(context.logger, ZeroXV2SwapConnector.name, __classPrivateFieldGet(this, _ZeroXV2SwapConnector_maskCredentialFunction, "f"));
        if (!request.origin) {
            throw new SwapConnectorError(ZeroXV2SwapConnector.name, SwapConnectorErrorType.InputValidationError, "Origin is mandatory");
        }
        const params = new URLSearchParams({
            chainId: request.chainId.toString(),
            buyToken: __classPrivateFieldGet(this, _ZeroXV2SwapConnector_instances, "m", _ZeroXV2SwapConnector_nativeAddressToEvmFormat).call(this, request.toTokenAddress),
            sellToken: __classPrivateFieldGet(this, _ZeroXV2SwapConnector_instances, "m", _ZeroXV2SwapConnector_nativeAddressToEvmFormat).call(this, request.fromTokenAddress),
            sellAmount: request.amountIn.toString(),
            taker: helpers.bufferToHex(request.fromAddress),
            slippageBps: request.slippageBps.toString(),
            txOrigin: helpers.bufferToHex(request.origin),
        });
        if (__classPrivateFieldGet(this, _ZeroXV2SwapConnector_tradeSurplusRecipient, "f")) {
            params.append("tradeSurplusRecipient", __classPrivateFieldGet(this, _ZeroXV2SwapConnector_tradeSurplusRecipient, "f"));
        }
        if (__classPrivateFieldGet(this, _ZeroXV2SwapConnector_excludeSources, "f").length) {
            params.append("excludedSources", __classPrivateFieldGet(this, _ZeroXV2SwapConnector_excludeSources, "f").join(","));
        }
        const response = await __classPrivateFieldGet(this, _ZeroXV2SwapConnector_instances, "m", _ZeroXV2SwapConnector_call0x).call(this, "/swap/allowance-holder/quote", params, logger);
        return {
            amountIn: BigInt(response.sellAmount),
            amountOut: BigInt(response.buyAmount),
            engine: "evm",
            tx: {
                data: response.transaction.data,
                to: response.transaction.to,
                value: response.transaction.value,
            },
            fromToken: __classPrivateFieldGet(this, _ZeroXV2SwapConnector_instances, "m", _ZeroXV2SwapConnector_fixEvmNativeAddress).call(this, response.sellToken),
            toToken: __classPrivateFieldGet(this, _ZeroXV2SwapConnector_instances, "m", _ZeroXV2SwapConnector_fixEvmNativeAddress).call(this, response.buyToken),
            rawConnectorResponse: response,
        };
    }
    get connectorName() {
        return "0x";
    }
}
_ZeroXV2SwapConnector_apiKey = new WeakMap(), _ZeroXV2SwapConnector_excludeSources = new WeakMap(), _ZeroXV2SwapConnector_maskCredentialFunction = new WeakMap(), _ZeroXV2SwapConnector_tradeSurplusRecipient = new WeakMap(), _ZeroXV2SwapConnector_basicUrl = new WeakMap(), _ZeroXV2SwapConnector_timeoutInMs = new WeakMap(), _ZeroXV2SwapConnector_instances = new WeakSet(), _ZeroXV2SwapConnector_call0x = async function _ZeroXV2SwapConnector_call0x(path, query, logger) {
    try {
        return await this.call({
            basicUrl: __classPrivateFieldGet(this, _ZeroXV2SwapConnector_basicUrl, "f"),
            path,
            query,
            headers: {
                "0x-api-key": __classPrivateFieldGet(this, _ZeroXV2SwapConnector_apiKey, "f"),
                "0x-version": "v2",
            },
            timeoutInMs: __classPrivateFieldGet(this, _ZeroXV2SwapConnector_timeoutInMs, "f"),
        }, {
            logger,
        });
    }
    catch (e) {
        const error = e;
        throw new SwapConnectorError(ZeroXV2SwapConnector.name, SwapConnectorErrorType.InternalError, error.message);
    }
}, _ZeroXV2SwapConnector_nativeAddressToEvmFormat = function _ZeroXV2SwapConnector_nativeAddressToEvmFormat(address) {
    let stringified = helpers.bufferToHex(address);
    if (stringified === "0x0000000000000000000000000000000000000000") {
        stringified = "0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE";
    }
    return stringified;
}, _ZeroXV2SwapConnector_fixEvmNativeAddress = function _ZeroXV2SwapConnector_fixEvmNativeAddress(evmFormat) {
    const evmNative = helpers.hexToBuffer("0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE");
    const address = helpers.hexToBuffer(evmFormat);
    return address.equals(evmNative) ? Buffer.alloc(20) : address;
};
//# sourceMappingURL=0x-v2.connector.js.map
import * as viem from "viem";
import { ChainId } from "../common.types";
import { buffersAreEqual, tokenAddressToString, tokenStringToBuffer } from "../utils";
import { SwapConnector, } from "./swap.connector";
import { AlgebraQuoterABI } from "./assets/AlgebraQuoter";
import { AlgebraSwapRouterABI } from "./assets/AlgebraSwapRouter";
import { SwapConnectorError } from "./errors/swap-connector.error";
import { SwapConnectorErrorType } from "./errors/swap-connector-error.type";
class MetisHerculesError extends SwapConnectorError {
    constructor(type, message) {
        super("MetisHerculesUsdcLP", type, message);
    }
}
const HerculesRouterAddress = "0xBde5839EC36Db2aC492b79e9E3B75e15FA8A59ec";
const HerculesQuoterAddress = "0xdc2496c72911542a359B9c4d6Fc114c9a392e3D7";
const quoteTTL = 600n; // 10min
const UsdcAddress = "0xEA32A96608495e54156Ae48931A7c20f0dcc1a21";
const UsdcAddressBuf = tokenStringToBuffer(ChainId.Metis, UsdcAddress);
const wMetisAddress = "0x75cb093E4D61d2A2e65D8e0BBb01DE8d89b53481";
const wMetisAddressBuf = tokenStringToBuffer(ChainId.Metis, wMetisAddress);
const MetisAddressBuf = Buffer.alloc(20, 0);
const supportedTokens = [UsdcAddressBuf, wMetisAddressBuf];
function getPath(tokenIn, tokenOut) {
    tokenIn = buffersAreEqual(tokenIn, MetisAddressBuf) ? wMetisAddressBuf : tokenIn;
    tokenOut = buffersAreEqual(tokenIn, MetisAddressBuf) ? wMetisAddressBuf : tokenOut;
    const index1 = supportedTokens.findIndex((v) => buffersAreEqual(v, tokenIn));
    const index2 = supportedTokens.findIndex((v) => buffersAreEqual(v, tokenOut));
    if (index2 > index1) {
        return supportedTokens.slice(index1, index2 + 1);
    }
    return supportedTokens.slice(index2, index1 + 1).reverse();
}
function checkTokens(tokenIn, tokenOut) {
    const hasTokenIn = undefined !== supportedTokens.find((v) => buffersAreEqual(v, tokenIn));
    const hasTokenOut = undefined !== supportedTokens.find((v) => buffersAreEqual(v, tokenOut));
    const areEqual = buffersAreEqual(tokenIn, tokenOut);
    if (areEqual)
        throw new MetisHerculesError(SwapConnectorErrorType.InputValidationError, `In and out tokens are equal`);
    if (!hasTokenIn)
        throw new MetisHerculesError(SwapConnectorErrorType.UnsupportedTokenAddress, `Unsupported input token (${tokenAddressToString(ChainId.Metis, tokenIn)})`);
    if (!hasTokenOut)
        throw new MetisHerculesError(SwapConnectorErrorType.UnsupportedTokenAddress, `Unsupported output token (${tokenAddressToString(ChainId.Metis, tokenOut)})`);
}
function getNormalizedPath(tokenIn, tokenOut) {
    const hasInputETH = buffersAreEqual(tokenIn, MetisAddressBuf);
    const hasOutputETH = buffersAreEqual(tokenOut, MetisAddressBuf);
    const normalizedTokens = {
        tokenInBuffer: hasInputETH ? wMetisAddressBuf : tokenIn,
        tokenOutBuffer: hasOutputETH ? wMetisAddressBuf : tokenOut,
        inputETH: hasInputETH,
        outputETH: hasOutputETH,
    };
    checkTokens(normalizedTokens.tokenInBuffer, normalizedTokens.tokenOutBuffer);
    return {
        ...normalizedTokens,
        tokenIn: tokenAddressToString(ChainId.Metis, normalizedTokens.tokenInBuffer),
        tokenOut: tokenAddressToString(ChainId.Metis, normalizedTokens.tokenOutBuffer),
        path: getPath(normalizedTokens.tokenInBuffer, normalizedTokens.tokenOutBuffer),
    };
}
function hexAddress(address) {
    return tokenAddressToString(ChainId.Metis, address);
}
export class MetisHerculesUsdcLP extends SwapConnector {
    constructor(connection) {
        super();
        this.connection = connection;
    }
    async getTx(normalizedTokens, amountIn, amountOutMinimum, recipient) {
        const { timestamp } = await this.connection.eth.getBlock("latest");
        const deadline = BigInt(timestamp) + quoteTTL;
        let swapCall;
        if (normalizedTokens.outputETH) {
            const swapAction = viem.encodeFunctionData({
                abi: AlgebraSwapRouterABI,
                functionName: "exactInputSingle",
                args: [
                    {
                        tokenIn: normalizedTokens.tokenIn,
                        tokenOut: normalizedTokens.tokenOut,
                        recipient: HerculesRouterAddress,
                        deadline,
                        amountIn,
                        amountOutMinimum,
                        limitSqrtPrice: 0n,
                    },
                ],
            });
            swapCall = viem.encodeFunctionData({
                abi: AlgebraSwapRouterABI,
                functionName: "multicall",
                args: [
                    [
                        swapAction,
                        viem.encodeFunctionData({
                            abi: AlgebraSwapRouterABI,
                            functionName: "unwrapWNativeToken",
                            args: [amountOutMinimum, recipient],
                        }),
                    ],
                ],
            });
        }
        else {
            swapCall = viem.encodeFunctionData({
                abi: AlgebraSwapRouterABI,
                functionName: "exactInputSingle",
                args: [
                    {
                        tokenIn: normalizedTokens.tokenIn,
                        tokenOut: normalizedTokens.tokenOut,
                        recipient,
                        deadline,
                        amountIn,
                        amountOutMinimum,
                        limitSqrtPrice: 0n,
                    },
                ],
            });
        }
        return {
            to: HerculesRouterAddress,
            data: swapCall,
            value: normalizedTokens.inputETH ? amountIn.toString() : "0",
        };
    }
    async getSwap(request, context) {
        if (!request.destReceiver)
            throw new MetisHerculesError(SwapConnectorErrorType.InputValidationError, `destReceiver must be explicitly set`);
        if (request.chainId !== ChainId.Metis)
            throw new MetisHerculesError(SwapConnectorErrorType.InputValidationError, `Unsupported chain: ${request.chainId}, expected Metis`);
        const normalizedTokens = getNormalizedPath(request.fromTokenAddress, request.toTokenAddress);
        const estimation = await this.getEstimate(request, context);
        const amountOutMin = (estimation.amountOut * (10000n - BigInt(request.slippageBps))) / 10000n;
        return {
            amountIn: request.amountIn,
            amountOut: estimation.amountOut,
            fromToken: request.fromTokenAddress,
            toToken: request.toTokenAddress,
            rawConnectorResponse: null,
            engine: "evm",
            tx: await this.getTx(normalizedTokens, request.amountIn, amountOutMin, hexAddress(request.destReceiver)),
        };
    }
    async getEstimate(request, context) {
        if (request.chainId !== ChainId.Metis)
            throw new MetisHerculesError(SwapConnectorErrorType.InputValidationError, `Unsupported chain: ${request.chainId}, expected Metis`);
        const normalizedTokens = getNormalizedPath(request.fromTokenAddress, request.toTokenAddress);
        const rawAmountsOut = await this.connection.eth.call({
            to: HerculesQuoterAddress,
            data: viem.encodeFunctionData({
                abi: AlgebraQuoterABI,
                functionName: "quoteExactInputSingle",
                args: [normalizedTokens.tokenIn, normalizedTokens.tokenOut, request.amountIn, 0n],
            }),
        });
        context.logger.verbose(`received response: ${JSON.stringify(rawAmountsOut)}`);
        const [amountOut] = viem.decodeFunctionResult({
            abi: AlgebraQuoterABI,
            functionName: "quoteExactInputSingle",
            data: rawAmountsOut,
        });
        return {
            chainId: request.chainId,
            fromTokenAddress: request.fromTokenAddress,
            toTokenAddress: request.toTokenAddress,
            amountIn: request.amountIn,
            amountOut,
        };
    }
    getSupportedChains() {
        return [ChainId.Metis];
    }
    get connectorName() {
        return MetisHerculesUsdcLP.name;
    }
}
//# sourceMappingURL=metis-hercules-usdc-lp.connector.js.map
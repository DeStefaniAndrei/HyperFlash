var _KyberSwapConnector_instances, _KyberSwapConnector_baseUrl, _KyberSwapConnector_SUPPORTED_CHAINS, _KyberSwapConnector_excludedSources, _KyberSwapConnector_maskCredentialFunction, _KyberSwapConnector_timeoutInMs, _KyberSwapConnector_chainIdToString, _KyberSwapConnector_apiCall;
import { __classPrivateFieldGet, __classPrivateFieldSet } from "tslib";
import { helpers } from "@debridge-finance/solana-utils";
import { ChainId } from "../common.types";
import { SwapConnector, } from "./swap.connector";
import { SwapConnectorError } from "./errors/swap-connector.error";
import { SwapConnectorLogger } from "./swap-connector.logger";
import { SwapConnectorErrorType } from "./errors/swap-connector-error.type";
var RequestMode;
(function (RequestMode) {
    RequestMode[RequestMode["GetRoutes"] = 0] = "GetRoutes";
    RequestMode[RequestMode["BuildTransaction"] = 1] = "BuildTransaction";
})(RequestMode || (RequestMode = {}));
export class KyberSwapConnector extends SwapConnector {
    constructor(excludedSources, timeoutInMs) {
        super();
        _KyberSwapConnector_instances.add(this);
        _KyberSwapConnector_baseUrl.set(this, "https://aggregator-api.kyberswap.com");
        _KyberSwapConnector_SUPPORTED_CHAINS.set(this, [
            ChainId.Arbitrum,
            ChainId.Avalanche,
            ChainId.BSC,
            ChainId.Ethereum,
            ChainId.Fantom,
            ChainId.Polygon,
        ]);
        _KyberSwapConnector_excludedSources.set(this, void 0);
        _KyberSwapConnector_maskCredentialFunction.set(this, void 0);
        _KyberSwapConnector_timeoutInMs.set(this, void 0);
        __classPrivateFieldSet(this, _KyberSwapConnector_excludedSources, excludedSources, "f");
        __classPrivateFieldSet(this, _KyberSwapConnector_maskCredentialFunction, (text) => text, "f");
        __classPrivateFieldSet(this, _KyberSwapConnector_timeoutInMs, timeoutInMs, "f");
    }
    getSupportedChains() {
        return __classPrivateFieldGet(this, _KyberSwapConnector_SUPPORTED_CHAINS, "f");
    }
    async getEstimate(request, context) {
        if (!this.getSupportedChains().includes(request.chainId)) {
            const message = `Chain ${ChainId[request.chainId]} is not supported`;
            throw new SwapConnectorError(KyberSwapConnector.name, SwapConnectorErrorType.UnsupportedChain, message);
        }
        const logger = new SwapConnectorLogger(context.logger, KyberSwapConnector.name, __classPrivateFieldGet(this, _KyberSwapConnector_maskCredentialFunction, "f"));
        const routes = await __classPrivateFieldGet(this, _KyberSwapConnector_instances, "m", _KyberSwapConnector_apiCall).call(this, RequestMode.GetRoutes, request.chainId, {
            amountIn: request.amountIn.toString(),
            tokenIn: helpers.bufferToHex(request.fromTokenAddress),
            tokenOut: helpers.bufferToHex(request.toTokenAddress),
            excludedSources: __classPrivateFieldGet(this, _KyberSwapConnector_excludedSources, "f"),
        }, logger);
        return {
            amountIn: request.amountIn,
            amountOut: BigInt(routes.data.routeSummary.amountOut),
            chainId: request.chainId,
            fromTokenAddress: request.fromTokenAddress,
            toTokenAddress: request.toTokenAddress,
            rawConnectorResponse: routes,
        };
    }
    async getSwap(request, context) {
        if (!this.getSupportedChains().includes(request.chainId)) {
            const message = `Chain ${ChainId[request.chainId]} is not supported`;
            throw new SwapConnectorError(KyberSwapConnector.name, SwapConnectorErrorType.UnsupportedChain, message);
        }
        const { rawConnectorResponse: payload } = await this.getEstimate(request, context);
        const routeSummary = payload.data.routeSummary;
        const logger = new SwapConnectorLogger(context.logger, KyberSwapConnector.name, __classPrivateFieldGet(this, _KyberSwapConnector_maskCredentialFunction, "f"));
        const swapResponse = await __classPrivateFieldGet(this, _KyberSwapConnector_instances, "m", _KyberSwapConnector_apiCall).call(this, RequestMode.BuildTransaction, request.chainId, {
            routeSummary,
        }, logger);
        const result = {
            amountIn: request.amountIn,
            amountOut: BigInt(swapResponse.data.amountOut),
            fromToken: request.fromAddress,
            toToken: request.toTokenAddress,
            rawConnectorResponse: swapResponse,
            tx: {
                data: swapResponse.data.data,
                to: swapResponse.data.routerAddress,
                value: swapResponse.data.gas,
            },
            engine: "evm",
        };
        return result;
    }
    get connectorName() {
        return "kyber";
    }
}
_KyberSwapConnector_baseUrl = new WeakMap(), _KyberSwapConnector_SUPPORTED_CHAINS = new WeakMap(), _KyberSwapConnector_excludedSources = new WeakMap(), _KyberSwapConnector_maskCredentialFunction = new WeakMap(), _KyberSwapConnector_timeoutInMs = new WeakMap(), _KyberSwapConnector_instances = new WeakSet(), _KyberSwapConnector_chainIdToString = function _KyberSwapConnector_chainIdToString(chainId) {
    const chainMap = {
        [ChainId.Arbitrum]: "arbitrum",
        [ChainId.Avalanche]: "avalanche",
        [ChainId.BSC]: "bsc",
        [ChainId.Ethereum]: "ethereum",
        [ChainId.Fantom]: "fantom",
        [ChainId.Polygon]: "polygon",
    };
    if (chainId in chainMap)
        return chainMap[chainId];
    const message = `Chain ${ChainId[chainId]} is not supported`;
    throw new SwapConnectorError(KyberSwapConnector.name, SwapConnectorErrorType.UnsupportedChain, message);
}, _KyberSwapConnector_apiCall = async function _KyberSwapConnector_apiCall(mode, chain, params, logger) {
    switch (mode) {
        case RequestMode.GetRoutes: {
            try {
                const response = await this.call({
                    basicUrl: __classPrivateFieldGet(this, _KyberSwapConnector_baseUrl, "f"),
                    timeoutInMs: __classPrivateFieldGet(this, _KyberSwapConnector_timeoutInMs, "f"),
                    path: `/${__classPrivateFieldGet(this, _KyberSwapConnector_instances, "m", _KyberSwapConnector_chainIdToString).call(this, chain)}/api/v1/routes`,
                    query: new URLSearchParams(Object.entries(params).filter(([k, v]) => v !== undefined)),
                    headers: {},
                }, { logger });
                return response;
            }
            catch (e) {
                const error = e;
                throw new SwapConnectorError(KyberSwapConnector.name, SwapConnectorErrorType.InternalError, error.message);
            }
        }
        case RequestMode.BuildTransaction: {
            try {
                const response = await this.call({
                    basicUrl: __classPrivateFieldGet(this, _KyberSwapConnector_baseUrl, "f"),
                    path: `/${__classPrivateFieldGet(this, _KyberSwapConnector_instances, "m", _KyberSwapConnector_chainIdToString).call(this, chain)}/api/v1/route/build`,
                    query: new URLSearchParams(Object.entries(params).filter(([k, v]) => v !== undefined)),
                    body: JSON.stringify(params),
                    method: "POST",
                    timeoutInMs: __classPrivateFieldGet(this, _KyberSwapConnector_timeoutInMs, "f"),
                    headers: {
                        "Content-Type": "application/json",
                    },
                }, { logger });
                return response;
            }
            catch (e) {
                const error = e;
                throw new SwapConnectorError(KyberSwapConnector.name, SwapConnectorErrorType.InternalError, error.message);
            }
        }
        default: {
            throw new SwapConnectorError(KyberSwapConnector.name, SwapConnectorErrorType.InternalError, "ConnectorKyberUnknownMethod");
        }
    }
};
//# sourceMappingURL=kyber.connector.js.map
import * as viem from "viem";
import { ChainId } from "../common.types";
import { buffersAreEqual, tokenAddressToString, tokenStringToBuffer } from "../utils";
import { SwapConnector, } from "./swap.connector";
import { SyncSwapClassicPoolABI } from "./assets/SyncSwapClassicPool.abi";
import { SyncSwapRouterABI } from "./assets/SyncSwapRouter.abi";
const SyncSwapRouterAddress = "0x80e38291e06339d10AAB483C65695D004dBD5C69";
const SyncSwapPoolFactory = "0x37BAc764494c8db4e54BDE72f6965beA9fa0AC2d";
const SyncSwapUSDCWETHPool = "0x5Ec5b1E9b1Bd5198343ABB6E55Fb695d2F7Bb308";
const quoteTTL = 600n; // 10min
const UsdcAddress = "0x176211869ca2b568f2a7d4ee941e073a821ee1ff";
const UsdcAddressBuf = tokenStringToBuffer(ChainId.Linea, UsdcAddress);
const wEthAddress = "0xe5d7c2a44ffddf6b295a15c148167daaaf5cf34f";
const wEthAddressBuf = tokenStringToBuffer(ChainId.Linea, wEthAddress);
const EthAddressBuf = Buffer.alloc(20, 0);
const supportedTokens = [UsdcAddressBuf, wEthAddressBuf];
function getPath(tokenIn, tokenOut) {
    tokenIn = buffersAreEqual(tokenIn, EthAddressBuf) ? wEthAddressBuf : tokenIn;
    tokenOut = buffersAreEqual(tokenIn, EthAddressBuf) ? wEthAddressBuf : tokenOut;
    const index1 = supportedTokens.findIndex((v) => buffersAreEqual(v, tokenIn));
    const index2 = supportedTokens.findIndex((v) => buffersAreEqual(v, tokenOut));
    if (index2 > index1) {
        return supportedTokens.slice(index1, index2 + 1);
    }
    return supportedTokens.slice(index2, index1 + 1).reverse();
}
function checkTokens(tokenIn, tokenOut) {
    const hasTokenIn = undefined !== supportedTokens.find((v) => buffersAreEqual(v, tokenIn));
    const hasTokenOut = undefined !== supportedTokens.find((v) => buffersAreEqual(v, tokenOut));
    const areEqual = buffersAreEqual(tokenIn, tokenOut);
    if (areEqual)
        throw new Error(`In and out tokens are equal`);
    if (!hasTokenIn)
        throw new Error(`Unsupported input token (${tokenAddressToString(ChainId.Linea, tokenIn)})`);
    if (!hasTokenOut)
        throw new Error(`Unsupported output token (${tokenAddressToString(ChainId.Linea, tokenOut)})`);
}
function normalizeTokens(tokenIn, tokenOut) {
    const hasInputETH = buffersAreEqual(tokenIn, EthAddressBuf);
    const hasOutputETH = buffersAreEqual(tokenOut, EthAddressBuf);
    const normalizedTokens = {
        tokenInBuffer: hasInputETH ? wEthAddressBuf : tokenIn,
        tokenOutBuffer: hasOutputETH ? wEthAddressBuf : tokenOut,
        inputETH: hasInputETH,
        outputETH: hasOutputETH,
    };
    checkTokens(normalizedTokens.tokenInBuffer, normalizedTokens.tokenOutBuffer);
    return {
        ...normalizedTokens,
        tokenIn: tokenAddressToString(ChainId.Linea, normalizedTokens.tokenInBuffer),
        tokenOut: tokenAddressToString(ChainId.Linea, normalizedTokens.tokenOutBuffer),
        path: getPath(normalizedTokens.tokenInBuffer, normalizedTokens.tokenOutBuffer),
    };
}
function hexAddress(address) {
    return tokenAddressToString(ChainId.Linea, address);
}
export class LineaSyncSwapUsdcLP extends SwapConnector {
    constructor(connection) {
        super();
        this.connection = connection;
    }
    async getTx(normalizedTokens, amountIn, minAmountOut, swapOutcomeRecipient) {
        const { timestamp } = await this.connection.eth.getBlock("latest");
        const deadline = BigInt(timestamp) + quoteTTL;
        const swapData = viem.encodeAbiParameters([
            { name: "tokenIn", type: "address" },
            { name: "recipient", type: "address" },
            { name: "withdrawMode", type: "uint8" },
        ], [normalizedTokens.tokenIn, swapOutcomeRecipient, normalizedTokens.outputETH ? 1 : 2]);
        // 1 LP = 1 step
        const steps = [
            {
                pool: SyncSwapUSDCWETHPool,
                data: swapData,
                callback: viem.zeroAddress,
                callbackData: "0x",
            },
        ];
        // Only one path
        const paths = [
            {
                steps: steps,
                tokenIn: normalizedTokens.inputETH ? viem.zeroAddress : normalizedTokens.tokenIn,
                amountIn: amountIn,
            },
        ];
        const swapCall = viem.encodeFunctionData({
            abi: SyncSwapRouterABI,
            functionName: "swap",
            args: [paths, minAmountOut, deadline],
        });
        return {
            to: SyncSwapRouterAddress,
            data: swapCall,
            value: normalizedTokens.inputETH ? amountIn.toString() : "0",
        };
    }
    async getSwap(request, context) {
        if (!request.destReceiver)
            throw new Error(`${LineaSyncSwapUsdcLP.name}: destReceiver must be explicitly set`);
        if (request.chainId !== ChainId.Linea)
            throw new Error(`Unsupported chain: ${request.chainId}, expected Linea`);
        const normalizedTokens = normalizeTokens(request.fromTokenAddress, request.toTokenAddress);
        const estimation = await this.getEstimate(request, context);
        const amountOutMin = (estimation.amountOut * (10000n - BigInt(request.slippageBps))) / 10000n;
        return {
            amountIn: request.amountIn,
            amountOut: estimation.amountOut,
            fromToken: request.fromTokenAddress,
            toToken: request.toTokenAddress,
            rawConnectorResponse: null,
            engine: "evm",
            tx: await this.getTx(normalizedTokens, request.amountIn, amountOutMin, hexAddress(request.destReceiver)),
        };
    }
    async getEstimate(request, context) {
        if (request.chainId !== ChainId.Linea)
            throw new Error(`Unsupported chain: ${request.chainId}, expected Linea`);
        const normalizedTokens = normalizeTokens(request.fromTokenAddress, request.toTokenAddress);
        const rawAmountsOut = await this.connection.eth.call({
            to: SyncSwapUSDCWETHPool,
            data: viem.encodeFunctionData({
                abi: SyncSwapClassicPoolABI,
                functionName: "getAmountOut",
                args: [normalizedTokens.tokenIn, request.amountIn, viem.zeroAddress /* sender, not used; zero address works */],
            }),
        });
        const amountOut = viem.decodeFunctionResult({
            abi: SyncSwapClassicPoolABI,
            functionName: "getAmountOut",
            data: rawAmountsOut,
        });
        return {
            chainId: request.chainId,
            fromTokenAddress: request.fromTokenAddress,
            toTokenAddress: request.toTokenAddress,
            amountIn: request.amountIn,
            amountOut,
        };
    }
    getSupportedChains() {
        return [ChainId.Linea];
    }
    get connectorName() {
        return LineaSyncSwapUsdcLP.name;
    }
}
//# sourceMappingURL=linea-syncswap-usdc-lp.connector.js.map
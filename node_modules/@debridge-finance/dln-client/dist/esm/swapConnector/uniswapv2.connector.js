var _UniswapV2Connector_instances, _UniswapV2Connector_findTokenSwapPath;
import { __classPrivateFieldGet } from "tslib";
import { decodeFunctionResult, encodeFunctionData } from "viem";
import { buffersAreEqual, tokenAddressToString } from "../utils";
import { SwapConnector, } from "./swap.connector";
import { UniswapV2RouterABI } from "./assets/UniswapV2Router";
import { SwapConnectorError } from "./errors/swap-connector.error";
import { SwapConnectorErrorType } from "./errors/swap-connector-error.type";
export class UniswapV2Connector extends SwapConnector {
    constructor(connection, chainId, tokens, routerAddress, wethAddress, ethPlaceholderAddress = Buffer.alloc(20, 0), quoteTTL = 600n) {
        super();
        _UniswapV2Connector_instances.add(this);
        this.connection = connection;
        this.chainId = chainId;
        this.tokens = tokens;
        this.routerAddress = routerAddress;
        this.wethAddress = wethAddress;
        this.ethPlaceholderAddress = ethPlaceholderAddress;
        this.quoteTTL = quoteTTL;
    }
    getPath(tokenIn, tokenOut) {
        tokenIn = buffersAreEqual(tokenIn, this.ethPlaceholderAddress) ? this.wethAddress : tokenIn;
        tokenOut = buffersAreEqual(tokenIn, this.ethPlaceholderAddress) ? this.wethAddress : tokenOut;
        if (buffersAreEqual(tokenIn, tokenOut))
            this.throwError(SwapConnectorErrorType.InputValidationError, `In and out tokens are equal`);
        const path = __classPrivateFieldGet(this, _UniswapV2Connector_instances, "m", _UniswapV2Connector_findTokenSwapPath).call(this, tokenIn, tokenOut);
        if (!path) {
            this.throwError(SwapConnectorErrorType.UnsupportedTokenAddress, "Path between tokens not found");
        }
        return path;
    }
    normalizeTokens(tokenIn, tokenOut) {
        const hasInputETH = buffersAreEqual(tokenIn, this.ethPlaceholderAddress);
        const hasOutputETH = buffersAreEqual(tokenOut, this.ethPlaceholderAddress);
        const normalizedTokens = {
            tokenIn: hasInputETH ? this.wethAddress : tokenIn,
            tokenOut: hasOutputETH ? this.wethAddress : tokenOut,
            inputETH: hasInputETH,
            outputETH: hasOutputETH,
        };
        return {
            ...normalizedTokens,
            path: this.getPath(normalizedTokens.tokenIn, normalizedTokens.tokenOut),
        };
    }
    async getTx(normalizedTokens, amountIn, minAmountOut, swapOutcomeRecipient) {
        const { timestamp } = await this.connection.eth.getBlock("latest");
        const deadline = BigInt(timestamp) + this.quoteTTL;
        const path = normalizedTokens.path.map((buffer) => tokenAddressToString(this.chainId, buffer));
        if (normalizedTokens.inputETH) {
            return {
                to: tokenAddressToString(this.chainId, this.routerAddress),
                data: encodeFunctionData({
                    abi: UniswapV2RouterABI,
                    functionName: "swapExactETHForTokens",
                    args: [minAmountOut, path, tokenAddressToString(this.chainId, swapOutcomeRecipient), deadline],
                }),
                value: amountIn.toString(),
            };
        }
        else if (normalizedTokens.outputETH) {
            return {
                to: tokenAddressToString(this.chainId, this.routerAddress),
                data: encodeFunctionData({
                    abi: UniswapV2RouterABI,
                    functionName: "swapExactTokensForETH",
                    args: [
                        amountIn,
                        minAmountOut,
                        path,
                        tokenAddressToString(this.chainId, swapOutcomeRecipient),
                        deadline,
                    ],
                }),
                value: "0",
            };
        }
        else {
            return {
                to: tokenAddressToString(this.chainId, this.routerAddress),
                data: encodeFunctionData({
                    abi: UniswapV2RouterABI,
                    functionName: "swapExactTokensForTokens",
                    args: [
                        amountIn,
                        minAmountOut,
                        path,
                        tokenAddressToString(this.chainId, swapOutcomeRecipient),
                        deadline,
                    ],
                }),
                value: "0",
            };
        }
    }
    async getSwap(request, context) {
        if (!request.destReceiver)
            this.throwError(SwapConnectorErrorType.InputValidationError, `destReceiver must be explicitly set`);
        if (request.chainId !== this.chainId)
            this.throwError(SwapConnectorErrorType.UnsupportedChain, `Unsupported`);
        const normalizedTokens = this.normalizeTokens(request.fromTokenAddress, request.toTokenAddress);
        const estimation = await this.getEstimate(request, context);
        const amountOutMin = (estimation.amountOut * (10000n - BigInt(request.slippageBps))) / 10000n;
        return {
            amountIn: request.amountIn,
            amountOut: estimation.amountOut,
            fromToken: request.fromTokenAddress,
            toToken: request.toTokenAddress,
            rawConnectorResponse: null,
            engine: "evm",
            tx: await this.getTx(normalizedTokens, request.amountIn, amountOutMin, request.destReceiver),
        };
    }
    async getEstimate(request, context) {
        if (request.chainId !== this.chainId)
            this.throwError(SwapConnectorErrorType.UnsupportedChain, "Unsupported");
        const normalizedTokens = this.normalizeTokens(request.fromTokenAddress, request.toTokenAddress);
        // uint[] memory quote = MoraSwapV2Router(NEON_POOL).getAmountsOut(reserveAmount, path);
        const rawAmountsOut = await this.connection.eth.call({
            to: tokenAddressToString(this.chainId, this.routerAddress),
            data: encodeFunctionData({
                abi: UniswapV2RouterABI,
                functionName: "getAmountsOut",
                args: [
                    request.amountIn,
                    normalizedTokens.path.map((address) => tokenAddressToString(this.chainId, address)),
                ],
            }),
        });
        const amountsOut = decodeFunctionResult({
            abi: UniswapV2RouterABI,
            functionName: "getAmountsOut",
            data: rawAmountsOut,
        });
        const lastAmount = amountsOut.at(-1);
        if (!lastAmount)
            this.throwError(SwapConnectorErrorType.InternalError, `Fatal error: getAmountsOut returned nothing`);
        return {
            chainId: request.chainId,
            fromTokenAddress: request.fromTokenAddress,
            toTokenAddress: request.toTokenAddress,
            amountIn: request.amountIn,
            amountOut: lastAmount,
        };
    }
    getSupportedChains() {
        return [this.chainId];
    }
    get connectorName() {
        return `${UniswapV2Connector.name}@${this.chainId}`;
    }
    throwError(type, message) {
        throw new SwapConnectorError(`${this.connectorName}`, type, message);
    }
}
_UniswapV2Connector_instances = new WeakSet(), _UniswapV2Connector_findTokenSwapPath = function _UniswapV2Connector_findTokenSwapPath(startToken, endToken) {
    // Build adjacency list (graph)
    const graph = {};
    for (const [token1, token2] of this.tokens) {
        const [tokenId1, tokenId2] = [token1.toString(), token2.toString()];
        if (!graph[tokenId1])
            graph[tokenId1] = new Set();
        if (!graph[tokenId2])
            graph[tokenId2] = new Set();
        graph[tokenId1].add(token2);
        graph[tokenId2].add(token1);
    }
    // DFS to find path
    const visited = new Set();
    const path = [];
    function dfs(currentToken) {
        // If we found the end token, return true
        if (buffersAreEqual(currentToken, endToken)) {
            path.push(currentToken);
            return true;
        }
        visited.add(currentToken);
        path.push(currentToken);
        // Explore neighbors
        for (const neighbor of graph[currentToken.toString()] || []) {
            if (!visited.has(neighbor)) {
                if (dfs(neighbor)) {
                    return true;
                }
            }
        }
        // If no path found, backtrack
        path.pop();
        return false;
    }
    // Start DFS from the startToken
    if (dfs(startToken)) {
        return path;
    }
    // If no path found, return null
    return null;
};
//# sourceMappingURL=uniswapv2.connector.js.map
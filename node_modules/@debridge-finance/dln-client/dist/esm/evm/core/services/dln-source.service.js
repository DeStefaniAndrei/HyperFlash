import BigNumber from "bignumber.js";
import { SupportedEVMChains, } from "../types/common.type";
import DlnSource from "../../assets/abi/DlnSource.json";
import LimaDlnSource from "../../assets/abi/LimaDlnSource.json";
import { ContractCache } from "../utils/contract-cache.class";
import { BPS_DENOMINATOR, ChainId } from "../../../common.types";
import { ClientErrorType } from "../../../errors/client-error-type.enum";
import { ClientError } from "../../../errors/client-error.error";
import { Env } from "../../../common/env";
import { getCorrectedGasLimit, predictGasPrice } from "./gasprice.service";
import { getL1FeeNativeCost, isOpStackBasedChain } from "./opstack.service";
//https://optimistic.etherscan.io/tx/0xb053e406c6f836bb3ea3885a6b0f706a0d573c2cf5039108f77af10c4829431a
const OP_TXDATA_GAS_CLAIM_BATCH_UNLOCK = 25000n;
//https://optimistic.etherscan.io/tx/0x03cff04008617bce29545d837ad946db75e4cabe1ca168a657b24cf60395782b
const OP_TXDATA_GAS_CLAIM_CANCEL = 35000n;
const EVM_GASLIMIT_CLAIM_BASE = {
    [ChainId.Arbitrum]: 400000,
    [ChainId.Avalanche]: 400000,
    [ChainId.Base]: 400000,
    [ChainId.Bitrock]: 400000,
    [ChainId.BSC]: 400000,
    [ChainId.Ethereum]: 400000,
    [ChainId.Fantom]: 400000 * 2,
    [ChainId.Gnosis]: 400000,
    [ChainId.LightLink]: 400000,
    [ChainId.Linea]: 400000,
    [ChainId.Metis]: 400000,
    [ChainId.Neon]: 0,
    [ChainId.Optimism]: 400000,
    [ChainId.Polygon]: 400000,
};
const EVM_GASLIMIT_CLAIM_UNLOCK_PER_ORDER = {
    [ChainId.Arbitrum]: 50000,
    [ChainId.Avalanche]: 50000,
    [ChainId.Base]: 50000,
    [ChainId.Bitrock]: 50000,
    [ChainId.BSC]: 50000,
    [ChainId.Ethereum]: 50000,
    [ChainId.Fantom]: 50000 * 2,
    [ChainId.Gnosis]: 50000,
    [ChainId.LightLink]: 50000,
    [ChainId.Linea]: 50000,
    [ChainId.Metis]: 50000,
    // reserve gas for: exFee transfer, unlock transfer, affiliate fee transfer
    // tx: 0xaa9b5c2b2e506884e5afcb5538ae3a41ee1fabaca62ff0462a74ef578eb876f2
    // assume that batch_size is 1
    [ChainId.Neon]: 4000000,
    [ChainId.Optimism]: 50000,
    [ChainId.Polygon]: 50000,
};
const EVM_GASLIMIT_CLAIM_CANCEL_PER_ORDER = {
    [ChainId.Arbitrum]: 50000,
    [ChainId.Avalanche]: 50000,
    [ChainId.Base]: 50000,
    [ChainId.Bitrock]: 50000,
    [ChainId.BSC]: 50000,
    [ChainId.Ethereum]: 50000,
    [ChainId.Fantom]: 50000 * 2,
    [ChainId.Gnosis]: 50000,
    [ChainId.LightLink]: 50000,
    [ChainId.Linea]: 50000,
    [ChainId.Metis]: 50000,
    // tx: 0xcf5cecae9a4c1b3644625f1126e4f57cd754fb516d34765d5dac3ba61814abc8
    [ChainId.Neon]: 2000000,
    [ChainId.Optimism]: 50000,
    [ChainId.Polygon]: 50000,
};
export class DlnSourceService extends ContractCache {
    constructor(enableContractsCache = true, version = Env.Prod) {
        super(enableContractsCache);
        this.version = version;
    }
    getCreateOrderMethod(provider, contractAddress, orderCreation, affiliateFee, referralCode, permit) {
        const contract = this.getContract(provider, contractAddress);
        return contract.methods.createOrder(orderCreation, affiliateFee, referralCode, permit);
    }
    getCreateSaltedOrderMethod(provider, contractAddress, orderCreation, salt, affiliateFee, referralCode, permit, metadata) {
        const contract = this.getContract(provider, contractAddress);
        return contract.methods.createSaltedOrder(orderCreation, salt, affiliateFee, referralCode, permit, metadata);
    }
    getPatchOrderGiveMethod(provider, contractAddress, order, amount, permit) {
        const contract = this.getContract(provider, contractAddress);
        return contract.methods.patchOrderGive(order, amount, permit);
    }
    async getClaimBatchUnlockNativeCostForSingleOrder(batchUnlockCoverage, chain, provider, orderEstimationStage, payload) {
        const logger = (...params) => payload?.loggerInstance?.verbose("[getClaimBatchUnlockNativeCostForSingleOrder]", ...params);
        if (batchUnlockCoverage < 0.1 || batchUnlockCoverage > 1)
            throw new ClientError(ClientErrorType.WrongBatchSize, `batchUnlockCoverage must be within [0.1, 1]`);
        const supportedChain = chain;
        if (!Object.values(SupportedEVMChains).includes(supportedChain))
            throw new ClientError(ClientErrorType.UnsupportedChain);
        // (claim_base / batch_size) + claim_unlock_per_order
        const projectedGasLimit = EVM_GASLIMIT_CLAIM_BASE[supportedChain] * batchUnlockCoverage +
            EVM_GASLIMIT_CLAIM_UNLOCK_PER_ORDER[supportedChain];
        logger(`projected gasLimit: ${projectedGasLimit.toString()}`);
        const gasLimit = await getCorrectedGasLimit(chain, provider, projectedGasLimit);
        logger(`corrected gasLimit: ${gasLimit.toString()}`);
        // gas price
        const gasPrice = await predictGasPrice(chain, provider, orderEstimationStage);
        logger(`predicted gasPrice: ${gasPrice.toString()}`);
        // cost
        let fee = gasPrice.multipliedBy(gasLimit);
        logger(`calculated tx fee: ${fee.toString()}`);
        // op stack
        if (isOpStackBasedChain(chain)) {
            const l1Fee = await getL1FeeNativeCost(chain, provider, OP_TXDATA_GAS_CLAIM_BATCH_UNLOCK, payload);
            const l1FeePerOrder = (l1Fee * BigInt(Math.round(batchUnlockCoverage * Number(BPS_DENOMINATOR)))) / BPS_DENOMINATOR;
            fee = fee.plus(l1FeePerOrder.toString());
            logger(`calculated l1 fee: ${l1Fee}, per order: ${l1FeePerOrder}, total fee: ${fee.toString()}`);
        }
        return {
            totalCost: BigInt(fee.integerValue().toString()),
            gasPrice: BigInt(gasPrice.integerValue().toString()),
            gasLimit: BigInt(gasLimit.integerValue().toString()),
            chainId: chain,
        };
    }
    async getClaimBatchUnlockExecutionFee(batchSize, chain, provider, orderEstimationStage, payload) {
        const logger = (...params) => payload?.loggerInstance?.verbose("[getClaimBatchUnlockExecutionFee]", ...params);
        if (batchSize < 1 || batchSize > 10)
            throw new ClientError(ClientErrorType.WrongBatchSize, `batchSize must be within [1, 10]`);
        const supportedChain = chain;
        if (!Object.values(SupportedEVMChains).includes(supportedChain))
            throw new ClientError(ClientErrorType.UnsupportedChain);
        // claim_base + (claim_unlock_per_order * batchSize)
        const gasLimit = await getCorrectedGasLimit(chain, provider, EVM_GASLIMIT_CLAIM_BASE[supportedChain] + EVM_GASLIMIT_CLAIM_UNLOCK_PER_ORDER[supportedChain] * batchSize);
        logger(`target gasLimit: ${gasLimit.toString()}`);
        // gas price
        const gasPrice = await predictGasPrice(chain, provider, orderEstimationStage);
        logger(`predicted gasPrice: ${gasPrice.toString()}`);
        // cost
        let fee = gasPrice.multipliedBy(gasLimit);
        logger(`calculated tx fee: ${fee.toString()}`);
        // op stack
        if (isOpStackBasedChain(chain)) {
            const l1Fee = await getL1FeeNativeCost(chain, provider, OP_TXDATA_GAS_CLAIM_BATCH_UNLOCK, payload);
            fee = fee.plus(l1Fee.toString());
            logger(`calculated l1 fee: ${l1Fee}, total fee: ${fee.toString()}`);
        }
        return {
            totalCost: BigInt(fee.integerValue().toString()),
            gasPrice: BigInt(gasPrice.integerValue().toString()),
            gasLimit: BigInt(gasLimit.integerValue().toString()),
            chainId: chain,
        };
    }
    async getClaimUnlockExecutionFee(chain, provider, orderEstimationStage, payload) {
        const logger = (...params) => payload?.loggerInstance?.verbose("[getClaimUnlockExecutionFee]", ...params);
        const supportedChain = chain;
        if (!Object.values(SupportedEVMChains).includes(supportedChain))
            throw new ClientError(ClientErrorType.UnsupportedChain);
        // claim_base + (claim_unlock_per_order)
        const gasLimit = await getCorrectedGasLimit(chain, provider, EVM_GASLIMIT_CLAIM_BASE[supportedChain] + EVM_GASLIMIT_CLAIM_UNLOCK_PER_ORDER[supportedChain]);
        logger(`target gasLimit: ${gasLimit.toString()}`);
        // gas price
        const gasPrice = await predictGasPrice(chain, provider, orderEstimationStage);
        logger(`predicted gasPrice: ${gasPrice.toString()}`);
        // cost
        let fee = gasPrice.multipliedBy(gasLimit);
        logger(`calculated tx fee: ${fee.toString()}`);
        // op stack
        if (isOpStackBasedChain(chain)) {
            const l1Fee = await getL1FeeNativeCost(chain, provider, OP_TXDATA_GAS_CLAIM_BATCH_UNLOCK, payload);
            fee = fee.plus(l1Fee.toString());
            logger(`calculated l1 fee: ${l1Fee}, total fee: ${fee.toString()}`);
        }
        return {
            totalCost: BigInt(fee.integerValue().toString()),
            gasPrice: BigInt(gasPrice.integerValue().toString()),
            gasLimit: BigInt(gasLimit.integerValue().toString()),
            chainId: chain,
        };
    }
    async getClaimCancelExecutionFee(chain, provider, orderEstimationStage, payload) {
        const logger = (...params) => payload?.loggerInstance?.verbose("[getClaimCancelExecutionFee]", ...params);
        const supportedChain = chain;
        if (!Object.values(SupportedEVMChains).includes(supportedChain))
            throw new ClientError(ClientErrorType.UnsupportedChain);
        // claim_base + (claim_cancel_per_order)
        const gasLimit = await getCorrectedGasLimit(chain, provider, EVM_GASLIMIT_CLAIM_BASE[supportedChain] + EVM_GASLIMIT_CLAIM_CANCEL_PER_ORDER[supportedChain]);
        logger(`target gasLimit: ${gasLimit.toString()}`);
        // gas price
        let gasPrice = await predictGasPrice(chain, provider, orderEstimationStage);
        if (chain === ChainId.BSC) {
            gasPrice = BigNumber.max(gasPrice, BigNumber("5000000000")); // 5 gwei
        }
        logger(`predicted gasPrice: ${gasPrice.toString()}`);
        // cost
        let fee = gasPrice.multipliedBy(gasLimit);
        logger(`calculated tx fee: ${fee.toString()}`);
        // op stack
        if (isOpStackBasedChain(chain)) {
            const l1Fee = await getL1FeeNativeCost(chain, provider, OP_TXDATA_GAS_CLAIM_CANCEL, payload);
            fee = fee.plus(l1Fee.toString());
            logger(`calculated l1 fee: ${l1Fee}, total fee: ${fee.toString()}`);
        }
        return {
            totalCost: BigInt(fee.integerValue().toString()),
            gasPrice: BigInt(gasPrice.integerValue().toString()),
            gasLimit: BigInt(gasLimit.integerValue().toString()),
            chainId: chain,
        };
    }
    async getGlobalFixedNativeFee(provider, contractAddress) {
        const contract = this.getContract(provider, contractAddress);
        const result = await contract.methods.globalFixedNativeFee().call({});
        return result?.toString() || "0";
    }
    async getGlobalTransferFeeBps(provider, contractAddress) {
        const contract = this.getContract(provider, contractAddress);
        const result = await contract.methods.globalTransferFeeBps().call({});
        return result?.toString() || "0";
    }
    async giveOrder(provider, contractAddress, orderId) {
        const contract = this.getContract(provider, contractAddress);
        const result = (await contract.methods.giveOrders(orderId).call({}));
        if (result) {
            result.status = parseInt(result.status.toString(), 10);
        }
        return result || null;
    }
    async givePatches(provider, contractAddress, orderId) {
        const contract = this.getContract(provider, contractAddress);
        const patches = await contract.methods.givePatches(orderId).call({});
        if (!patches)
            return BigInt(0);
        return BigInt(patches);
    }
    createContract(provider, contractAddress) {
        return new provider.eth.Contract((this.version === Env.Prod ? DlnSource.abi : LimaDlnSource.abi), contractAddress);
    }
}
//# sourceMappingURL=dln-source.service.js.map
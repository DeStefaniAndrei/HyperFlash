import BigNumber from "bignumber.js";
import { SupportedEVMChains, } from "../types/common.type";
import DlnDestination from "../../assets/abi/DlnDestination.json";
import LimaDlnDestination from "../../assets/abi/LimaDlnDestination.json";
import { ContractCache } from "../utils/contract-cache.class";
import { BPS_DENOMINATOR, ChainId, } from "../../../common.types";
import { ClientError } from "../../../errors/client-error.error";
import { ClientErrorType } from "../../../errors/client-error-type.enum";
import { orderToEvm } from "../utils/order.data.to.evm";
import { Env } from "../../../common/env";
import { getCorrectedGasLimit, predictGasPrice } from "./gasprice.service";
import { getL1FeeNativeCost, isOpStackBasedChain } from "./opstack.service";
// https://optimistic.etherscan.io/tx/0x037ea7d57b8b3ffb825b3ab3c92cad8be4d6b2938de2ea65bb91616c1ba644d3
const OP_TXDATA_GAS_SEND_UNLOCK_EVM = 10000n;
// https://optimistic.etherscan.io/tx/0xad96410898f375b11729ddd9e43f0bab1b6910a99aa5a98976fdf277fe7c6e03
const OP_TXDATA_GAS_SEND_UNLOCK_SOLANA = 50000n;
// https://optimistic.etherscan.io/tx/0x95af5d316451db99e66aa441516dcaf6fc538c5c564e02270b31526f54a3a255
const OP_TXDATA_GAS_FULFILL = 9000n;
// https://optimistic.etherscan.io/tx/0x230b959cac6e391f185e452c04bafd9bfbaf4ab5e1ef30ecd64dea0024ba6944
const OP_TXDATA_GAS_FULFILL_WITH_SWAP = 25000n;
const EVM_GASLIMIT_SEND_UNLOCK_BASE = {
    [ChainId.Arbitrum]: 140000,
    [ChainId.Avalanche]: 150000,
    [ChainId.Base]: 140000,
    // 0x2b56130fd807d852f4ef37b53b0b46e5a439eaa269a756344fd10eddd18d4715
    [ChainId.Bitrock]: 200000,
    [ChainId.BSC]: 140000,
    [ChainId.Ethereum]: 140000,
    [ChainId.Fantom]: 140000 * 2,
    [ChainId.Gnosis]: 140000,
    [ChainId.LightLink]: 140000,
    [ChainId.Linea]: 140000,
    [ChainId.Metis]: 140000,
    // Neon does not uses opcode pricing, so we estimate txn by the number of orders (see the per order pricing)
    [ChainId.Neon]: 10000,
    [ChainId.Optimism]: 140000,
    [ChainId.Polygon]: 140000,
};
const EVM_GASLIMIT_SEND_UNLOCK_PER_ORDER_DEFAULT = {
    [ChainId.Arbitrum]: 20000,
    [ChainId.Avalanche]: 20000,
    [ChainId.Base]: 20000,
    [ChainId.Bitrock]: 20000,
    [ChainId.BSC]: 20000,
    [ChainId.Ethereum]: 20000,
    [ChainId.Fantom]: 20000 * 2,
    [ChainId.Gnosis]: 20000,
    [ChainId.LightLink]: 20000,
    [ChainId.Linea]: 20000,
    [ChainId.Metis]: 20000,
    // batch(1) and batch(2) are eating 10K gas,
    // while batch(10) is eating 275K, so assume 300k/10 is the per_order cost of send_unlock
    // tx: 0xd1de7422f2d1ed0ce5533f3ea4b9d9d047aa2f67ecfedf9fca7da054f02c935a
    [ChainId.Neon]: 30000,
    [ChainId.Optimism]: 20000,
    [ChainId.Polygon]: 20000,
};
const EVM_GASLIMIT_SEND_UNLOCK_PER_ORDER_OVERRIDES = [
    {
        giveChainId: ChainId.Solana,
        takeChainId: SupportedEVMChains.Neon,
        gasLimit: 300000,
    },
];
function getGasLimitSendUnlockPerOrder(input) {
    const overrides = EVM_GASLIMIT_SEND_UNLOCK_PER_ORDER_OVERRIDES.find((_) => input.giveChainId === _.giveChainId && input.takeChainId === _.takeChainId)?.gasLimit;
    if (!overrides) {
        return EVM_GASLIMIT_SEND_UNLOCK_PER_ORDER_DEFAULT[input.takeChainId];
    }
    return overrides;
}
export class DlnDestinationService extends ContractCache {
    constructor(enableContractsCache = true, version = Env.Prod) {
        super(enableContractsCache);
        this.version = version;
    }
    bytesLikeToString(data) {
        return typeof data === "string" ? data : "0x" + Buffer.from(Array.from(data)).toString("hex");
    }
    /**
     * Method for calculation cost in native of fullfill
     * @param takeChain take chain
     * @param inToken input token for preswap
     * @param outToken take token
     * @param takeProvider web3
     * @param orderEstimationStage estimation type
     * @param calculationDetails details for calculation
     * @param cappedGasPrice gas price
     * @param payload chain-specific payload
     */
    async getRawFulfillNativeCost(chain, provider, orderEstimationStage, gasLimit, cappedGasPrice, hasSwap, payload) {
        const logger = (...params) => payload?.loggerInstance?.verbose("[getRawFulfillNativeCost]", ...params);
        const supportedChain = chain;
        if (!Object.values(SupportedEVMChains).includes(supportedChain))
            throw new ClientError(ClientErrorType.UnsupportedChain);
        logger(`target gasLimit: ${gasLimit.toString()}`);
        // gas price
        const gasPrice = cappedGasPrice
            ? new BigNumber(cappedGasPrice.toString())
            : await predictGasPrice(chain, provider, orderEstimationStage);
        logger(`predicted gasPrice: ${gasPrice.toString()}`);
        // cost
        let fee = gasPrice.multipliedBy(gasLimit.toString());
        logger(`calculated tx fee: ${fee.toString()}`);
        // op stack
        if (isOpStackBasedChain(chain)) {
            const l1Fee = await getL1FeeNativeCost(chain, provider, hasSwap ? OP_TXDATA_GAS_FULFILL_WITH_SWAP : OP_TXDATA_GAS_FULFILL, payload);
            fee = fee.plus(l1Fee.toString());
            logger(`calculated l1 fee: ${l1Fee} for fulfill ${hasSwap ? "with" : "without"} swap, total fee: ${fee.toString()}`);
        }
        return {
            totalCost: BigInt(fee.integerValue().toString()),
            gasPrice: BigInt(gasPrice.integerValue().toString()),
            gasLimit: gasLimit,
            chainId: chain,
        };
    }
    async getSendCancelCost(giveChainId, takeChainId, provider, orderEstimationStage, payload) {
        // Same as sendUnlock cost at the moment
        return this.getSendBatchUnlockNativeCost(1, giveChainId, takeChainId, provider, orderEstimationStage, payload);
    }
    async getSendUnlockNativeCost(giveChainId, takeChainId, provider, orderEstimationStage, payload) {
        return this.getSendBatchUnlockNativeCost(1, giveChainId, takeChainId, provider, orderEstimationStage, payload);
    }
    async getSendBatchUnlockNativeCost(batchSize, giveChainId, takeChainId, provider, orderEstimationStage, payload) {
        const logger = (...params) => payload?.loggerInstance?.verbose("[getSendBatchUnlockNativeCost]", ...params);
        const supportedChain = takeChainId;
        if (!Object.values(SupportedEVMChains).includes(supportedChain))
            throw new ClientError(ClientErrorType.UnsupportedChain);
        const gasLimitUnlockPerOrder = getGasLimitSendUnlockPerOrder({ giveChainId, takeChainId: supportedChain });
        // send_unlock_base + send_unlock_per_order * batchSize
        const gasLimit = await getCorrectedGasLimit(takeChainId, provider, EVM_GASLIMIT_SEND_UNLOCK_BASE[supportedChain] + gasLimitUnlockPerOrder * batchSize);
        logger(`target gasLimit: ${gasLimit.toString()}`);
        // gas price
        const gasPrice = await predictGasPrice(takeChainId, provider, orderEstimationStage);
        logger(`predicted gasPrice: ${gasPrice.toString()}`);
        let fee = gasPrice.multipliedBy(gasLimit);
        logger(`calculated tx fee: ${fee.toString()}`);
        // op stack
        if (isOpStackBasedChain(takeChainId)) {
            const l1Fee = await getL1FeeNativeCost(takeChainId, provider, giveChainId === ChainId.Solana ? OP_TXDATA_GAS_SEND_UNLOCK_SOLANA : OP_TXDATA_GAS_SEND_UNLOCK_EVM, payload);
            fee = fee.plus(l1Fee.toString());
            logger(`calculated l1 fee: ${l1Fee}, total fee: ${fee.toString()}`);
        }
        return {
            totalCost: BigInt(fee.integerValue().toString()),
            gasPrice: BigInt(gasPrice.integerValue().toString()),
            gasLimit: BigInt(gasLimit.integerValue().toString()),
            chainId: takeChainId,
        };
    }
    async getSendBatchUnlockNativeCostForSingleOrder(batchUnlockCoverage, giveChainId, takeChainId, provider, orderEstimationStage, payload) {
        const logger = (...params) => payload?.loggerInstance?.verbose("[getSendBatchUnlockNativeCostForSingleOrder]", ...params);
        if (batchUnlockCoverage < 0.1 || batchUnlockCoverage > 1)
            throw new ClientError(ClientErrorType.WrongBatchSize, `batchUnlockCoverage must be within [0.1, 1]`);
        const supportedChain = takeChainId;
        if (!Object.values(SupportedEVMChains).includes(supportedChain))
            throw new ClientError(ClientErrorType.UnsupportedChain);
        const gasLimitUnlockPerOrder = getGasLimitSendUnlockPerOrder({ giveChainId, takeChainId: supportedChain });
        // (send_unlock_base / batch_size) + send_unlock_per_order
        const projectedGasLimit = EVM_GASLIMIT_SEND_UNLOCK_BASE[supportedChain] * batchUnlockCoverage + gasLimitUnlockPerOrder;
        logger(`projected gasLimit: ${projectedGasLimit.toString()}`);
        const gasLimit = await getCorrectedGasLimit(takeChainId, provider, projectedGasLimit);
        logger(`estimated gasLimit: ${gasLimit.toString()}`);
        // gas price
        const gasPrice = await predictGasPrice(takeChainId, provider, orderEstimationStage);
        logger(`predicted gasPrice: ${gasPrice.toString()}`);
        // cost
        let fee = gasPrice.multipliedBy(gasLimit);
        logger(`calculated tx fee: ${fee.toString()}`);
        // op stack
        if (isOpStackBasedChain(takeChainId)) {
            const l1Fee = await getL1FeeNativeCost(takeChainId, provider, giveChainId === ChainId.Solana ? OP_TXDATA_GAS_SEND_UNLOCK_SOLANA : OP_TXDATA_GAS_SEND_UNLOCK_EVM, payload);
            const l1FeePerOrder = (l1Fee * BigInt(Math.round(batchUnlockCoverage * Number(BPS_DENOMINATOR)))) / BPS_DENOMINATOR;
            fee = fee.plus(l1FeePerOrder.toString());
            logger(`calculated l1 fee: ${l1Fee}, per order: ${l1FeePerOrder}, total fee: ${fee.toString()}`);
        }
        return {
            totalCost: BigInt(fee.integerValue().toString()),
            gasPrice: BigInt(gasPrice.integerValue().toString()),
            gasLimit: BigInt(gasLimit.integerValue().toString()),
            chainId: takeChainId,
        };
    }
    getFulfillOrderMethod(provider, contractAddress, order, fulFillAmount, orderId, permit, unlockAuthority, externalCallRewardBeneficiary) {
        const contract = this.getContract(provider, contractAddress);
        const evmOrder = orderToEvm(order);
        const fulfillArgs = [
            evmOrder,
            fulFillAmount,
            this.bytesLikeToString(orderId),
            this.bytesLikeToString(permit),
            this.bytesLikeToString(unlockAuthority),
        ];
        if (order.externalCall?.externalCallData) {
            if (externalCallRewardBeneficiary === undefined)
                throw new ClientError(ClientErrorType.RewardBeneficiaryRequired, "Reward beneficiary required if order.externalCall is present");
            fulfillArgs.push(this.bytesLikeToString(externalCallRewardBeneficiary));
        }
        return contract.methods.fulfillOrder(...fulfillArgs);
    }
    getPatchOrderTakeMethod(provider, contractAddress, order, subtrahend) {
        const contract = this.getContract(provider, contractAddress);
        return contract.methods.patchOrderTake(order, subtrahend);
    }
    async takePatches(provider, contractAddress, orderId) {
        const contract = this.getContract(provider, contractAddress);
        const patches = await contract.methods.takePatches(this.bytesLikeToString(orderId)).call({});
        if (!patches)
            return BigInt(0);
        return BigInt(patches);
    }
    sendBatchEvmUnlock(provider, contractAddress, orderIds, beneficiary, executionFee) {
        const contract = this.getContract(provider, contractAddress);
        return contract.methods.sendBatchEvmUnlock(orderIds.map((oid) => this.bytesLikeToString(oid)), beneficiary, executionFee);
    }
    sendBatchSolanaUnlock(provider, contractAddress, orders, beneficiary, claimFee, initWalletFee, claimUnlockFee) {
        const contract = this.getContract(provider, contractAddress);
        return contract.methods.sendBatchSolanaUnlock(orders.map((o) => orderToEvm(o)), this.bytesLikeToString(beneficiary), claimFee.toString(), initWalletFee.toString(), claimUnlockFee.toString());
    }
    getSendEvmUnlockMethod(provider, contractAddress, orderId, beneficiary, executionFee) {
        const contract = this.getContract(provider, contractAddress);
        return contract.methods.sendEvmUnlock(this.bytesLikeToString(orderId), beneficiary, executionFee.toString());
    }
    getSendEvmOrderCancelMethod(provider, contractAddress, order, cancelBeneficiary, executionFee) {
        const contract = this.getContract(provider, contractAddress);
        return contract.methods.sendEvmOrderCancel(order, cancelBeneficiary, executionFee);
    }
    getSendSolanaUnlockMethod(provider, contractAddress, order, beneficiary, executionFee, reward1, reward2) {
        const contract = this.getContract(provider, contractAddress);
        return contract.methods.sendSolanaUnlock(order, beneficiary, executionFee, reward1, reward2);
    }
    getSendSolanaOrderCancelMethod(provider, contractAddress, order, cancelBeneficiary, executionFee, reward1, reward2) {
        const contract = this.getContract(provider, contractAddress);
        return contract.methods.sendSolanaOrderCancel(order, cancelBeneficiary, executionFee, reward1, reward2);
    }
    async takeOrders(provider, contractAddress, orderId) {
        const contract = this.getContract(provider, contractAddress);
        const result = await contract.methods.takeOrders(this.bytesLikeToString(orderId)).call({});
        return result || null;
    }
    createContract(provider, contractAddress) {
        let contract;
        switch (this.version) {
            case Env.Lima: {
                contract = LimaDlnDestination.abi;
                break;
            }
            case Env.Hanoi:
            case Env.Madrid:
            case Env.Prod: {
                contract = DlnDestination.abi;
                break;
            }
            default: {
                throw new Error(`Unexpected env`);
            }
        }
        return new provider.eth.Contract(contract, contractAddress);
    }
}
//# sourceMappingURL=dln-destination.service.js.map
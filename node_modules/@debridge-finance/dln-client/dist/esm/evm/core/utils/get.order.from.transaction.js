import { helpers } from "@debridge-finance/solana-utils";
import Web3 from "web3";
import DlnSource from "../../assets/abi/DlnSource.json";
function getEventFromLogs(eventABI, logs, web3) {
    const address = null;
    const eventName = eventABI.name;
    if (!eventName)
        return null;
    if (!eventABI || !eventABI.inputs)
        return null;
    const eventSignature = `${eventName}(${eventABI.inputs
        .map((input) => {
        if (input.type === "tuple") {
            return `(${input.components.map((input) => input.type).join()})`;
        }
        return input.type;
    })
        .join(",")})`;
    const eventTopic = Web3.utils.sha3(eventSignature);
    // Only decode events of type 'EventName'
    const created = logs
        .filter((log) => log.topics.length > 0 && log.topics[0] === eventTopic && (!address || log.address === address))
        .map((log) => web3.eth.abi.decodeLog(eventABI.inputs, log.data, log.topics.slice(1)))
        .map((decoded) => ({ event: eventName, args: decoded }));
    if (!created || created.length === 0)
        return null;
    return created[0].args;
}
export function evmOrderToOrderData(order) {
    return {
        give: {
            chainId: Number(order.giveChainId),
            amount: BigInt(order.giveAmount),
            tokenAddress: helpers.hexToBuffer(order.giveTokenAddress),
        },
        take: {
            chainId: Number(order.takeChainId),
            amount: BigInt(order.takeAmount),
            tokenAddress: helpers.hexToBuffer(order.takeTokenAddress),
        },
        maker: helpers.hexToBuffer(order.makerSrc),
        nonce: BigInt(order.makerOrderNonce),
        receiver: helpers.hexToBuffer(order.receiverDst),
        givePatchAuthority: helpers.hexToBuffer(order.givePatchAuthoritySrc),
        orderAuthorityDstAddress: helpers.hexToBuffer(order.orderAuthorityAddressDst),
        allowedCancelBeneficiary: order.allowedCancelBeneficiarySrc != "0x" ? helpers.hexToBuffer(order.allowedCancelBeneficiarySrc) : undefined,
        allowedTaker: order.allowedTakerDst != "0x" ? helpers.hexToBuffer(order.allowedTakerDst) : undefined,
        externalCall: order.externalCall != "0x"
            ? {
                externalCallData: helpers.hexToBuffer(order.externalCall),
            }
            : undefined,
    };
}
export async function getOrderFromEvmTransaction(txHash, web3) {
    const txReceipt = await web3.eth.getTransactionReceipt(txHash);
    if (!txReceipt)
        return null;
    const eventName = "CreatedOrder";
    const eventABI = DlnSource.abi.find((item) => item.type === "event" && item.name === eventName);
    if (!eventABI)
        return null;
    const patchedEventAbi = JSON.parse(JSON.stringify(eventABI));
    patchedEventAbi.inputs?.pop();
    const createdOrderInfo = getEventFromLogs(eventABI, txReceipt.logs, web3) ||
        getEventFromLogs(patchedEventAbi, txReceipt.logs, web3);
    if (!createdOrderInfo)
        return null;
    const order = evmOrderToOrderData(createdOrderInfo.order);
    let affiliateInfo = undefined;
    if (createdOrderInfo.affiliateFee !== "0x" && createdOrderInfo.affiliateFee !== null) {
        affiliateInfo = {
            amount: BigInt("0x" + createdOrderInfo.affiliateFee.slice(42)),
            beneficiary: helpers.hexToBuffer(createdOrderInfo.affiliateFee.slice(0, 42)), // 0x + 20 hex bytes
        };
    }
    const blockInfo = await web3.eth.getBlock(txReceipt.blockHash);
    const blockTimestamp = typeof blockInfo.timestamp === "string"
        ? blockInfo.timestamp === ""
            ? undefined
            : Number(blockInfo.timestamp)
        : blockInfo.timestamp;
    return {
        ...order,
        orderId: helpers.hexToBuffer(createdOrderInfo.orderId),
        referralCode: Number(createdOrderInfo.referralCode),
        transferFee: BigInt(createdOrderInfo.percentFee),
        fixFee: BigInt(createdOrderInfo.nativeFixFee),
        createTimestamp: blockTimestamp,
        affiliateInfo,
    };
}
//# sourceMappingURL=get.order.from.transaction.js.map
import { ClientErrorType } from "../errors/client-error-type.enum";
import { ClientError } from "../errors/client-error.error";
import { getEngineByChainId, } from "../common.types";
export class CommonDlnClient {
    constructor(...clients) {
        this.clients = new Map();
        for (const client of clients || []) {
            this.clients.set(client.getEngine(), client);
        }
    }
    getClient(chain) {
        const engine = getEngineByChainId(chain);
        const client = this.clients.get(engine);
        if (!client)
            throw new ClientError(ClientErrorType.ClientMissing, `Client for chain ${chain} (engine ${engine}) is missing`);
        return client;
    }
    setClient(client) {
        this.clients.set(client.getEngine(), client);
    }
    getConnection(chain) {
        return this.getClient(chain).getConnection(chain);
    }
    getDecimals(chain, tokenAddress) {
        return this.getClient(chain).getDecimals(chain, tokenAddress);
    }
    getTokenInfo(chain, tokenAddress) {
        return this.getClient(chain).getTokenInfo(chain, tokenAddress);
    }
    /**
     * Get decimals of native token for requested chain
     * @param chain
     * @returns
     */
    getNativeCurrencyDecimals(chain) {
        return this.getClient(chain).nativeCurrencyDecimals;
    }
    /**
     * Get length of address for requested chain (addr len are same across engine)
     * @param chain
     * @returns
     */
    getAddressLength(chain) {
        return this.getClient(chain).addressLength;
    }
    /**
     * Parse address string (hex for evm, base58 for solana) into Address
     * @param chain
     * @param address string to parse
     * @returns
     */
    parseAddress(chain, address) {
        return this.getClient(chain).parseAddress(address);
    }
    /**
     * Build transaction to increase order give amount in give chain
     * @param params.order order to patch
     * @param params.amountToAdd amount to increase give offer by
     * @param payload chain-specific payload
     */
    patchOrderGive(params, payload) {
        return this.getClient(params.order.give.chainId).patchOrderGive(params, payload);
    }
    /**
     * Build transaction to decrease order take amount in take chain
     * @param params.order order to patch
     * @param params.amountToSub amount to decrease take offer by
     * @param payload chain-specific payload
     */
    patchOrderTake(params, payload) {
        return this.getClient(params.order.take.chainId).patchOrderTake(params, payload);
    }
    /**
     * Get final order.give amount including give patches
     * @param params arguments shared between all clients
     * @param params.order order to retrieve final give amount for
     * @param payload chain-specific payload
     */
    getFinalGiveAmount(params, payload) {
        return this.getClient(params.order.give.chainId).getFinalGiveAmount(params, payload);
    }
    /**
     * Get final order.take amount including take patches
     * @param params.order order to retrieve final take amount for
     * @param payload chain-specific payload
     */
    getFinalTakeAmount(params, payload) {
        return this.getClient(params.order.take.chainId).getFinalTakeAmount(params, payload);
    }
    /**
     * Get DLN fees from chain
     * @param chain chain to get DLN fees for
     * @param amount amount to calculate transfer fee amount
     */
    getFees(chain, amount) {
        return this.getClient(chain).getFees(chain, amount);
    }
    /**
     * Get execution fee info for requested action
     * @param params.action action to estimate
     * @param params.takeNativePrice price of take native token in intermediary token
     * @param params.giveNativePrice price of give native token in intermediary token
     * @param params.batchSize count of orders in batch. Will fail if action is "ClaimBatchUnlock" and batchSize is undefined
     * @param payload chain-specific payload
     */
    async getClaimExecutionFee(params, payload) {
        const { giveChain, takeChain } = params;
        const giveClient = this.getClient(giveChain);
        const takeClient = this.getClient(takeChain);
        const takeDecimals = takeClient.nativeCurrencyDecimals;
        const takeToken = await takeClient.getWrappedNativeTokenAddress(takeChain);
        return giveClient.getClaimExecutionFee({ ...params, takeDecimals, takeToken }, payload);
    }
    async getClaimBatchUnlockCostForSingleOrder(params, payload) {
        const { giveChain, takeChain } = params;
        const giveClient = this.getClient(giveChain);
        const takeClient = this.getClient(takeChain);
        const takeDecimals = takeClient.nativeCurrencyDecimals;
        const takeToken = await takeClient.getWrappedNativeTokenAddress(takeChain);
        return giveClient.getClaimBatchUnlockCostForSingleOrder({ ...params, takeDecimals, takeToken }, payload);
    }
    /**
     * Get cost of createOrder action in give chain
     * @param params arguments shared between all clients
     * @param payload chain-specific payload
     */
    async getCreateCost(params, payload) {
        return this.getClient(params.giveChain).getCreateCost(params, payload);
    }
    /**
     * Get cost of fulfill action in take chain
     * @param params arguments shared between all clients
     * @param payload chain-specific payload
     */
    async getFulfillCost(params, payload) {
        return this.getClient(params.takeChain).getFulfillCost(params, payload);
    }
    /**
     * get an estimated cost of fulfill + send_unlock + claim_unlock for a single order in the native
     * currency of the take chain. This method takes shared unlock batches into consideration, so order's cost would be â‰ˆNth
     * of {send,claim}UnlockCost (where N is the size of the batch).
     */
    async getTakerFlowCostForSingleOrder(params, payload) {
        const logger = (...args) => params.loggerInstance?.verbose("[getTakerFlowCostForSingleOrder]", ...args);
        if (params.batchUnlockCoverage < 0.1 || params.batchUnlockCoverage > 1)
            throw new ClientError(ClientErrorType.WrongBatchSize, "getTakerFlowCostForSingleOrder: batchUnlockCoverage should be in range [0.1, 1]");
        logger(`calculating the take cost of an order; assuming it must cover ${params.batchUnlockCoverage} of the base cost of a batch unlock`);
        const executionFeeForSingleOrder = await this.getClaimBatchUnlockCostForSingleOrder(params, payload);
        logger(`expected execution fee for single order: ${executionFeeForSingleOrder}`);
        const takeClient = this.getClient(params.takeChain);
        const [sendUnlockCost, fulfillCost] = await Promise.all([
            takeClient.getSendUnlockCostForSingleOrder({
                ...params,
                executionFeeForSingleOrder: executionFeeForSingleOrder,
            }, payload),
            takeClient.getFulfillCost({
                takeChain: params.takeChain,
                equivalentToken: params.equivalentToken,
                orderTakeToken: params.orderTakeToken || params.equivalentToken,
                loggerInstance: params.loggerInstance,
            }, payload),
        ]);
        logger(`Fulfill cost: ${fulfillCost.totalCost}, send unlock cost (incl. execution fee) for single order: ${sendUnlockCost}`);
        const total = fulfillCost.totalCost + sendUnlockCost;
        return total;
    }
    /**
     * Get on-chain order status in give chain
     * @param params arguments shared between all clients
     * @param payload chain-specific payload
     */
    getGiveOrderState(params, payload) {
        return this.getClient(params.giveChain).getGiveOrderState(params, payload);
    }
    /**
     * Get on-chain order status in take chain
     * @param params arguments shared between all clients
     * @param payload chain-specific payload
     */
    getTakeOrderState(params, payload) {
        return this.getClient(params.takeChain).getTakeOrderState(params, payload);
    }
    /**
     * Build transaction for order creation in `order.give.chainId` chain
     * @param params arguments shared between all clients
     * @param params.order order data without nonce
     * @param params.referralCode ref code
     * @param params.affiliateFee affiliate fee
     * @param payload chain-specific payload
     */
    createOrder(params, payload) {
        return this.getClient(params.order.give.chainId).createOrder(params, payload);
    }
    /**
     * Build transaction for order fulfillment
     * @param params.order order to fulfill
     * @param payload chain-specific payload
     */
    fulfillOrder(params, payload) {
        return this.getClient(params.order.take.chainId).fulfillOrder(params, payload);
    }
    /**
     * @internal
     * @param chain
     * @returns
     */
    getForwarderAddress(chain) {
        return this.getClient(chain).getForwarderAddress?.(chain);
    }
    /**
     * @internal
     * Build atomic transaction to perform swap using swapResult and fulfill order
     * @param params.order order to fulfill
     * @param params.taker fulfiller/taker address
     * @param params.swapResult information about swap: token in/out with amount, routes, chain-specific swap info
     * @param payload chain-specific payload
     */
    preswapAndFulfillOrder(params, payload) {
        return this.getClient(params.order.take.chainId).preswapAndFulfillOrder(params, payload);
    }
    /**
     * @internal
     * Build atomic transaction to perform swap using SwapResult and create order
     * @param params.order order to create. Order give offer should be in swap result tokenOut token
     * @param params.affiliateFee affiliate fee to take after swap/before order creation from swapped amount
     * @param params.swapResult information about swap: token in/out with amount, routes, chain-specific swap info
     * @param payload chain-specific payload
     */
    preswapAndCreateOrder(params, payload) {
        return this.getClient(params.order.give.chainId).preswapAndCreateOrder(params, payload);
    }
    /**
     * Build sendBatchUnlock transaction to send unlock message for multiple orders via deBridge protocol
     * @param params.orders list of orders to batch unlock. Give & take chains must be equal
     * @param params.beneficiary receiver of give part in give chain
     * @param params.executionFee execution fee amount in take chain native token
     * @param payload chain-specific payload
     */
    sendBatchUnlock(params, payload) {
        return this.getClient(params.orders[0].take.chainId).sendBatchUnlock(params, payload);
    }
    /**
     * Build sendCancel transaction to send cancel message for single order via deBridge protocol
     * @param params.order order to cancel
     * @param params.executionFee execution fee amount in take chain native token
     * @param params.cancelBeneficiary beneficiary of cancel in give chain
     * @param payload chain-specific payload
     */
    sendCancelOrder(params, payload) {
        return this.getClient(params.order.take.chainId).sendCancelOrder(params, payload);
    }
    /**
     * Build sendUnlock transaction to send unlock message for single order via deBridge protocol
     * @param params.order order to unlock
     * @param params.beneficiary receiver of give part in give chain
     * @param params.executionFee execution fee amount in take chain native token
     * @param payload chain-specific payload
     */
    sendUnlockOrder(params, payload) {
        return this.getClient(params.order.take.chainId).sendUnlockOrder(params, payload);
    }
    /**
     * Extract order from create order transaction in give chain
     * @param params.giveChain order creation chain
     * @param params.txHash order creation transaction
     * @param payload chain-specific payload
     */
    getOrderFromTransaction(params, payload) {
        return this.getClient(params.giveChain).getOrderFromTransaction(params, payload);
    }
}
//# sourceMappingURL=client.js.map
import { Buffer } from "buffer";
import { helpers } from "@debridge-finance/solana-utils";
import { PublicKey } from "@solana/web3.js";
import BigNumber from "bignumber.js";
import { ChainId, ZERO_EVM_ADDRESS, ZERO_SOLANA_ADDRESS } from "./common.types";
// TODO: move to @debridge-finance/solana-utils
export const ATASize = 165;
export const TransactionFee = 5000;
/**
 * Lambda for quick convertation of Address into string. At the moment supports only evm and solana.
 * It's better to call `clientImplementation.fromAddress(chain, token).toString()`
 * @returns stringified address
 */
export const tokenAddressToString = (chain, address) => {
    let result;
    switch (chain) {
        case ChainId.Solana:
            result = new PublicKey(address).toString();
            break;
        default:
            result = helpers.bufferToHex(Buffer.from(address));
    }
    return result;
};
/**
 * Lambda for quick convertation of Address into string. At the moment supports only evm and solana.
 * It's better to call `clientImplementation.parseAddress(chain, token)`
 * @returns parsed address
 */
export const tokenStringToBuffer = (chain, address) => {
    let result;
    switch (chain) {
        case ChainId.Solana:
            if (address.startsWith("0x")) {
                result = helpers.hexToBuffer(address);
            }
            else {
                result = new PublicKey(address).toBytes();
            }
            break;
        default:
            result = helpers.hexToBuffer(address);
    }
    return result;
};
/**
 * Helper for buffers comparison
 */
export const buffersAreEqual = (a, b) => Buffer.compare(Buffer.from(a), Buffer.from(b)) === 0;
/**
 * Lambda for to get native token for specific chain. Could be used when clientImplementation is unavailable.
 * Better way to retrieve native token address is to read `clientImplementation.nativeAddress` field
 */
export const getNativeToken = (chainId) => {
    if (chainId === ChainId.Solana) {
        return tokenStringToBuffer(chainId, ZERO_SOLANA_ADDRESS);
    }
    else {
        return tokenStringToBuffer(chainId, ZERO_EVM_ADDRESS);
    }
};
/**
 * @internal
 * @deprecated, use {@link calcBigIntAmountViaCrossRate}
 * Converts the amount of inToken to outToken using the given exchange rates
 */
export const calcAmountViaCrossRate = (inAmount, inTokenExchangeRate, inTokenDecimals, outTokenExchangeRate, outTokenDecimals, payload) => {
    const inAmountIntermediaryValue = inAmount
        .multipliedBy(inTokenExchangeRate)
        .div(new BigNumber(10).pow(inTokenDecimals));
    const outAmount = inAmountIntermediaryValue
        .multipliedBy(new BigNumber(10).pow(outTokenDecimals))
        .div(outTokenExchangeRate);
    return outAmount;
};
/**
 * @internal
 */
export function fixDecimals(amount, decimalsIn, decimalsOut) {
    if (decimalsIn === decimalsOut)
        return amount;
    const delta = decimalsIn - decimalsOut;
    if (delta > 0) {
        return amount / 10n ** BigInt(delta);
    }
    else {
        return amount * 10n ** BigInt(-delta);
    }
}
export function formatAmount(amount, decimals) {
    const amountString = amount.toString();
    const length = amountString.length;
    const decimalIndex = length - decimals;
    if (decimals <= 0) {
        return amountString;
    }
    else if (decimalIndex <= 0) {
        const leadingZeros = "0".repeat(Math.abs(decimalIndex));
        return `0.${leadingZeros}${amountString}`;
    }
    else {
        const integerPart = amountString.slice(0, decimalIndex);
        const decimalPart = amountString.slice(decimalIndex).padStart(decimals, "0");
        return `${integerPart}.${decimalPart}`;
    }
}
/**
 * @internal
 */
export const calcBigIntAmountViaCrossRate = (inAmount, inTokenExchangeRate, inTokenDecimals, outTokenExchangeRate, outTokenDecimals) => {
    const rateDecimalsFixer = 1e6;
    const exchangeRatio = BigInt(Math.ceil((inTokenExchangeRate * rateDecimalsFixer) / outTokenExchangeRate));
    const amount = (inAmount * exchangeRatio) / BigInt(rateDecimalsFixer);
    return fixDecimals(amount, inTokenDecimals, outTokenDecimals);
};
//# sourceMappingURL=utils.js.map
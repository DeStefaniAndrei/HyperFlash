var _UniversalPriceTokenService_defaultPriceTokenService;
import { __classPrivateFieldGet, __classPrivateFieldSet } from "tslib";
import { ChainId, ZERO_EVM_ADDRESS } from "../common.types";
import { tokenStringToBuffer } from "../utils";
import { CachePriceFeed } from "./cachePriceTokenService";
import { CoingeckoPriceFeed } from "./coingecko.price.feed";
import { MappedPriceFeed } from "./mappedPriceTokenService";
import { PriceTokenService } from "./price.token.service";
const defaultCoingeckoCacheTtl = 60 * 5; // 5m
/**
 * A price token service with predefined immutable configuration suitable for DLN API and dln-taker
 * It uses CoingeckoPriceFeed with 5m cache under the hood, and overrides some popular intermediary
 * tokens used inside buckets
 */
export class UniversalPriceTokenService extends PriceTokenService {
    constructor(opts = {}) {
        super();
        _UniversalPriceTokenService_defaultPriceTokenService.set(this, void 0);
        __classPrivateFieldSet(this, _UniversalPriceTokenService_defaultPriceTokenService, new MappedPriceFeed({
            [ChainId.Solana]: {
                // remap USDC@Solana price to USDC@Ethereum
                EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v: {
                    type: "redirect",
                    chainId: ChainId.Ethereum,
                    token: tokenStringToBuffer(ChainId.Ethereum, "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48"),
                },
            },
            [ChainId.Linea]: {
                // remap ETH@Linea price to ETH@Ethereum
                [ZERO_EVM_ADDRESS]: {
                    type: "redirect",
                    chainId: ChainId.Ethereum,
                    token: tokenStringToBuffer(ChainId.Ethereum, ZERO_EVM_ADDRESS),
                },
            },
        }, new CachePriceFeed(new CoingeckoPriceFeed(opts.coingeckoApiKey), opts.coingeckoCacheTTL || defaultCoingeckoCacheTtl)), "f");
    }
    async getPrice(chainId, token, context) {
        return __classPrivateFieldGet(this, _UniversalPriceTokenService_defaultPriceTokenService, "f").getPrice(chainId, token, context);
    }
    calculateRelativeAmount(tokenIn, tokenOut, intermediary) {
        if (!__classPrivateFieldGet(this, _UniversalPriceTokenService_defaultPriceTokenService, "f")) {
            throw new Error(`For using calculateRelativeAmount need to be setup`);
        }
        return __classPrivateFieldGet(this, _UniversalPriceTokenService_defaultPriceTokenService, "f").calculateRelativeAmount(tokenIn, tokenOut, intermediary);
    }
    getNominalPrice(token, nominal) {
        if (!__classPrivateFieldGet(this, _UniversalPriceTokenService_defaultPriceTokenService, "f")) {
            throw new Error(`For using getNominalPrice need to be setup`);
        }
        return __classPrivateFieldGet(this, _UniversalPriceTokenService_defaultPriceTokenService, "f")?.getNominalPrice(token, nominal);
    }
}
_UniversalPriceTokenService_defaultPriceTokenService = new WeakMap();
//# sourceMappingURL=universalPriceFeed.js.map
var _MappedPriceFeed_mapping, _MappedPriceFeed_defaultPriceTokenService;
import { __classPrivateFieldGet, __classPrivateFieldSet } from "tslib";
import { ChainEngine, ChainId, getEngineByChainId, ZERO_EVM_ADDRESS, ZERO_SOLANA_ADDRESS, } from "../common.types";
import { buffersAreEqual, tokenAddressToString, tokenStringToBuffer } from "../utils";
import { PriceTokenService } from "./price.token.service";
export class MappedPriceFeed extends PriceTokenService {
    constructor(mapping, defaultPriceTokenService) {
        super();
        _MappedPriceFeed_mapping.set(this, void 0);
        _MappedPriceFeed_defaultPriceTokenService.set(this, void 0);
        __classPrivateFieldSet(this, _MappedPriceFeed_defaultPriceTokenService, defaultPriceTokenService, "f");
        __classPrivateFieldSet(this, _MappedPriceFeed_mapping, mapping || {}, "f");
    }
    async getPrice(chainId, token, context) {
        if (!token)
            token = this.getNativeAddress(chainId);
        const remappedSource = this.findRemapping(chainId, token);
        if (remappedSource) {
            return this.remapSource(chainId, token, remappedSource, context);
        }
        else if (__classPrivateFieldGet(this, _MappedPriceFeed_defaultPriceTokenService, "f")) {
            return __classPrivateFieldGet(this, _MappedPriceFeed_defaultPriceTokenService, "f").getPrice(chainId, token, context);
        }
        else
            throw new Error(`Unable to find price of ${token ? tokenAddressToString(chainId, token) : "null"} on ${ChainId[chainId]}, and default price feed is not specified`);
    }
    calculateRelativeAmount(tokenIn, tokenOut, intermediary) {
        if (!__classPrivateFieldGet(this, _MappedPriceFeed_defaultPriceTokenService, "f")) {
            throw new Error(`For using calculateRelativeAmount need to be setup`);
        }
        return __classPrivateFieldGet(this, _MappedPriceFeed_defaultPriceTokenService, "f").calculateRelativeAmount(tokenIn, tokenOut, intermediary);
    }
    getNominalPrice(token, nominal) {
        if (!__classPrivateFieldGet(this, _MappedPriceFeed_defaultPriceTokenService, "f")) {
            throw new Error(`For using getNominalPrice need to be setup`);
        }
        return __classPrivateFieldGet(this, _MappedPriceFeed_defaultPriceTokenService, "f")?.getNominalPrice(token, nominal);
    }
    findRemapping(chainId, srcToken) {
        return Object.entries(__classPrivateFieldGet(this, _MappedPriceFeed_mapping, "f")[chainId] || {}).find(([token, priceSource]) => buffersAreEqual(tokenStringToBuffer(chainId, token), srcToken))?.[1];
    }
    remapSource(chainId, token, source, context) {
        switch (source.type) {
            case "redirect":
                return this.getPrice(source.chainId, source.token, context);
            case "fixed":
                return Promise.resolve(source.hardcodedPrice);
            case "compute":
                return source.func(chainId, token, context);
            default:
                throw new Error(`Unexpected remap type`);
        }
    }
    getNativeAddress(chain) {
        switch (getEngineByChainId(chain)) {
            case ChainEngine.Solana:
                return tokenStringToBuffer(chain, ZERO_SOLANA_ADDRESS);
            case ChainEngine.EVM:
                return tokenStringToBuffer(chain, ZERO_EVM_ADDRESS);
            default:
                throw new Error();
        }
    }
}
_MappedPriceFeed_mapping = new WeakMap(), _MappedPriceFeed_defaultPriceTokenService = new WeakMap();
//# sourceMappingURL=mappedPriceTokenService.js.map
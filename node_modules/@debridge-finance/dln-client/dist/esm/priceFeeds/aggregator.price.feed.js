var _AggregatorPriceTokenService_instances, _AggregatorPriceTokenService_config, _AggregatorPriceTokenService_decimalsGetter, _AggregatorPriceTokenService_swapConnectorGetter, _AggregatorPriceTokenService_fixToken, _AggregatorPriceTokenService_swapConnector_get;
import { __classPrivateFieldGet, __classPrivateFieldSet } from "tslib";
import { tokenStringToBuffer, buffersAreEqual, tokenAddressToString, } from "..";
import { ChainId } from "../common.types";
import { PriceTokenService } from "./price.token.service";
const defaultConfig = {
    [ChainId.Arbitrum]: ["0xff970a61a04b1ca14834a43f5de4533ebddb5cc8", 6],
    [ChainId.Avalanche]: ["0xB97EF9Ef8734C71904D8002F8b6Bc66Dd9c48a6E", 6],
    [ChainId.Bitrock]: ["0xD647a6E1F898c39bA594443c19De0872EA935310", 6],
    [ChainId.Base]: ["0xd9aaec86b65d86f6a7b5b1b0c42ffa531710b6ca", 6],
    [ChainId.BSC]: ["0x8ac76a51cc950d9822d68b83fe1ad97b32cd580d", 18],
    [ChainId.Ethereum]: ["0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48", 6],
    [ChainId.Gnosis]: ["0xDDAfbb505ad214D7b80b1f830fcCc89B60fb7A83", 6],
    [ChainId.Linea]: ["0x176211869cA2b568f2A7D4EE941E073a821EE1ff", 6],
    [ChainId.Optimism]: ["0x7f5c764cbc14f9669b88837ca1490cca17c31607", 6],
    [ChainId.Polygon]: ["0x2791bca1f2de4661ed88a30c99a7a9449aa84174", 6],
    [ChainId.Solana]: ["EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v", 6],
    [ChainId.Neon]: ["0xEA6B04272f9f62F997F666F07D3a974134f7FFb9", 6],
    [ChainId.Metis]: ["0xEA32A96608495e54156Ae48931A7c20f0dcc1a21", 6],
    [ChainId.LightLink]: ["0x18fB38404DADeE1727Be4b805c5b242B5413Fa40", 6],
};
const stablecoinBaseValue = 100n;
export class AggregatorPriceTokenService extends PriceTokenService {
    constructor(decimalsGetter, swapConnectorGetter, config) {
        super();
        _AggregatorPriceTokenService_instances.add(this);
        _AggregatorPriceTokenService_config.set(this, void 0);
        _AggregatorPriceTokenService_decimalsGetter.set(this, void 0);
        _AggregatorPriceTokenService_swapConnectorGetter.set(this, void 0);
        __classPrivateFieldSet(this, _AggregatorPriceTokenService_decimalsGetter, decimalsGetter, "f");
        __classPrivateFieldSet(this, _AggregatorPriceTokenService_swapConnectorGetter, swapConnectorGetter, "f");
        __classPrivateFieldSet(this, _AggregatorPriceTokenService_config, { ...defaultConfig, ...config }, "f");
    }
    async getPrice(chain, token, context) {
        const logger = (...params) => context.logger.verbose(`[${AggregatorPriceTokenService.name} chain: ${chain}]`, ...params);
        if (!__classPrivateFieldGet(this, _AggregatorPriceTokenService_config, "f")[chain])
            throw new Error(`${AggregatorPriceTokenService.name}: not configured for ${chain}`);
        const [fromTokenRaw, fromTokenDecimals] = __classPrivateFieldGet(this, _AggregatorPriceTokenService_config, "f")[chain];
        const fromToken = typeof fromTokenRaw === "string" ? tokenStringToBuffer(chain, fromTokenRaw) : fromTokenRaw;
        const toToken = __classPrivateFieldGet(this, _AggregatorPriceTokenService_instances, "m", _AggregatorPriceTokenService_fixToken).call(this, chain, token);
        if (buffersAreEqual(toToken, fromToken))
            return Promise.resolve(1);
        const fromAmountRaw = stablecoinBaseValue;
        const toTokenDecimals = await __classPrivateFieldGet(this, _AggregatorPriceTokenService_decimalsGetter, "f").call(this, chain, toToken);
        const outcome = await __classPrivateFieldGet(this, _AggregatorPriceTokenService_instances, "a", _AggregatorPriceTokenService_swapConnector_get).getEstimate({
            chainId: chain,
            slippageBps: 100,
            fromTokenAddress: fromToken,
            amountIn: BigInt(fromAmountRaw) * 10n ** BigInt(fromTokenDecimals),
            toTokenAddress: toToken,
        }, context);
        logger(`swapping ${fromAmountRaw} of a stable coin to ${tokenAddressToString(chain, toToken)} gives ${outcome.amountOut}`);
        const precision = 6;
        const rate = (fromAmountRaw * 10n ** BigInt(toTokenDecimals + precision)) / outcome.amountOut;
        const normalizedRate = Number(rate.toString()) / 10 ** precision;
        logger(`calculated rate: ${rate}, normalized: ${normalizedRate}`);
        return normalizedRate;
    }
    calculateRelativeAmount(tokenIn, tokenOut, intermediary) {
        throw new Error("Method not implemented.");
    }
    getNominalPrice(token, nominal) {
        throw new Error("Method not implemented.");
    }
}
_AggregatorPriceTokenService_config = new WeakMap(), _AggregatorPriceTokenService_decimalsGetter = new WeakMap(), _AggregatorPriceTokenService_swapConnectorGetter = new WeakMap(), _AggregatorPriceTokenService_instances = new WeakSet(), _AggregatorPriceTokenService_fixToken = function _AggregatorPriceTokenService_fixToken(chain, token) {
    if (!token) {
        if (chain === ChainId.Solana)
            return Buffer.alloc(32);
        return Buffer.alloc(20);
    }
    return token;
}, _AggregatorPriceTokenService_swapConnector_get = function _AggregatorPriceTokenService_swapConnector_get() {
    return typeof __classPrivateFieldGet(this, _AggregatorPriceTokenService_swapConnectorGetter, "f") === "function" ? __classPrivateFieldGet(this, _AggregatorPriceTokenService_swapConnectorGetter, "f").call(this) : __classPrivateFieldGet(this, _AggregatorPriceTokenService_swapConnectorGetter, "f");
};
//# sourceMappingURL=aggregator.price.feed.js.map
import { AnchorProvider, Program, BN } from "@coral-xyz/anchor";
import { MessageV0, PublicKey, SystemProgram, VersionedTransaction, } from "@solana/web3.js";
import * as wasm from "@debridge-finance/debridge-external-call";
import { TOKEN_PROGRAM_ID, WRAPPED_SOL_MINT, constants, findAssociatedTokenAddress, txs, } from "@debridge-finance/solana-utils";
import { spl } from "@debridge-finance/solana-utils";
import { extCallDataToInstructions } from "@debridge-finance/solana-contracts-client";
import { Logger } from "../common/logger";
import { IDL } from "./idl/executor";
const ACCOUNT_DISCRIMINATOR_SIZE = 8;
export const findExtcallStateAddress = (extcallProgram) => PublicKey.findProgramAddressSync([Buffer.from("STATE", "utf-8")], extcallProgram)[0];
export const findExtcallMetaAddress = (extcallProgram, id) => PublicKey.findProgramAddressSync([Buffer.from("META", "utf-8"), id], new PublicKey(extcallProgram))[0];
export const findExtcallStorageAddress = (extcallProgram, id, owner) => PublicKey.findProgramAddressSync([Buffer.from("STORAGE", "utf-8"), id, owner.toBuffer()], new PublicKey(extcallProgram))[0];
export const findExtcallAuthAddress = (extcallProgram, id) => PublicKey.findProgramAddressSync([Buffer.from("AUTH", "utf-8"), id], new PublicKey(extcallProgram))[0];
export const findExtcallWalletAddress = (extcallProgram, id, isNative) => isNative
    ? findExtcallAuthAddress(extcallProgram, id)
    : PublicKey.findProgramAddressSync([Buffer.from("WALLET", "utf-8"), id], extcallProgram)[0];
export var ExecutionState;
(function (ExecutionState) {
    ExecutionState["Executed"] = "Executed";
    ExecutionState["Execution"] = "Execution";
    ExecutionState["Failed"] = "Failed";
    ExecutionState["Fallbacked"] = "Fallbacked";
    ExecutionState["Initializing"] = "Initializing";
})(ExecutionState || (ExecutionState = {}));
const CHUNK_SIZE = 850;
const STORAGE_OFFSET = ACCOUNT_DISCRIMINATOR_SIZE + 9; // discriminator (8) + u64 (8) + bool (1)
function ixToIExtIx(ix) {
    return {
        keys: ix.keys.map((meta) => ({
            pubkey: meta.pubkey.toBase58(),
            isSigner: meta.isSigner,
            isWritable: meta.isWritable,
        })),
        programId: ix.programId.toBase58(),
        data: ix.data,
    };
}
function bufferChunks(data, chunkSize) {
    let offset = 0;
    const chunks = [];
    while (offset < data.length) {
        chunks.push([offset, data.subarray(offset, offset + chunkSize)]);
        offset += chunkSize;
    }
    return chunks;
}
export class Executor {
    constructor(programId, connection) {
        this.program = new Program(IDL, programId, new AnchorProvider(connection, {}, {}));
    }
    /**
     * @deprecated use `extCallDataToInstructions` from solana-contracts-client
     * @param calldata
     * @param offset
     * @returns
     */
    static deserializeCalldata(calldata, offset = 0) {
        return extCallDataToInstructions(calldata, offset);
    }
    isNative(tokenMint) {
        return tokenMint.toBase58() === Executor.nativeAddress;
    }
    /**
     *
     * @param takeTokenAddress
     * @param solPrice in usd
     * @param takeTokenPrice in usd
     * @param takeTokenDecimals
     * @param calldata
     * @param profitabilityMultiplier value in range 0..1, rewards will be equal (multiplier+1)*expensesInTakeToken
     * @returns
     */
    static setExecutionFeeRewards(takeTokenAddress, solPrice, takeTokenPrice, takeTokenDecimals, calldata, profitabilityMultiplier = 0.2) {
        const takeTokenStr = new PublicKey(takeTokenAddress).toBase58();
        if (takeTokenStr === Executor.nativeAddress || takeTokenStr === WRAPPED_SOL_MINT.toBase58()) {
            takeTokenPrice = 1;
            solPrice = 1;
        }
        const wasmInput = new wasm.CostCalculationInput(takeTokenAddress.length, false, 10, 3480n, 2, 5000n, solPrice, takeTokenPrice, takeTokenDecimals, true, true, profitabilityMultiplier, BigInt(calldata.length));
        const result = wasmInput.calculate_recomended_reward_for_external_call(calldata);
        wasmInput.free();
        return result;
    }
    async getStorageData(orderId, executor) {
        const storageAddress = findExtcallStorageAddress(this.program.programId, orderId, executor);
        const storageData = await this.program.provider.connection.getAccountInfo(storageAddress);
        if (storageData === null || storageData.lamports === 0) {
            return null;
        }
        return storageData.data;
    }
    initExtCallStorage(extcallId, calldata, owner, chunkSize = CHUNK_SIZE) {
        const builders = [];
        const extcallStorage = findExtcallStorageAddress(this.program.programId, extcallId, owner);
        for (const [offset, chunk] of bufferChunks(Buffer.from(calldata), chunkSize)) {
            const builder = this.program.methods.fillExtcallStorage(Array.from(extcallId), new BN(calldata.length), new BN(offset), chunk);
            builder.accountsStrict({ systemProgram: SystemProgram.programId, owner, extcallStorage });
            builders.push(builder);
        }
        return Promise.all(builders.map(async (b) => {
            const ix = await b.instruction();
            const result = {
                instructions: [ix],
                payer: owner,
            };
            return result;
        }));
    }
    /**
     * Transforms solana's TransactionInstruction into serialized format executable by debridge calldata executor
     * @param instruction
     * @param substitutions object that allows to substitute amount at offset/wallet at index
     * @param expense cost of ix execution, before execution this amount (of native SOL) will be transferred to submissionAuthority wallet and will be used to pay for actions in solana (usually rent)
     * @param reward this amount will be deducted from balance of submissionWallet, meant to cover expense
     * @param isInMandatoryBlock is this instruction should be executed in the same transaction as other sequental instructions with this flag?
     * @returns serialized calldata
     */
    static serializeExternalInstruction(instruction, substitutions, expense, reward, zeroRentAlreadyIncluded = false, isInMandatoryBlock = false) {
        const ZERO_ACCOUNT_RENT = 890880n;
        const ixWrapper = new wasm.ExternalInstructionWrapper(reward, expense !== undefined ? expense + (zeroRentAlreadyIncluded ? 0n : ZERO_ACCOUNT_RENT) : undefined, isInMandatoryBlock, substitutions?.amountSubstitutions ?? [], substitutions?.walletSubstitutions ?? [], ixToIExtIx(instruction));
        // IDK why, but that line emits 0 pointer passed to the wasm module
        // ixWrapper.free();
        return ixWrapper.serialize();
    }
    convertExtcallState(raw) {
        if (raw.state.executed) {
            return {
                state: ExecutionState.Executed,
                buffer: raw.state.executed.buffer,
            };
        }
        else if (raw.state.execution) {
            return {
                state: ExecutionState.Execution,
                executedInstructionsCount: raw.state.execution.executedInstructionsCount.toNumber(),
                offset: raw.state.execution.offset.toNumber(),
            };
        }
        else if (raw.state.failed) {
            return {
                state: ExecutionState.Failed,
                buffer: raw.state.failed.buffer,
            };
        }
        else if (raw.state.fallbacked) {
            return {
                state: ExecutionState.Fallbacked,
            };
        }
        else if (raw.state.initializing) {
            return {
                state: ExecutionState.Initializing,
            };
        }
        else {
            throw new Error("Unknown extcall meta state");
        }
    }
    normalizeExtcallMeta(data) {
        return {
            ...this.convertExtcallState(data),
            authority: data.providedAuthority,
            amount: BigInt(data.providedAmount.toString()),
            flow: data.providedToken.nativeSol ? "native" : "spl",
        };
    }
    async buildFallbackIx(extcallId, fallbackAuthority, tokenMint) {
        const builder = this.program.methods.makeFallback(Array.from(extcallId));
        const isNative = this.isNative(tokenMint);
        const fallbackWallet = isNative ? fallbackAuthority : findAssociatedTokenAddress(fallbackAuthority, tokenMint)[0];
        const instructions = [];
        if (!isNative) {
            instructions.push(spl.createAssociatedWalletInstruction(tokenMint, fallbackWallet, fallbackAuthority, fallbackAuthority));
        }
        builder.accountsStrict({
            systemProgram: SystemProgram.programId,
            splTokenProgram: TOKEN_PROGRAM_ID,
            extcallMeta: findExtcallMetaAddress(this.program.programId, extcallId),
            executeAuth: findExtcallAuthAddress(this.program.programId, extcallId),
            executeWallet: findExtcallWalletAddress(this.program.programId, extcallId, isNative),
            fallbackAuthority,
            fallbackWallet,
        });
        instructions.push(await builder.instruction());
        return { instructions, payer: fallbackAuthority };
    }
    async buildExecuteExternalCallIx(extcallId, calldata, offset, count, accounts) {
        const context = wasm.get_external_call_account_meta(calldata, offset, calldata.length, count, accounts.extcallMeta.toBase58(), accounts.executeAuth.toBase58(), accounts.executeWallet.toBase58());
        const subsitutionBumps = context.reversed_subsitution_bumps();
        const remainingAccounts = context.remaning_accounts().map((item) => {
            const pk = new PublicKey(item.pubkey);
            return {
                isSigner: item.is_signer,
                isWritable: item.is_writable,
                pubkey: pk,
            };
        });
        context.free();
        const builder = this.program.methods.executeExtcall(Array.from(extcallId), new BN(count), Buffer.from(subsitutionBumps));
        builder.accountsStrict({
            ...accounts,
            splTokenProgram: TOKEN_PROGRAM_ID,
            systemProgram: SystemProgram.programId,
        });
        builder.remainingAccounts(remainingAccounts);
        return builder.instruction();
    }
    async getExternalCallMeta(extcallId) {
        const address = findExtcallMetaAddress(this.program.programId, extcallId);
        const fetched = this.program.account.extcallMeta.fetchNullable(address);
        return fetched;
    }
    async buildOptimalExecuteExternalCallTransaction(extcallId, executor, tokenMint) {
        const logger = new Logger();
        const accounts = {
            extcallMeta: findExtcallMetaAddress(this.program.programId, extcallId),
            extcallStorage: findExtcallStorageAddress(this.program.programId, extcallId, executor),
            executeAuth: findExtcallAuthAddress(this.program.programId, extcallId),
            executeWallet: findExtcallWalletAddress(this.program.programId, extcallId, this.isNative(tokenMint)),
            executor,
        };
        const [rawStorage, rawMeta] = await this.program.provider.connection.getMultipleAccountsInfo([
            accounts.extcallStorage,
            accounts.extcallMeta,
        ]);
        if (rawMeta === null)
            throw new Error("Failed to get ext call meta");
        if (rawStorage === null)
            throw new Error("Failed to get ext call storage");
        const parsedMeta = this.normalizeExtcallMeta(this.program.coder.accounts.decode("extcallMeta", rawMeta.data));
        let rewardDst;
        if (parsedMeta.flow === "native") {
            rewardDst = executor;
            accounts.executeWallet = accounts.executeAuth;
        }
        else {
            rewardDst = findAssociatedTokenAddress(executor, tokenMint)[0];
        }
        let offset = STORAGE_OFFSET;
        if (parsedMeta.state in [ExecutionState.Executed, ExecutionState.Failed, ExecutionState.Fallbacked]) {
            throw new Error(`Can't execute submission with state: ${JSON.stringify(parsedMeta.state)}`);
        }
        else if (parsedMeta.state === ExecutionState.Execution) {
            offset = parsedMeta.offset;
        }
        const calldata = rawStorage.data;
        let execIx = null;
        let vtx = null;
        let optimalCountMin = 0;
        let optimalCountMax = extCallDataToInstructions(calldata, offset).length + 1;
        let middle = 0;
        let err = null;
        while (optimalCountMax - optimalCountMin > 1) {
            middle = Math.floor((optimalCountMin + optimalCountMax) / 2);
            logger.verbose(`Current min: ${optimalCountMin}, max: ${optimalCountMax}, middle: ${middle}`);
            try {
                execIx = await this.buildExecuteExternalCallIx(extcallId, calldata, offset, middle, { ...accounts, rewardDst });
                vtx = new VersionedTransaction(MessageV0.compile({
                    instructions: [execIx],
                    payerKey: executor,
                    recentBlockhash: constants.FAKE_BLOCKHASH,
                    addressLookupTableAccounts: [],
                }));
                if ((txs.getTransactionSize(vtx) ?? 1250) > 1232) {
                    err = "tx too big";
                }
                else {
                    //console.log(Buffer.from(vtx.serialize()).toString("base64"));
                    const simulation = await this.program.provider.connection.simulateTransaction(vtx, {
                        replaceRecentBlockhash: true,
                    });
                    logger.verbose(simulation.value.err);
                    err = simulation.value.err;
                }
                if (err === null) {
                    optimalCountMin = middle;
                }
                else {
                    optimalCountMax = middle;
                }
            }
            catch (e) {
                logger.verbose(e);
                optimalCountMax = middle;
            }
        }
        let optimal = Math.floor((optimalCountMax + optimalCountMin) / 2);
        optimal = optimal === 0 ? 1 : optimal;
        logger.verbose(`Optimal count: ${optimal}`);
        execIx = await this.buildExecuteExternalCallIx(extcallId, calldata, offset, optimal, { ...accounts, rewardDst });
        return [
            {
                instructions: [execIx],
                payer: executor,
            },
            optimal,
        ];
    }
}
Executor.nativeAddress = "11111111111111111111111111111111";
//# sourceMappingURL=executor.js.map
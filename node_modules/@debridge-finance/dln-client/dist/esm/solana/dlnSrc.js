import { Buffer } from "buffer";
import { PublicKey, SystemProgram } from "@solana/web3.js";
import { AnchorProvider, Program, BN } from "@coral-xyz/anchor";
import { dlnSrcResolver, findAssociatedTokenAddress, constants, helpers, TOKEN_PROGRAM_ID, ASSOCIATED_TOKEN_PROGRAM_ID, } from "@debridge-finance/solana-utils";
import { SolanaParser } from "@debridge-finance/solana-transaction-parser";
import { Order } from "../order";
import { ChainId } from "../common.types";
import { ClientError } from "../errors/client-error.error";
import { ClientErrorType } from "../errors/client-error-type.enum";
import { Env } from "../common/env";
import { IDL as ProdIDL } from "./idl/src";
import { IDL as HanoiIDL } from "./idl/hanoi_src";
import { bigintToArray, bigintToBN, orderDataToAnchorFormat, solanaOrderToOrderData, getMinimumBalanceForRentExemption, getAccountInfoCached, } from "./utils";
const BPS_DENOMINATOR = BigInt(constants.BPS_DENOMINATOR);
export class DLNSrc {
    constructor(programId, connection, logger, version = Env.Prod) {
        this.logger = logger;
        this.version = version;
        switch (version) {
            case Env.Lima:
            case Env.Madrid:
            case Env.Prod: {
                this.program = new Program(ProdIDL, programId, new AnchorProvider(connection, {}, {}));
                break;
            }
            case Env.Hanoi: {
                this.program = new Program(HanoiIDL, programId, new AnchorProvider(connection, {}, {}));
            }
        }
        this.accountsResolver = dlnSrcResolver(this.program.programId).methods;
        this.state = null;
    }
    setConnection(connection) {
        this.program = new Program(this.program.idl, this.program.programId, new AnchorProvider(connection, {}, {}));
    }
    async getOrderFromTransaction(txId) {
        const tx = await this.program.provider.connection.getTransaction(txId, {
            maxSupportedTransactionVersion: 0,
            commitment: "confirmed",
        });
        if (tx === null)
            throw new ClientError(ClientErrorType.MissingTransaction);
        if ((tx.meta?.err ?? null) !== null)
            throw new ClientError(ClientErrorType.FailedTransaction);
        let createdEventInfo = null;
        let orderId = null;
        for (const log of tx?.meta?.logMessages || []) {
            if (!log.startsWith("Program data: "))
                continue;
            const decoded = this.program.coder.events.decode(log.slice("Program data: ".length));
            if (decoded && decoded.name === "CreatedOrder")
                createdEventInfo = decoded.data;
            if (decoded && decoded.name === "CreatedOrderId")
                orderId = Buffer.from(decoded.data.orderId);
        }
        if (!orderId || !createdEventInfo)
            return null;
        const transferFee = BigInt(createdEventInfo.percentFee.toString());
        const fixFee = BigInt(createdEventInfo.fixFee.toString());
        const orderData = solanaOrderToOrderData(createdEventInfo.order);
        const parser = new SolanaParser([{ idl: this.program.idl, programId: this.program.programId }]);
        let extCallData = undefined;
        const parsedTx = parser.parseTransactionData(tx?.transaction.message, tx?.meta?.loadedAddresses);
        let affiliateInfo = undefined;
        let referralCode = undefined;
        for (const parsedIx of parsedTx) {
            let continueParsingInstructions = true;
            if (parsedIx.programId.equals(this.program.programId)) {
                switch (parsedIx.name) {
                    case "createOrderWithNonce":
                    case "createOrder": {
                        const createOrderIx = parsedIx;
                        extCallData = createOrderIx.args.orderArgs?.externalCall;
                        referralCode = createOrderIx.args.referralCode;
                        if (createOrderIx.args.affiliateFee === null) {
                            affiliateInfo = undefined;
                        }
                        else {
                            const affiliateFeeAmount = BigInt(createOrderIx.args.affiliateFee.amount.toString());
                            affiliateInfo = {
                                beneficiary: createOrderIx.args.affiliateFee.beneficiary.toBuffer(),
                                amount: affiliateFeeAmount,
                            };
                        }
                        continueParsingInstructions = false;
                        break;
                    }
                }
            }
            if (!continueParsingInstructions)
                break;
        }
        return {
            ...orderData,
            externalCall: extCallData
                ? {
                    externalCallData: extCallData,
                }
                : undefined,
            orderId: orderId,
            transferFee,
            fixFee,
            referralCode,
            createTimestamp: tx.blockTime ?? undefined,
            affiliateInfo,
        };
    }
    async getState() {
        if (this.state) {
            return this.state;
        }
        const [stateAccount] = this.accountsResolver.getStateAccount();
        const state = await this.program.account.state.fetchNullable(stateAccount);
        if (state === null) {
            throw new ClientError(ClientErrorType.SolanaNoSrcState);
        }
        this.state = state;
        return state;
    }
    async getFees(amount) {
        const state = await this.getState();
        const transferFeeBps = Number(state.percentFeeBps.toString());
        return {
            fixFee: BigInt(state.fixedFee.toString()),
            transferFee: amount ? (BigInt(transferFeeBps) * amount) / BPS_DENOMINATOR : BigInt(0),
            transferFeeBps,
        };
    }
    async getGiveOrderState(orderId, commitment = "finalized") {
        const [stateAcc] = this.accountsResolver.getGiveOrderStateAccount(typeof orderId === "string" ? helpers.hexToBuffer(orderId) : Buffer.from(orderId));
        const giveState = await this.program.account.giveOrderState.fetchNullable(stateAcc, commitment);
        if (!giveState)
            return null;
        if ("created" in giveState.status) {
            return {
                status: 1 /* OrderState.Created */,
                takeChainId: new BN(giveState.status.created.takeChainId).toNumber(),
                // fetched.status.created!.giveAmount can't be null
                giveAmount: BigInt(giveState.status.created.giveAmount.toString()),
            };
        }
        else if ("claimedCancel" in giveState.status) {
            return {
                status: 7 /* OrderState.ClaimedCancel */,
            };
        }
        else if ("claimedUnlock" in giveState.status) {
            return {
                status: 6 /* OrderState.ClaimedUnlock */,
            };
        }
        throw new ClientError(ClientErrorType.UnknownStatus, `Unkown give status: ${JSON.stringify(giveState.status)}`);
    }
    async getCreateCost(ataRent, maker) {
        let dlnNonceAccountRent = 0;
        // cost = locker wallet creation + give order state creation
        let giveOrderStateSize = 211;
        // TODO remove after contract 3.0 release on prod
        if (this.version === Env.Hanoi) {
            giveOrderStateSize = 176;
        }
        const nonceSize = 8 + 8;
        const [state, giveStateRent, nonceRent, dlnNonceAccount] = await Promise.all([
            this.getState(),
            getMinimumBalanceForRentExemption(this.program.provider.connection, giveOrderStateSize),
            getMinimumBalanceForRentExemption(this.program.provider.connection, nonceSize),
            getAccountInfoCached(this.program.provider.connection, this.accountsResolver.getNonceAccount(new PublicKey(maker))[0]),
        ]);
        // TODO remove after contract 3.0 release on prod
        if (dlnNonceAccount?.lamports !== 0 && this.version !== Env.Hanoi) {
            dlnNonceAccountRent = nonceRent;
        }
        return state.fixedFee.addn(giveStateRent).addn(ataRent).addn(dlnNonceAccountRent).toNumber();
    }
    /**
     *
     * @param order order data with order id
     * @param amount amount to add to order.give part
     * @returns transaction to modify give part of the order
     */
    async patchGive(order, amount) {
        if (order.give.chainId !== ChainId.Solana)
            throw new ClientError(ClientErrorType.WrongChain, `Can't patch orders created in ${order.give.chainId} using Solana client`);
        const builder = this.program.methods.patchOrderGive(Array.from(order.orderId), new BN(amount.toString()));
        const orderIdBuf = Buffer.from(order.orderId);
        const givePatchAuthority = new PublicKey(order.givePatchAuthority);
        builder.accountsStrict({
            giveOrderState: this.accountsResolver.getGiveOrderStateAccount(orderIdBuf)[0],
            giveOrderWallet: this.accountsResolver.getGiveOrderWalletAddress(orderIdBuf)[0],
            givePatchAuthority,
            givePatchAuthorityWallet: findAssociatedTokenAddress(givePatchAuthority, new PublicKey(order.give.tokenAddress))[0],
            state: this.accountsResolver.getStateAccount()[0],
            splTokenProgram: TOKEN_PROGRAM_ID,
        });
        return builder.transaction();
    }
    async createOrder(order, referralCode, affiliateFee, makerWallet, metadata) {
        let useExplicitNonce = false;
        if (Object.prototype.hasOwnProperty.call(order, "nonce") && order.nonce !== undefined) {
            useExplicitNonce = true;
        }
        const [[stateAccount], [nonceAccount]] = await Promise.all([
            this.accountsResolver.getStateAccount(),
            this.accountsResolver.getNonceAccount(Buffer.from(order.maker)),
        ]);
        const [state, nonceData] = await Promise.all([
            this.getState(),
            useExplicitNonce
                ? Promise.resolve({ nonce: new BN(order.nonce.toString()) })
                : this.program.account.nonceMaster.fetchNullable(nonceAccount),
        ]);
        if (state === null) {
            throw new ClientError(ClientErrorType.SolanaNoSrcState);
        }
        const giveAmountWithoutFee = order.give.amount -
            (BigInt(state.percentFeeBps.toString()) * order.give.amount) / BPS_DENOMINATOR -
            (affiliateFee?.amount || BigInt(0));
        const nonce = nonceData?.nonce;
        if (order.give.chainId != ChainId.Solana) {
            throw new ClientError(ClientErrorType.SolanaWrongSrcChainId);
        }
        const realOrder = {
            nonce: BigInt(nonce === undefined ? 0 : nonce.toString()),
            give: {
                amount: giveAmountWithoutFee,
                chainId: ChainId.Solana,
                tokenAddress: order.give.tokenAddress,
            },
            take: order.take,
            maker: order.maker,
            receiver: order.receiver,
            givePatchAuthority: order.givePatchAuthority,
            orderAuthorityDstAddress: order.orderAuthorityDstAddress,
            allowedCancelBeneficiary: order.allowedCancelBeneficiary ? order.allowedCancelBeneficiary : undefined,
            allowedTaker: order.allowedTaker,
            externalCall: order.externalCall,
        };
        const orderId = Buffer.from(Order.calculateId(realOrder).slice(2), "hex");
        const giveMint = new PublicKey(order.give.tokenAddress);
        const maker = new PublicKey(order.maker);
        makerWallet = makerWallet || findAssociatedTokenAddress(maker, giveMint)[0];
        const [[giveOrderState], [giveOrderWallet]] = await Promise.all([
            this.accountsResolver.getGiveOrderStateAccount(orderId),
            this.accountsResolver.getGiveOrderWalletAddress(orderId),
        ]);
        const anchorOrder = orderDataToAnchorFormat(realOrder);
        const createOrderArgs = {
            ...anchorOrder,
            giveOriginalAmount: bigintToBN(order.give.amount),
            givePatchAuthoritySrc: new PublicKey(anchorOrder.givePatchAuthoritySrc),
            allowedCancelBeneficiarySrc: anchorOrder.allowedCancelBeneficiarySrc
                ? new PublicKey(anchorOrder.allowedCancelBeneficiarySrc)
                : null,
            externalCall: order.externalCall?.externalCallData ? Buffer.from(order.externalCall.externalCallData) : null,
        };
        let builderFn;
        if (useExplicitNonce || metadata?.length !== 0) {
            builderFn = (createArgs, affiliateFee, referralCode) => this.program.methods.createOrderWithNonce(createArgs, affiliateFee, referralCode, nonce, Buffer.from(metadata ?? []));
        }
        else {
            builderFn = this.program.methods.createOrder;
        }
        const orderBuilder = builderFn(createOrderArgs, affiliateFee
            ? {
                beneficiary: new PublicKey(affiliateFee.beneficiary),
                amount: new BN(affiliateFee.amount.toString()),
            }
            : null, referralCode ?? null);
        orderBuilder.accountsStrict({
            maker,
            state: stateAccount,
            tokenMint: giveMint,
            giveOrderState: giveOrderState,
            authorizedNativeSender: this.accountsResolver.getAuthorizedNativeSenderAddress(Buffer.from(bigintToArray(order.take.chainId, "u256")))[0],
            makerWallet: makerWallet,
            feeLedgerWallet: this.accountsResolver.getFeeLedgerWalletAddress(giveMint)[0],
            giveOrderWallet: giveOrderWallet,
            nonceMaster: nonceAccount,
            systemProgram: SystemProgram.programId,
            splTokenProgram: TOKEN_PROGRAM_ID,
            associatedSplTokenProgram: ASSOCIATED_TOKEN_PROGRAM_ID,
        });
        return orderBuilder.instruction();
    }
    async withdrawAffiliateFee(orderId, beneficiary, beneficiaryWallet) {
        const orderIdBuffer = typeof orderId === "string" ? helpers.hexToBuffer(orderId) : Buffer.from(orderId);
        const builder = this.program.methods.withdrawAffiliateFee(Array.from(orderIdBuffer));
        builder.accountsStrict({
            affiliateFeeBeneficiary: beneficiary,
            affiliateFeeWallet: beneficiaryWallet,
            giveOrderState: this.accountsResolver.getGiveOrderStateAccount(orderIdBuffer)[0],
            giveOrderWallet: this.accountsResolver.getGiveOrderWalletAddress(orderIdBuffer)[0],
            splTokenProgram: TOKEN_PROGRAM_ID,
        });
        return builder.transaction();
    }
}
//# sourceMappingURL=dlnSrc.js.map
import { ASSOCIATED_TOKEN_PROGRAM_ID, crypto, findAssociatedTokenAddress, helpers, spl, TOKEN_PROGRAM_ID, WRAPPED_SOL_MINT, } from "@debridge-finance/solana-utils";
import { AddressLookupTableAccount, ComputeBudgetProgram, PublicKey, SystemProgram, } from "@solana/web3.js";
import { ChainEngine, ChainId, } from "../common.types";
import { Logger } from "../common/logger";
import { ClientErrorType } from "../errors/client-error-type.enum";
import { ClientError } from "../errors/client-error.error";
import { ATASize, buffersAreEqual, TransactionFee } from "../utils";
import { Env } from "../common/env";
import { DLNDst } from "./dlnDst";
import { DLNSrc } from "./dlnSrc";
import { findALT, getMinimumBalanceForRentExemption, getSolanaDecimals, getTokenInfo, prepareALT, prepareV0Transaction, verifyALT, } from "./utils";
export class DlnClient {
    constructor(connection, srcId, dstId, debridgeId, debridgeSettingsId, ALTs, logger = new Logger(), version = Env.Prod) {
        this.connection = connection;
        this.cache = new Map();
        this.nativeCurrencyDecimals = 9;
        this.addressLength = 32;
        this.source = new DLNSrc(srcId, connection, logger, version);
        this.destination = new DLNDst(dstId, debridgeId, debridgeSettingsId, connection, version);
        this.fulfillPreswapALT = ALTs?.fulfillPreswap || null;
        this.createPreswapALT = ALTs?.createPreswap || null;
        this.defaultLogger = new Logger();
    }
    async getBalance(chain, tokenAddress, wallet) {
        if (buffersAreEqual(tokenAddress, this.nativeAddress)) {
            const result = await spl.getNativeWalletBalance(this.getConnection(chain), new PublicKey(wallet));
            return BigInt(result.toString());
        }
        else {
            const result = await spl.getAssocSPLWalletBalance(this.getConnection(chain), new PublicKey(wallet), new PublicKey(tokenAddress));
            return BigInt(result.toString());
        }
    }
    get nativeAddress() {
        return Uint8Array.from(Array.from({ length: this.addressLength }).fill(0));
    }
    getConnection(chain) {
        return this.connection;
    }
    setConnection(chain, connection) {
        this.connection = connection;
        this.destination.setConnection(connection);
        this.source.setConnection(connection);
    }
    fromAddress(address) {
        return new PublicKey(Buffer.from(address));
    }
    fromAddressMaybe(address) {
        if (!address)
            return undefined;
        return this.fromAddress(address);
    }
    toAddress(nativeAddress) {
        return nativeAddress.toBuffer();
    }
    parseAddress(address) {
        return new PublicKey(address).toBuffer();
    }
    getWrappedNativeTokenAddress(chain) {
        return Promise.resolve(WRAPPED_SOL_MINT.toBuffer());
    }
    getEngine() {
        return ChainEngine.Solana;
    }
    getFees(chain, amount) {
        return this.source.getFees(amount);
    }
    async getClaimBatchUnlockCostForSingleOrder(params, payload) {
        // batchUnlockCoverage is not used bc the cost of unlock in Solana is linear
        const { total } = await this.destination.getClaimExecutionFees(params.takeToken.length, params.takeChain, Buffer.from(params.takeToken), params.giveNativePrice, params.takeNativePrice, params.takeDecimals, "unlock");
        return total;
    }
    getClaimExecutionFee(params, payload) {
        switch (params.action) {
            case "ClaimUnlock":
                return this.destination.getClaimExecutionFees(params.takeToken.length, params.takeChain, Buffer.from(params.takeToken), params.giveNativePrice, params.takeNativePrice, params.takeDecimals, "unlock");
            case "ClaimBatchUnlock":
                return this.destination.getClaimExecutionFees(params.takeToken.length, params.takeChain, Buffer.from(params.takeToken), params.giveNativePrice, params.takeNativePrice, params.takeDecimals, "batchUnlock", params.batchSize);
            case "ClaimCancel":
                return this.destination.getClaimExecutionFees(params.takeToken.length, params.takeChain, Buffer.from(params.takeToken), params.giveNativePrice, params.takeNativePrice, params.takeDecimals, "cancel");
            default:
                throw new ClientError(ClientErrorType.UnsupportedChain, "unknown action");
        }
    }
    async getFulfillCost(params, payload) {
        const totalCost = await this.destination.getFulfillCost({
            ...payload,
            isNative: Buffer.compare(this.nativeAddress, params.orderTakeToken) === 0,
        });
        return {
            chainId: ChainId.Solana,
            gasLimit: totalCost,
            gasPrice: 1n,
            totalCost,
        };
    }
    getSendCancelCost(params, payload) {
        return this.destination.getSendCost(params.giveChain, params.executionFee, "cancel", 1, payload.priorityFee);
    }
    getSendUnlockCost(params, payload) {
        return this.destination.getSendCost(params.giveChain, params.executionFee, params.batchSize === 1 ? "unlock" : "batchUnlock", params.batchSize, payload.priorityFee);
    }
    async getSendUnlockCostForSingleOrder(params, payload) {
        const logger = (...args) => params.loggerInstance?.verbose("[getSendUnlockCostForSingleOrder]", ...args);
        const { totalCost: totalUndistributedCost, fixFee } = await this.destination.getSendCost(params.giveChain, params.executionFeeForSingleOrder, "batchUnlock", 1, payload.priorityFee);
        // totalUndistributedCost contains a full fixFee, but it must be spread across a batch according to the coverage
        const precision = 10000n;
        const sharedFixFee = (fixFee * BigInt(Math.round(params.batchUnlockCoverage * Number(precision)))) / precision;
        logger("shared fee", sharedFixFee);
        if (!(0 <= params.discountPercents.batchUnlockFixFee && params.discountPercents.batchUnlockFixFee <= 100)) {
            throw new Error(`discountPercents.batchUnlockFixFee should be between 0 and 100`);
        }
        const sharedFixFeeWithDiscount = ((100n - params.discountPercents.batchUnlockFixFee) * sharedFixFee) / 100n;
        logger("shared fee with discount", sharedFixFeeWithDiscount);
        const totalCost = totalUndistributedCost - fixFee + sharedFixFeeWithDiscount;
        return totalCost;
    }
    getGiveOrderState(params, payload) {
        return this.source.getGiveOrderState(params.orderId, payload.confirmationsCount !== undefined ? this.confirmationsToCommitment(payload.confirmationsCount) : undefined);
    }
    getTakeOrderState(params, payload) {
        return this.destination.getTakeOrderState(params.orderId, payload.confirmationsCount !== undefined ? this.confirmationsToCommitment(payload.confirmationsCount) : undefined);
    }
    async patchOrderGive(params, payload) {
        const tx = await this.source.patchGive(params.order, params.amountToAdd);
        return prepareV0Transaction(this.connection, this.fromAddress(params.order.maker), tx.instructions);
    }
    async patchOrderTake(params, payload) {
        const patcher = this.fromAddress(payload.patcher);
        const tx = await this.destination.patchTake(patcher, params.order, params.amountToSub);
        return prepareV0Transaction(this.connection, patcher, tx.instructions, []);
    }
    async getFinalGiveAmount(params, payload) {
        const giveState = await this.source.getGiveOrderState(params.order.orderId);
        if (!giveState)
            throw new ClientError(ClientErrorType.GiveStateNotFound, `Can't find order state for orderId ${helpers.bufferToHex(params.order.orderId)}`);
        if (giveState.status != 1 /* OrderState.Created */)
            throw new ClientError(ClientErrorType.SolanaWrongOrderState, `Can't get give patches for order in state != Created. Current state: ${giveState.status}`);
        return giveState.giveAmount;
    }
    async getFinalTakeAmount(params, payload) {
        const patchedAmount = await this.destination.getPatchedTakeAmount(params.order.orderId);
        return patchedAmount === null ? params.order.take.amount : patchedAmount;
    }
    /**
     *
     * @param params
     * @param payload chain-specific params
     * @param payload.makerWallet optional maker wallet, if not set default ATA(maker, giveToken) will be used
     * @returns
     */
    async createOrder(params, payload) {
        const { order, referralCode, affiliateFee } = params;
        const createIx = await this.source.createOrder(order, referralCode, affiliateFee
            ? {
                amount: affiliateFee.amount,
                beneficiary: this.fromAddress(affiliateFee.beneficiary),
            }
            : undefined, this.fromAddressMaybe(payload.makerWallet), params.metadata);
        return prepareV0Transaction(this.connection, new PublicKey(order.maker), [createIx]);
    }
    /**
     * @internal
     */
    async preswapAndFulfillOrder(params, payload) {
        /*
        const logger = (...args: unknown[]) =>
          (params?.loggerInstance || this.defaultLogger).verbose(`[preswapAndFulfillOrder]`, ...args);
        */
        if (!this.fulfillPreswapALT)
            throw new ClientError(ClientErrorType.BadALT, `fulfillPreswapALT missing, forgot to call client.initForFulfill?`);
        if ("solana" !== params.swapResult.engine) {
            throw new ClientError(ClientErrorType.PropertyMissing, "Wrong swap response provided, missing 'solana' engine in swapResponse");
        }
        const { swapInstructions, ALTs: swapALTs } = params.swapResult;
        if (!swapInstructions || !swapInstructions.length)
            throw new ClientError(ClientErrorType.NoSwapRoutes);
        const taker = new PublicKey(params.taker);
        const [fulfillTx] = await Promise.all([
            this.destination.fulfillOrder(params.order, taker, this.fromAddressMaybe(payload.unlockAuthority), this.fromAddressMaybe(payload.takerWallet)),
        ]);
        const transactionV0 = await prepareV0Transaction(this.connection, taker, [...swapInstructions, ...fulfillTx.instructions], [...swapALTs, this.fulfillPreswapALT]);
        return transactionV0;
    }
    /**
     * @internal
     */
    async preswapAndCreateOrder(params, payload) {
        const { order, affiliateFee, referralCode } = params;
        if ("solana" !== params.swapResult.engine) {
            throw new ClientError(ClientErrorType.PropertyMissing, "Wrong swap response provided, missing 'solana' engine in swapResponse");
        }
        const { swapInstructions, ALTs: swapALTs } = params.swapResult;
        if (!swapInstructions || !swapInstructions.length)
            throw new ClientError(ClientErrorType.NoSwapRoutes);
        if (!this.createPreswapALT)
            throw new ClientError(ClientErrorType.BadALT, "create preswap alt is uninitialized");
        const maker = new PublicKey(order.maker);
        const createIx = await this.source.createOrder(order, referralCode, affiliateFee
            ? {
                amount: affiliateFee.amount,
                beneficiary: this.fromAddress(affiliateFee.beneficiary),
            }
            : undefined, this.fromAddressMaybe(payload.makerWallet), params.metadata);
        const prefix = [];
        if (payload.computeUnitsLimit) {
            prefix.push(ComputeBudgetProgram.setComputeUnitLimit({ units: payload.computeUnitsLimit }));
            const price = Math.ceil((1e6 * params.swapResult.prioritizationFeeLamports) / payload.computeUnitsLimit);
            prefix.push(ComputeBudgetProgram.setComputeUnitPrice({ microLamports: BigInt(price) }));
        }
        const transactionV0 = await prepareV0Transaction(this.connection, maker, [...prefix, ...swapInstructions, createIx], [...swapALTs, this.createPreswapALT]);
        return transactionV0;
    }
    /**
     *
     * @param params
     * @param payload chain-specific payload
     * @param payload.taker address of fulfiller
     * @param payload.unlockAuthority optional address of allowed unlock authority
     * @returns
     */
    async fulfillOrder(params, payload) {
        const takerPk = this.fromAddress(payload.taker);
        const tx = await this.destination.fulfillOrder(params.order, takerPk, this.fromAddressMaybe(payload.unlockAuthority), payload.unlockAuthority
            ? payload.unlockAuthority === payload.taker
                ? undefined
                : this.fromAddressMaybe(payload.takerWallet)
            : undefined);
        return prepareV0Transaction(this.connection, takerPk, tx.instructions);
    }
    async sendCancelOrder(params, payload) {
        const { order: orderWithId, executionFee, cancelBeneficiary } = params;
        const cancelerPk = this.fromAddress(payload.canceler);
        const cancelIx = await this.destination.cancelOrder(cancelerPk, orderWithId);
        const accountedExecutionFee = await this.destination.getAmountWithAccountedGateTransferFee(orderWithId.give.chainId, executionFee);
        const sendTxContext = await this.destination.sendOrderCancel(cancelerPk, Buffer.from(orderWithId.orderId), orderWithId.give.chainId, cancelBeneficiary, accountedExecutionFee, this.fromAddressMaybe(payload.cancelerWallet));
        return prepareV0Transaction(this.connection, cancelerPk, [cancelIx, ...sendTxContext.instructions], sendTxContext.ALTs);
    }
    async sendUnlockOrder(params, payload) {
        const { order, beneficiary, executionFee } = params;
        return this.destination.sendUnlock(this.fromAddress(payload.unlocker), Buffer.from(order.orderId), order.give.chainId, Buffer.from(beneficiary), executionFee, this.fromAddressMaybe(payload?.unlockerWallet));
    }
    async sendBatchUnlock(params, payload) {
        const { executionFee, beneficiary, orders } = params;
        const takeChain = orders[0].take.chainId;
        const { chainId: giveChain } = orders[0].give;
        if (orders.find((o) => o.take.chainId !== takeChain || o.give.chainId !== giveChain) !== undefined)
            throw new ClientError(ClientErrorType.WrongBatchOrders, `Orders with same giveChain, takeChain and giveToken are required for batch unlock`);
        return this.destination.sendBatchUnlock(this.fromAddress(payload.unlocker), orders.map((o) => o.orderId), giveChain, Buffer.from(beneficiary), executionFee, this.fromAddressMaybe(payload.unlockerWallet));
    }
    async getOrderFromTransaction(params, payload) {
        return this.source.getOrderFromTransaction(params.txHash);
    }
    async getCreateCost(params, payload) {
        const ATARent = await this.getATARent();
        const orderCreationCost = await this.source.getCreateCost(ATARent, payload.maker);
        const costs = orderCreationCost + TransactionFee;
        let totalCost = BigInt(costs);
        if (payload.priorityFee) {
            totalCost += payload.priorityFee;
        }
        return {
            chainId: ChainId.Solana,
            gasLimit: totalCost,
            gasPrice: 1n,
            totalCost,
        };
    }
    async getATARent() {
        if (this.cache.has(`ATA_RENT`)) {
            return this.cache.get(`ATA_RENT`);
        }
        const rent = await getMinimumBalanceForRentExemption(this.connection, ATASize);
        this.cache.set(`ATA_RENT`, rent);
        return rent;
    }
    async prepareCreatePreswapALT(stableMint, supportedChains) {
        const authorizedSenders = await Promise.all(supportedChains.map((chain) => this.source.accountsResolver.getAuthorizedNativeSenderAddress(crypto.normalizeChainId(chain))));
        const ALTAddresses = [
            stableMint,
            WRAPPED_SOL_MINT,
            this.source.accountsResolver.getStateAccount()[0],
            // (await solanaClient.source.accountsResolver.getFeeLedgerAddress())[0],
            this.source.accountsResolver.getFeeLedgerWalletAddress(stableMint)[0],
            SystemProgram.programId,
            TOKEN_PROGRAM_ID,
            ASSOCIATED_TOKEN_PROGRAM_ID,
            ...authorizedSenders.map((v) => v[0]),
        ];
        return ALTAddresses;
    }
    /**
     * @internal
     */
    async initForCreatePreswap(owner, supportedChains = [
        ChainId.Polygon,
        ChainId.BSC,
        ChainId.Ethereum,
        ChainId.Arbitrum,
        ChainId.Avalanche,
        ChainId.Base,
        ChainId.Fantom,
        ChainId.Heco,
        ChainId.Linea,
        ChainId.Optimism,
        ChainId.Neon,
        ChainId.Gnosis,
        ChainId.LightLink,
        ChainId.Metis,
    ]) {
        const usdc = new PublicKey("EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v");
        const ALTAddresses = await this.prepareCreatePreswapALT(usdc, supportedChains);
        if (this.createPreswapALT) {
            const fetched = await this.connection.getAddressLookupTable(this.createPreswapALT);
            if (verifyALT(fetched.value, ALTAddresses)) {
                return;
            }
            else {
                throw new ClientError(ClientErrorType.BadALT, `ALT @ ${this.createPreswapALT.toBase58()} is not valid for create preswap`);
            }
        }
        const foundALT = await this.findALT(ALTAddresses);
        if (!foundALT) {
            const [lookupTableAddress, txs] = await this.createCorrectALT(owner, ALTAddresses);
            this.createPreswapALT = lookupTableAddress;
            return txs;
        }
        else {
            this.createPreswapALT = foundALT;
        }
        return;
    }
    /**
     * @internal
     */
    async initForTaker(payer, taker, supportedChains, ALT) {
        const usdc = new PublicKey("EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v");
        // remove solana if passed
        // supportedChains = supportedChains.filter((c) => c != ChainId.Solana);
        const [sendAccounts, fulfillAccounts, additional] = await Promise.all([
            this.destination.getDLNSendALTAccounts(supportedChains),
            this.destination.getDLNFulfillALTAccounts(supportedChains),
            [
                taker,
                usdc,
                findAssociatedTokenAddress(taker, usdc)[0],
                WRAPPED_SOL_MINT,
                findAssociatedTokenAddress(taker, WRAPPED_SOL_MINT)[0],
            ],
        ]);
        const maybeDuplicatedList = [...sendAccounts, ...fulfillAccounts, ...additional].map((acc) => acc.toBase58()); // convert to bs58 for normal Set work
        const ALTAddresses = Array.from(new Set(maybeDuplicatedList)).map((acc) => new PublicKey(acc));
        if (ALT) {
            const fetchedAlt = await this.connection.getAddressLookupTable(ALT);
            if (verifyALT(fetchedAlt.value, ALTAddresses)) {
                this.fulfillPreswapALT = ALT;
                return;
            }
            else {
                throw new ClientError(ClientErrorType.BadALT, `ALT @ ${ALT.toBase58()} is not valid for fulfill preswap`);
            }
        }
        const foundALT = await this.findALT(ALTAddresses);
        if (!foundALT) {
            const [lookupTableAddress, txs] = await this.createCorrectALT(payer, ALTAddresses);
            this.fulfillPreswapALT = lookupTableAddress;
            return txs;
        }
        else {
            this.fulfillPreswapALT = foundALT;
        }
    }
    async getDecimals(chain, tokenAddress) {
        const stringifiedAddress = this.fromAddress(tokenAddress).toBase58();
        const cacheKey = `decimals_${stringifiedAddress}`;
        const cacheHit = this.cache.get(cacheKey);
        if (cacheHit) {
            return cacheHit;
        }
        else {
            const decimals = await getSolanaDecimals(this.connection, stringifiedAddress);
            this.cache.set(cacheKey, decimals);
            return decimals;
        }
    }
    async getTokenInfo(chain, tokenAddress) {
        const pubkey = this.fromAddress(tokenAddress);
        const cacheKey = `tokenInfo_${pubkey.toString()}`;
        const cacheHit = this.cache.get(cacheKey);
        if (cacheHit) {
            return cacheHit;
        }
        else {
            const [decimals, nameAndSymbol] = await Promise.all([
                this.getDecimals(chain, tokenAddress),
                getTokenInfo(this.getConnection(chain), pubkey),
            ]);
            const result = {
                ...nameAndSymbol,
                chainId: chain,
                address: pubkey.toBase58(),
                decimals,
            };
            this.cache.set(cacheKey, result);
            return result;
        }
    }
    /**
     * @internal
     */
    async findALT(expectedAccounts) {
        const pattern = Buffer.concat([...expectedAccounts.slice(0, 3).map((k) => k.toBuffer())]);
        // console.log(pattern.toString("hex"));
        const possibleALTs = await findALT(this.connection, pattern);
        for (const possibleALTData of possibleALTs) {
            // console.log(possibleALT);
            if (!possibleALTData || !possibleALTData.account.data)
                continue;
            const possibleALT = new AddressLookupTableAccount({
                key: possibleALTData.pubkey,
                state: AddressLookupTableAccount.deserialize(possibleALTData.account.data),
            });
            if (!verifyALT(possibleALT, expectedAccounts))
                continue;
            return possibleALTData.pubkey;
        }
        return null;
    }
    /**
     * @internal
     */
    async createCorrectALT(payerAndOwner, expectedAccounts) {
        const slot = await this.connection.getSlot({ commitment: "processed" });
        return prepareALT(slot, payerAndOwner, expectedAccounts);
    }
    confirmationsToCommitment(confirmations) {
        if (confirmations < 0)
            throw new ClientError(ClientErrorType.UnsupportedFinalization, "finalization should be in range [0, 32]");
        else if (confirmations == 0) {
            return "processed";
        }
        else if (confirmations <= 21) {
            return "confirmed";
        }
        else if (confirmations <= 32) {
            return "finalized";
        }
        else {
            throw new ClientError(ClientErrorType.UnsupportedFinalization, "finalization should be in range [0, 32]");
        }
    }
}
export { Executor } from "./executor";
export { solanaOrderToOrderData } from "./utils";
//# sourceMappingURL=index.js.map
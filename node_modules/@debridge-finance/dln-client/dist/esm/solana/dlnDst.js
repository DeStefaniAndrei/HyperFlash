import { Buffer } from "buffer";
import { AnchorProvider, BN, BorshAccountsCoder, Program } from "@coral-xyz/anchor";
import { PublicKey, SystemProgram, SYSVAR_INSTRUCTIONS_PUBKEY, Transaction, TransactionInstruction, AddressLookupTableAccount, } from "@solana/web3.js";
import { DeBridgeSolanaClient } from "@debridge-finance/solana-contracts-client";
import { ASSOCIATED_TOKEN_PROGRAM_ID, dlnDstResolver, TOKEN_PROGRAM_ID, findAssociatedTokenAddress, helpers, constants, crypto, } from "@debridge-finance/solana-utils";
import { ChainId } from "../common.types";
import { ClientError } from "../errors/client-error.error";
import { ClientErrorType } from "../errors/client-error-type.enum";
import { Env } from "../common/env";
import { IDL } from "./idl/dst";
import { IDL as LimaIDL } from "./idl/lima_dst";
import { IDL as HanoiIDL } from "./idl/hanoi_dst";
import { bigintToArray, bigintToBN, orderDataToAnchorFormat, getMinimumBalanceForRentExemption, getAccountInfoCached, } from "./utils";
import { findExtcallStateAddress, findExtcallMetaAddress, findExtcallWalletAddress } from "./executor";
const WRAPPED_SOL_MINT = new PublicKey("So11111111111111111111111111111111111111112");
export class DLNDst {
    constructor(programId, debridgeId, debridgeSettingsId, connection, version = Env.Prod) {
        this.version = version;
        switch (version) {
            case Env.Prod:
            case Env.Madrid: {
                this.program = new Program(IDL, programId, new AnchorProvider(connection, {}, {}));
                break;
            }
            case Env.Lima: {
                this.program = new Program(LimaIDL, programId, new AnchorProvider(connection, {}, {}));
                break;
            }
            case Env.Hanoi: {
                this.program = new Program(HanoiIDL, programId, new AnchorProvider(connection, {}, {}));
                break;
            }
        }
        this.accountsResolver = dlnDstResolver(this.program.programId).methods;
        this.debridge = new DeBridgeSolanaClient(connection, undefined, {
            programId: debridgeId,
            settingsProgramId: debridgeSettingsId,
        });
        this.cachedSendALT = null;
    }
    setConnection(connection) {
        this.program = new Program(this.program.idl, this.program.programId, new AnchorProvider(connection, {}, {}));
    }
    getExecutorAddress(atomic = false) {
        if (atomic)
            throw new Error("Atomic executor for solana is missing");
        return new PublicKey(this.version === Env.Hanoi
            ? "exh7oPJuyQnAyMLeTmWbEwPU1rfLJAukQUBSvfX4LSP"
            : "exe59FS5cojZkPJVDFDV8RnXCC7wd6yoBjsUtqH7Zai");
    }
    getDLNFulfillALTAccounts(chains) {
        /**
              name: "takeOrderState", - depends on oid
              name: "taker",
              name: "takerWallet",
              name: "receiverDst" - in case of ext call could be stored in ALT,
              name: "authorizedSrcContract" - storable
              name: "takeOrderPatch",
              name: "splTokenProgram" - storable
              name: "systemProgram" - storable
    
              + remaining
              extcall state - storable
              extcall meta - depends on oid
              extcall wallet
              token mint
         */
        const authorizedSenders = chains.map((chain) => this.accountsResolver.getAuthorizedSrcContractAddress(Buffer.from(bigintToArray(chain, "u256")))[0]);
        const extcallProgram = this.getExecutorAddress();
        const accounts = [
            extcallProgram,
            ...authorizedSenders,
            TOKEN_PROGRAM_ID,
            SystemProgram.programId,
            findExtcallStateAddress(extcallProgram),
        ];
        return accounts;
    }
    async getDLNSendALTAccounts(chains) {
        const tokenMint = WRAPPED_SOL_MINT;
        const [sendFrom] = this.accountsResolver.getAuthorizedDstNativeSenderAddress();
        const [[sendFromWallet], ...authorizedContracts] = await Promise.all([
            findAssociatedTokenAddress(sendFrom, tokenMint),
            ...chains.map((chain) => this.accountsResolver.getAuthorizedSrcContractAddress(Buffer.from(bigintToArray(chain, "u256")))),
        ]);
        const debridgeSendAccounts = await this.getALTAccountsForDebridgeSend(tokenMint, chains);
        return [
            ...debridgeSendAccounts,
            sendFromWallet,
            sendFrom,
            SYSVAR_INSTRUCTIONS_PUBKEY,
            SystemProgram.programId,
            TOKEN_PROGRAM_ID,
            ...authorizedContracts.map(([pk]) => pk),
        ];
    }
    async getALTAccountsForDebridgeSend(tokenMint, chains) {
        /*
          bridgeCtx: {
            bridge: context.bridge, +
            tokenMint: context.tokenMint, +
            mintAuthority: context.mintAuthority, +
            stakingWallet: context.stakingWallet, +
            chainSupportInfo: context.chainSupportInfo, +
            splTokenProgram: TOKEN_PROGRAM_ID, +
            settingsProgram: CONFIG.SETTINGS_PROGRAM_ID, +
          },
          stateCtx: {
            state: context.state, +
            feeBeneficiary: context.feeBeneficiary, +
          },
          nonceStorage: context.nonceStorage, +
          sendFromWallet: context.sendFromWallet,
          sendFrom: context.sendFrom,
          bridgeFee: context.bridgeFee, +
          discount: context.discount,
          systemProgram: SystemProgram.programId, +
          externalCallStorage: context.externalCallStorage,
          externalCallMeta: context.externalCallMeta,
        */
        await this.debridge.init();
        const [bridge] = this.debridge.accountsResolver.getBridgeAddress(tokenMint);
        const [mintAuthority] = this.debridge.accountsResolver.getMintAuthorityAddress(bridge);
        const [[noDiscount], [noBridgeFee], [nonce], [stakingWallet], ...rest] = await Promise.all([
            this.debridge.accountsResolver.getNoDiscountAddress(),
            this.debridge.accountsResolver.getNoBridgeFeeAddress(),
            this.debridge.accountsResolver.getNonceAddress(),
            findAssociatedTokenAddress(mintAuthority, tokenMint),
            ...chains.map((chain) => this.debridge.accountsResolver.getChainSupportInfoAddress(chain)),
            ...chains.map((chain) => this.debridge.accountsResolver.getBridgeFeeAddress(bridge, chain)),
        ]);
        const state = this.debridge.statePublicKey;
        const feeBeneficiary = this.debridge.feeBeneficiary;
        const ALTAccounts = [
            tokenMint,
            bridge,
            mintAuthority,
            TOKEN_PROGRAM_ID,
            SystemProgram.programId,
            this.debridge.settingsProgram.programId,
            this.debridge.program.programId,
            state,
            feeBeneficiary,
            nonce,
            stakingWallet,
            noDiscount,
            noBridgeFee,
            ...rest.map(([pk]) => pk),
        ];
        return ALTAccounts;
    }
    async getSendALT() {
        let ALT;
        switch (this.version) {
            case Env.Lima: {
                ALT = new PublicKey("6EjPRqQ8ZYSq8qRzqDHeo1f38Ee5yPJYmqtSEKmpRZLw");
                break;
            }
            case Env.Prod: {
                ALT = new PublicKey("Z9SwCHdnxCpAEHdTewMXqZedbQBuBpQr16G9yedAU9q");
                break;
            }
            case Env.Madrid: {
                ALT = new PublicKey("6EjPRqQ8ZYSq8qRzqDHeo1f38Ee5yPJYmqtSEKmpRZLw");
                break;
            }
            case Env.Hanoi: {
                ALT = new PublicKey("9sWk4uvqk8B6EkPn8y1nR8hzZzzwwx3m52Sfk8m3ChHD");
                break;
            }
        }
        if (this.cachedSendALT === null) {
            const tmp = await helpers.getAccountInfo(this.program.provider.connection, ALT);
            if (!tmp)
                throw new ClientError(ClientErrorType.BadALT, `Failed to get ALT at address ${ALT.toBase58()}`);
            const state = AddressLookupTableAccount.deserialize(tmp.data);
            this.cachedSendALT = new AddressLookupTableAccount({ key: ALT, state });
        }
        return this.cachedSendALT;
    }
    async buildSendingContext(targetChainId, beneficiary, extCallData) {
        if (!this.debridge.isInitialized())
            await this.debridge.init();
        const [authorizedAddress] = this.accountsResolver.getAuthorizedSrcContractAddress(targetChainId);
        const authorizedRaw = await getAccountInfoCached(this.program.provider.connection, authorizedAddress);
        if (authorizedRaw === null)
            throw new ClientError(ClientErrorType.AuthroizedNativeSenderAccountMissing);
        const recieverSrcContract = this.program.coder.accounts.decode("authorizedSrcContract", authorizedRaw.data).srcContract;
        const ix = await this.debridge.buildSendContext(this.accountsResolver.getAuthorizedDstNativeSenderAddress()[0], null, WRAPPED_SOL_MINT, "0x" + Buffer.from(recieverSrcContract).toString("hex"), targetChainId, false, "0x" + beneficiary.toString("hex"), 0, extCallData);
        return { ...ix.asFlat, debridgeProgram: this.debridge.program.programId };
    }
    async getFulfillCost(params) {
        const signFee = 5000;
        // TakeOrderState size = discriminator(8) + bump (u8 1) + source_chain_id (chainId) + order_state (OrderTakeStatus)
        // chainId = u256 = 4 * u64 = 32 bytes
        // OrderTakeStatus max size = enum marker (1) + OrderTakeStatus::Canceled
        // OrderTakeStatus::Canceled = pubkey(32) + option<address> (1 + vec<u8> = 1 + u64 + sourceSize)
        // TODO fix after release in contract 3.0
        let takeOrderStateSize = 115; // + 8 + order.give.tokenAddress.length;
        let externalCallRent = 0;
        if (this.version === Env.Hanoi) {
            takeOrderStateSize = 106;
        }
        if (params.isOrderWithCalldata) {
            const externalCallMetaSize = 200;
            externalCallRent += await getMinimumBalanceForRentExemption(this.program.provider.connection, externalCallMetaSize);
            if (!params.isNative) {
                const externalCallWalletSize = 165;
                externalCallRent += await getMinimumBalanceForRentExemption(this.program.provider.connection, externalCallWalletSize);
            }
            if (this.version === Env.Hanoi) {
                externalCallRent += 890892;
            }
        }
        if (params.priorityFee) {
            externalCallRent += Number(params.priorityFee);
        }
        const stateCreate = await getMinimumBalanceForRentExemption(this.program.provider.connection, takeOrderStateSize);
        return BigInt(stateCreate + signFee + externalCallRent);
    }
    async getAmountWithAccountedGateTransferFee(sendToChainId, neededAmount) {
        const [chainAddr] = this.debridge.accountsResolver.getChainSupportInfoAddress(sendToChainId);
        const chainSupportInfo = await this.debridge.getChainSupportInfoSafe(chainAddr);
        const fees = await this.debridge.getFeesOrGlobal(chainSupportInfo);
        const BD = BigInt(constants.BPS_DENOMINATOR);
        const amount = (neededAmount * BD) / (BD - BigInt(fees.transferFeeBps.toString()));
        return amount;
    }
    async getSendCost(giveChainId, targetExecutionFeeInLamports, mode, batchSize, priorityFee) {
        if (!this.debridge.isInitialized())
            await this.debridge.init();
        const signFee = BigInt(5000);
        const [debridgeNonceMaster] = this.debridge.accountsResolver.getNonceAddress();
        const emptyBuffer = Buffer.alloc(32);
        let externalCallLength;
        let takeOrderStateSize = 115;
        // TODO remove after contract 3.0 release on prod
        if (this.version === Env.Hanoi) {
            takeOrderStateSize = 106;
        }
        let takeOrderState = 0;
        switch (mode) {
            case "cancel": {
                externalCallLength = this.buildCancelCalldata(emptyBuffer, emptyBuffer).length;
                takeOrderState = await getMinimumBalanceForRentExemption(this.program.provider.connection, takeOrderStateSize);
                break;
            }
            case "unlock": {
                externalCallLength = this.buildUnlockCalldata(emptyBuffer, emptyBuffer).length;
                break;
            }
            case "batchUnlock": {
                if (batchSize === undefined)
                    throw new ClientError(ClientErrorType.WrongBatchSize, "batch size required for batch unlock cost calculation");
                externalCallLength = this.buildBatchUnlockCalldata(Array.from({ length: batchSize }).fill(emptyBuffer), emptyBuffer).length;
                break;
            }
        }
        const extCallSize = 8 + externalCallLength;
        // discriminator + ExternalCallMetaVariants::Execution ( offset(u64) + len (u64) + auth_bump(1)) + storage_bump(1) + bump (1)
        let metaSize = 40; // 8 + 8 + 8 + 1 + 1 + 1 = 27;
        // TODO remove after contract 3.0 release on prod
        if (this.version === Env.Hanoi && mode !== "batchUnlock") {
            metaSize = 28;
        }
        const [externalCallRent, externalCallMetaRent, deBridgeFees, nonceAccount] = await Promise.all([
            getMinimumBalanceForRentExemption(this.program.provider.connection, extCallSize),
            getMinimumBalanceForRentExemption(this.program.provider.connection, metaSize),
            (async () => {
                const [chainAddr] = this.debridge.accountsResolver.getChainSupportInfoAddress(giveChainId);
                const fees = await this.debridge.getFeesOrGlobal(chainAddr);
                const fixFee = BigInt(fees.fixedFee.toString()); // in lamports
                const BD = BigInt(constants.BPS_DENOMINATOR);
                const amount = (targetExecutionFeeInLamports * BD) / (BD - BigInt(fees.transferFeeBps.toString())); // in wrapped sol, lamports
                return { fixFee, accountedExecutionFee: amount };
            })(),
            this.program.provider.connection.getAccountInfo(debridgeNonceMaster),
        ]);
        let finalAmount = BigInt(takeOrderState) + BigInt(externalCallRent) + BigInt(externalCallMetaRent) + signFee;
        if (nonceAccount === null || nonceAccount === undefined || nonceAccount.lamports === 0) {
            // discriminator + nonce
            const nonceSize = 8 + 8;
            const nonceRent = await getMinimumBalanceForRentExemption(this.program.provider.connection, nonceSize);
            finalAmount += BigInt(nonceRent);
        }
        let totalCost = deBridgeFees.fixFee + deBridgeFees.accountedExecutionFee + finalAmount;
        if (priorityFee) {
            totalCost += priorityFee;
        }
        return {
            accountedExecutionFee: deBridgeFees.accountedExecutionFee,
            fixFee: deBridgeFees.fixFee,
            transactionCost: {
                chainId: ChainId.Solana,
                gasLimit: finalAmount,
                gasPrice: 1n,
                totalCost: finalAmount,
            },
            totalCost,
        };
    }
    async getClaimExecutionFees(takeChainAddressLength, takeChainId, takeChainToken, solPrice, tokenPrice, tokenDecimals, mode, batchSize) {
        let extCall;
        switch (mode) {
            case "cancel": {
                extCall = helpers.hexToBuffer("0xfeffffffffffffff01f01d1f0000000000000000000101000000000000000100000000000000010000008c97258f4e2489f1bb3d1029148e0d830b5a1399daff1084048e7bd8dbe9f8590300000000000000000000002000000000000000c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c800000000200000000000000006ddf6e1d765a193d9cbe146ceeb79ac1cb485ed5f5b37913a8cf5857eff00a9000000002000000000000000646464646464646464646464646464646464646464646464646464646464646400008c97258f4e2489f1bb3d1029148e0d830b5a1399daff1084048e7bd8dbe9f85906000000000000001968562fef0aab1b1d8f99d44306595cd4ba41d7cc899c007a774d23ad702ff601019f3d96f657370bf1dbb3313efba51ea7a08296ac33d77b949e1b62d538db37f20001c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c80000646464646464646464646464646464646464646464646464646464646464646400000000000000000000000000000000000000000000000000000000000000000000000006ddf6e1d765a193d9cbe146ceeb79ac1cb485ed5f5b37913a8cf5857eff00a90000010000000000000001fdffffffffffffff00000000000107000000000000000200000000000000010000000d0720cc7c6605b7736c08b95ad98d6b67f2da0ede7eff702e76a173c18e9d3601000000000000000000000005000000000000005354415445000300000000000000010000000d0720cc7c6605b7736c08b95ad98d6b67f2da0ede7eff702e76a173c18e9d360100000000000000000000000a00000000000000464545204c4544474552000400000000000000010000000d0720cc7c6605b7736c08b95ad98d6b67f2da0ede7eff702e76a173c18e9d3602000000000000000000000011000000000000004645455f4c45444745525f57414c4c45540000000020000000000000006464646464646464646464646464646464646464646464646464646464646464000600000000000000010000000d0720cc7c6605b7736c08b95ad98d6b67f2da0ede7eff702e76a173c18e9d360200000000000000000000001000000000000000474956455f4f524445525f5354415445000000002000000000000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff000700000000000000010000008c97258f4e2489f1bb3d1029148e0d830b5a1399daff1084048e7bd8dbe9f8590300000000000000000000002000000000000000c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c800000000200000000000000006ddf6e1d765a193d9cbe146ceeb79ac1cb485ed5f5b37913a8cf5857eff00a90000000020000000000000006464646464646464646464646464646464646464646464646464646464646464000900000000000000010000000d0720cc7c6605b7736c08b95ad98d6b67f2da0ede7eff702e76a173c18e9d360200000000000000000000001100000000000000474956455f4f524445525f57414c4c4554000000002000000000000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff000b00000000000000010000000d0720cc7c6605b7736c08b95ad98d6b67f2da0ede7eff702e76a173c18e9d360200000000000000000000001800000000000000415554484f52495a45445f4e41544956455f53454e4445520000000020000000000000000a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a00000d0720cc7c6605b7736c08b95ad98d6b67f2da0ede7eff702e76a173c18e9d360d0000000000000062584959deb8a728a91cebdc187b545d920479265052145f31fb80c73fac5aea00001968562fef0aab1b1d8f99d44306595cd4ba41d7cc899c007a774d23ad702ff60101980176896e24d940ee6f0a89d0020e1cd53aa3d17be42270bb39223f6ed75c6300018c6ecc336484fb8f32871d3c1656d832cc86eb2465048fea348cde76ae57233100014026e8772b7640ce6fb9fd348473f43df344e3dcd89a43c93db81ee6efe08e67000106a7d517187bd16635dad40455fdc2c0c124c68f215675a5dbbacb5f080000000000107fe6a33e564217c5773c604a479581564c5e4c12465d65c9374ee2190f5ee400019f3d96f657370bf1dbb3313efba51ea7a08296ac33d77b949e1b62d538db37f20001c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c800011507b8f891ebbfc57577d4d2e6a2b52dc0a744eba2be503e686d0d07d19e6ec7000164646464646464646464646464646464646464646464646464646464646464640000efe9c4afa6dc798a27b0c18e3cf0b76ad3fe8cc93764f6cb3112f9397f2cd1c6000006ddf6e1d765a193d9cbe146ceeb79ac1cb485ed5f5b37913a8cf5857eff00a90000280000000000000013617eeecc8d454cffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
                break;
            }
            case "unlock": {
                extCall = helpers.hexToBuffer("0xfeffffffffffffff01f01d1f0000000000000000000101000000000000000100000000000000010000008c97258f4e2489f1bb3d1029148e0d830b5a1399daff1084048e7bd8dbe9f8590300000000000000000000002000000000000000c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c800000000200000000000000006ddf6e1d765a193d9cbe146ceeb79ac1cb485ed5f5b37913a8cf5857eff00a9000000002000000000000000646464646464646464646464646464646464646464646464646464646464646400008c97258f4e2489f1bb3d1029148e0d830b5a1399daff1084048e7bd8dbe9f85906000000000000001968562fef0aab1b1d8f99d44306595cd4ba41d7cc899c007a774d23ad702ff601019f3d96f657370bf1dbb3313efba51ea7a08296ac33d77b949e1b62d538db37f20001c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c80000646464646464646464646464646464646464646464646464646464646464646400000000000000000000000000000000000000000000000000000000000000000000000006ddf6e1d765a193d9cbe146ceeb79ac1cb485ed5f5b37913a8cf5857eff00a90000010000000000000001fdffffffffffffff00000000000107000000000000000200000000000000010000000d0720cc7c6605b7736c08b95ad98d6b67f2da0ede7eff702e76a173c18e9d3601000000000000000000000005000000000000005354415445000300000000000000010000000d0720cc7c6605b7736c08b95ad98d6b67f2da0ede7eff702e76a173c18e9d360100000000000000000000000a00000000000000464545204c4544474552000400000000000000010000000d0720cc7c6605b7736c08b95ad98d6b67f2da0ede7eff702e76a173c18e9d3602000000000000000000000011000000000000004645455f4c45444745525f57414c4c45540000000020000000000000006464646464646464646464646464646464646464646464646464646464646464000600000000000000010000000d0720cc7c6605b7736c08b95ad98d6b67f2da0ede7eff702e76a173c18e9d360200000000000000000000001000000000000000474956455f4f524445525f5354415445000000002000000000000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff000700000000000000010000008c97258f4e2489f1bb3d1029148e0d830b5a1399daff1084048e7bd8dbe9f8590300000000000000000000002000000000000000c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c800000000200000000000000006ddf6e1d765a193d9cbe146ceeb79ac1cb485ed5f5b37913a8cf5857eff00a90000000020000000000000006464646464646464646464646464646464646464646464646464646464646464000900000000000000010000000d0720cc7c6605b7736c08b95ad98d6b67f2da0ede7eff702e76a173c18e9d360200000000000000000000001100000000000000474956455f4f524445525f57414c4c4554000000002000000000000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff000b00000000000000010000000d0720cc7c6605b7736c08b95ad98d6b67f2da0ede7eff702e76a173c18e9d360200000000000000000000001800000000000000415554484f52495a45445f4e41544956455f53454e4445520000000020000000000000000a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a00000d0720cc7c6605b7736c08b95ad98d6b67f2da0ede7eff702e76a173c18e9d360d0000000000000062584959deb8a728a91cebdc187b545d920479265052145f31fb80c73fac5aea00001968562fef0aab1b1d8f99d44306595cd4ba41d7cc899c007a774d23ad702ff60101980176896e24d940ee6f0a89d0020e1cd53aa3d17be42270bb39223f6ed75c6300018c6ecc336484fb8f32871d3c1656d832cc86eb2465048fea348cde76ae57233100014026e8772b7640ce6fb9fd348473f43df344e3dcd89a43c93db81ee6efe08e67000106a7d517187bd16635dad40455fdc2c0c124c68f215675a5dbbacb5f080000000000107fe6a33e564217c5773c604a479581564c5e4c12465d65c9374ee2190f5ee400019f3d96f657370bf1dbb3313efba51ea7a08296ac33d77b949e1b62d538db37f20001c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c800011507b8f891ebbfc57577d4d2e6a2b52dc0a744eba2be503e686d0d07d19e6ec7000164646464646464646464646464646464646464646464646464646464646464640000efe9c4afa6dc798a27b0c18e3cf0b76ad3fe8cc93764f6cb3112f9397f2cd1c6000006ddf6e1d765a193d9cbe146ceeb79ac1cb485ed5f5b37913a8cf5857eff00a9000028000000000000005951b44f8e9042fbffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
                break;
            }
            case "batchUnlock": {
                if (batchSize === undefined)
                    throw new ClientError(ClientErrorType.WrongBatchSize);
                const claimUnlockIx = helpers.hexToBuffer("0xfdffffffffffffff00000000000107000000000000000200000000000000010000000d0720cc7c6605b7736c08b95ad98d6b67f2da0ede7eff702e76a173c18e9d3601000000000000000000000005000000000000005354415445000300000000000000010000000d0720cc7c6605b7736c08b95ad98d6b67f2da0ede7eff702e76a173c18e9d360100000000000000000000000a00000000000000464545204c4544474552000400000000000000010000000d0720cc7c6605b7736c08b95ad98d6b67f2da0ede7eff702e76a173c18e9d3602000000000000000000000011000000000000004645455f4c45444745525f57414c4c45540000000020000000000000006464646464646464646464646464646464646464646464646464646464646464000600000000000000010000000d0720cc7c6605b7736c08b95ad98d6b67f2da0ede7eff702e76a173c18e9d360200000000000000000000001000000000000000474956455f4f524445525f5354415445000000002000000000000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff000700000000000000010000008c97258f4e2489f1bb3d1029148e0d830b5a1399daff1084048e7bd8dbe9f8590300000000000000000000002000000000000000c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c800000000200000000000000006ddf6e1d765a193d9cbe146ceeb79ac1cb485ed5f5b37913a8cf5857eff00a90000000020000000000000006464646464646464646464646464646464646464646464646464646464646464000900000000000000010000000d0720cc7c6605b7736c08b95ad98d6b67f2da0ede7eff702e76a173c18e9d360200000000000000000000001100000000000000474956455f4f524445525f57414c4c4554000000002000000000000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff000b00000000000000010000000d0720cc7c6605b7736c08b95ad98d6b67f2da0ede7eff702e76a173c18e9d360200000000000000000000001800000000000000415554484f52495a45445f4e41544956455f53454e4445520000000020000000000000000a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a00000d0720cc7c6605b7736c08b95ad98d6b67f2da0ede7eff702e76a173c18e9d360d0000000000000062584959deb8a728a91cebdc187b545d920479265052145f31fb80c73fac5aea00001968562fef0aab1b1d8f99d44306595cd4ba41d7cc899c007a774d23ad702ff60101980176896e24d940ee6f0a89d0020e1cd53aa3d17be42270bb39223f6ed75c6300018c6ecc336484fb8f32871d3c1656d832cc86eb2465048fea348cde76ae57233100014026e8772b7640ce6fb9fd348473f43df344e3dcd89a43c93db81ee6efe08e67000106a7d517187bd16635dad40455fdc2c0c124c68f215675a5dbbacb5f080000000000107fe6a33e564217c5773c604a479581564c5e4c12465d65c9374ee2190f5ee400019f3d96f657370bf1dbb3313efba51ea7a08296ac33d77b949e1b62d538db37f20001c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c800011507b8f891ebbfc57577d4d2e6a2b52dc0a744eba2be503e686d0d07d19e6ec7000164646464646464646464646464646464646464646464646464646464646464640000efe9c4afa6dc798a27b0c18e3cf0b76ad3fe8cc93764f6cb3112f9397f2cd1c6000006ddf6e1d765a193d9cbe146ceeb79ac1cb485ed5f5b37913a8cf5857eff00a9000028000000000000005951b44f8e9042fbffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
                const initWallet = helpers.hexToBuffer("0xfeffffffffffffff01f01d1f0000000000000000000101000000000000000100000000000000010000008c97258f4e2489f1bb3d1029148e0d830b5a1399daff1084048e7bd8dbe9f8590300000000000000000000002000000000000000c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c800000000200000000000000006ddf6e1d765a193d9cbe146ceeb79ac1cb485ed5f5b37913a8cf5857eff00a9000000002000000000000000646464646464646464646464646464646464646464646464646464646464646400008c97258f4e2489f1bb3d1029148e0d830b5a1399daff1084048e7bd8dbe9f85906000000000000001968562fef0aab1b1d8f99d44306595cd4ba41d7cc899c007a774d23ad702ff601019f3d96f657370bf1dbb3313efba51ea7a08296ac33d77b949e1b62d538db37f20001c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c8c80000646464646464646464646464646464646464646464646464646464646464646400000000000000000000000000000000000000000000000000000000000000000000000006ddf6e1d765a193d9cbe146ceeb79ac1cb485ed5f5b37913a8cf5857eff00a90000010000000000000001");
                extCall = Buffer.concat([
                    initWallet,
                    ...Array.from({ length: batchSize }).fill(claimUnlockIx),
                ]);
            }
        }
        const execFee = await this.debridge.calculateExecutionFee(takeChainAddressLength, crypto.hashDebridgeId(takeChainId, takeChainToken), solPrice, tokenPrice, tokenDecimals, false, 1.3, false, extCall);
        delete execFee.externalCallWithRewards;
        return execFee;
    }
    alignBeneficiary(beneficiary, size = 32) {
        return Buffer.concat([Buffer.from(Uint8Array.from({ length: size - beneficiary.length }).fill(0)), beneficiary]);
    }
    buildCancelCalldata(orderId, beneficiary) {
        const EVM_ORDER_CANCEL_PREFIX = Buffer.from([212, 139, 1, 70]);
        return Buffer.concat([EVM_ORDER_CANCEL_PREFIX, orderId, this.alignBeneficiary(beneficiary)]);
    }
    buildUnlockCalldata(orderId, beneficiary) {
        const EVM_ORDER_UNLOCK_PREFIX = Buffer.from([88, 134, 216, 210]);
        return Buffer.concat([EVM_ORDER_UNLOCK_PREFIX, orderId, this.alignBeneficiary(beneficiary)]);
    }
    buildBatchUnlockCalldata(orderIds, beneficiary) {
        const EVM_ORDER_BATCH_UNLOCK_PREFIX = Buffer.from("6abd4ea7", "hex");
        const CONST_1 = Buffer.from("0000000000000000000000000000000000000000000000000000000000000040", "hex");
        const alignedOrdesCount = Buffer.allocUnsafe(32).fill(0);
        // order count will never be more than INT32_MAX, so it's ok to use i32
        alignedOrdesCount.writeInt32BE(orderIds.length, 28);
        return Buffer.concat([
            EVM_ORDER_BATCH_UNLOCK_PREFIX,
            CONST_1,
            this.alignBeneficiary(beneficiary),
            alignedOrdesCount,
            ...orderIds,
        ]);
    }
    async sendBatchUnlock(unlocker, orderIds, giveChain, beneficiary, executionFee, unlockerWallet) {
        unlocker = new PublicKey(unlocker);
        unlockerWallet = unlockerWallet ? unlockerWallet : findAssociatedTokenAddress(unlocker, WRAPPED_SOL_MINT)[0];
        orderIds = orderIds.map((oid) => (typeof oid === "string" ? helpers.hexToBuffer(oid) : oid));
        const takeOrderStates = orderIds.map((oid) => ({
            isSigner: false,
            isWritable: true,
            pubkey: this.accountsResolver.getTakeOrderStateAddress(oid)[0],
        }));
        const giveChainBuffer = Buffer.from(bigintToArray(giveChain, "u256"));
        const sendBuilder = this.program.methods.sendBatchUnlock(beneficiary, new BN(executionFee.toString()));
        const unlockCalldata = this.buildBatchUnlockCalldata(orderIds, beneficiary);
        const context = await this.buildSendingContext(giveChainBuffer, beneficiary, unlockCalldata);
        sendBuilder.accountsStrict({
            sending: context,
            authorizedSrcContract: this.accountsResolver.getAuthorizedSrcContractAddress(giveChainBuffer)[0],
            unlocker,
        });
        sendBuilder.remainingAccounts(takeOrderStates);
        const prepareBuilder = this.program.methods.prepareSend();
        prepareBuilder.accountsStrict({
            debridgeState: context.state,
            takeOrderState: SystemProgram.programId,
            payer: unlocker,
            payerWallet: unlockerWallet,
            sendFromWallet: context.sendFromWallet,
            sendFrom: context.sendFrom,
            chainSupportInfo: context.chainSupportInfo,
            instructions: SYSVAR_INSTRUCTIONS_PUBKEY,
            splTokenProgram: TOKEN_PROGRAM_ID,
            systemProgram: SystemProgram.programId,
        });
        const instructions = await Promise.all([
            prepareBuilder.instruction(),
            sendBuilder.instruction(),
        ]);
        return {
            instructions,
            payer: unlocker,
            ALTs: [await this.getSendALT()],
        };
    }
    async cancelOrder(canceler, order) {
        const anchorOrder = orderDataToAnchorFormat(order);
        const [[takeOrderState], [authorizedAddress]] = await Promise.all([
            this.accountsResolver.getTakeOrderStateAddress(Buffer.from(order.orderId)),
            this.accountsResolver.getAuthorizedSrcContractAddress(Buffer.from(bigintToArray(order.give.chainId, "u256"))),
        ]);
        const builder = this.program.methods.cancelOrder(anchorOrder, Array.from(order.orderId));
        builder.accountsStrict({
            authorizedSrcContract: authorizedAddress,
            systemProgram: SystemProgram.programId,
            takeOrderState,
            canceler,
        });
        return builder.instruction();
    }
    async sendOrderCancel(canceler, orderId, giveChain, cancelBeneficiary, executionFee, cancelerWallet) {
        let instructions = [];
        orderId = typeof orderId === "string" ? helpers.hexToBuffer(orderId) : orderId;
        const giveChainBuffer = Buffer.from(bigintToArray(giveChain, "u256"));
        const [takeOrderStateAddress] = this.accountsResolver.getTakeOrderStateAddress(orderId);
        const cancelBeneficiaryBuffer = Buffer.from(cancelBeneficiary);
        const [authorizedAddress] = this.accountsResolver.getAuthorizedSrcContractAddress(giveChainBuffer);
        const cancelData = this.buildCancelCalldata(orderId, cancelBeneficiaryBuffer);
        const context = await this.buildSendingContext(giveChainBuffer, cancelBeneficiaryBuffer, cancelData);
        const builder = this.program.methods.sendOrderCancel(Array.from(orderId), cancelBeneficiaryBuffer, bigintToBN(executionFee));
        canceler = new PublicKey(canceler);
        cancelerWallet = cancelerWallet ? cancelerWallet : findAssociatedTokenAddress(canceler, WRAPPED_SOL_MINT)[0];
        builder.accountsStrict({
            sending: context,
            authorizedSrcContract: authorizedAddress,
            canceler,
            takeOrderState: takeOrderStateAddress,
        });
        const prepareBuilder = this.program.methods.prepareSend();
        prepareBuilder.accountsStrict({
            debridgeState: context.state,
            takeOrderState: takeOrderStateAddress,
            payer: canceler,
            payerWallet: cancelerWallet,
            sendFromWallet: context.sendFromWallet,
            sendFrom: context.sendFrom,
            chainSupportInfo: context.chainSupportInfo,
            instructions: SYSVAR_INSTRUCTIONS_PUBKEY,
            splTokenProgram: TOKEN_PROGRAM_ID,
            systemProgram: SystemProgram.programId,
        });
        instructions = [...instructions, ...(await Promise.all([prepareBuilder.instruction(), builder.instruction()]))];
        return {
            instructions,
            ALTs: [await this.getSendALT()],
            payer: canceler,
        };
    }
    async buildFullCancelTransaction(canceler, orderId, giveChain, orderWithId, cancelBeneficiary, executionFee, cancelerWallet) {
        const [cancelIx, { instructions, ALTs, payer }] = await Promise.all([
            this.cancelOrder(canceler, orderWithId),
            this.sendOrderCancel(canceler, orderId, giveChain, cancelBeneficiary, executionFee, cancelerWallet),
        ]);
        return {
            instructions: [cancelIx, ...instructions],
            ALTs,
            payer,
        };
    }
    async sendUnlock(unlocker, orderId, giveChain, beneficiary, executionFee, unlockerWallet) {
        orderId = typeof orderId === "string" ? helpers.hexToBuffer(orderId) : orderId;
        const giveChainBuffer = Buffer.from(bigintToArray(giveChain, "u256"));
        unlocker = new PublicKey(unlocker);
        unlockerWallet = unlockerWallet ? unlockerWallet : findAssociatedTokenAddress(unlocker, WRAPPED_SOL_MINT)[0];
        const [authorizedAddress] = this.accountsResolver.getAuthorizedSrcContractAddress(giveChainBuffer);
        const [takeOrderStateAddress] = this.accountsResolver.getTakeOrderStateAddress(orderId);
        const unlockData = this.buildUnlockCalldata(orderId, beneficiary);
        const context = await this.buildSendingContext(giveChainBuffer, beneficiary, unlockData);
        const builder = this.program.methods.sendUnlock(Array.from(orderId), beneficiary, bigintToBN(executionFee));
        builder.accountsStrict({
            authorizedSrcContract: authorizedAddress,
            takeOrderState: takeOrderStateAddress,
            unlocker,
            sending: context,
        });
        const prepareBuilder = this.program.methods.prepareSend();
        prepareBuilder.accountsStrict({
            sendFrom: context.sendFrom,
            sendFromWallet: context.sendFromWallet,
            payer: unlocker,
            payerWallet: unlockerWallet,
            chainSupportInfo: context.chainSupportInfo,
            takeOrderState: takeOrderStateAddress,
            debridgeState: context.state,
            systemProgram: SystemProgram.programId,
            splTokenProgram: TOKEN_PROGRAM_ID,
            instructions: SYSVAR_INSTRUCTIONS_PUBKEY,
        });
        const instructions = await Promise.all([prepareBuilder.instruction(), builder.instruction()]);
        // const computeBudgetIx = ComputeBudgetProgram.setComputeUnitLimit({ units: UNLOCK_UNITS });
        // const computeBudgetPriceIx = ComputeBudgetProgram.setComputeUnitPrice({ microLamports: UNLOCK_UNIT_PRICE });
        return {
            instructions,
            payer: unlocker,
            ALTs: [await this.getSendALT()],
        };
    }
    async fulfillOrder(order, taker, unlockAuthority, takerWallet, initMissingRecieverWallet = true) {
        const result = new Transaction();
        const orderId = Buffer.from(order.orderId);
        const builder = this.program.methods.fulfillOrder(orderDataToAnchorFormat(order), Array.from(order.orderId), unlockAuthority || null);
        const [authorizedAddress] = this.accountsResolver.getAuthorizedSrcContractAddress(Buffer.from(bigintToArray(order.give.chainId, "u256")));
        const takeMint = new PublicKey(order.take.tokenAddress);
        const nativeMint = "11111111111111111111111111111111";
        const isNative = nativeMint === takeMint.toBase58();
        const receiver = new PublicKey(order.receiver);
        let [receiverWallet] = findAssociatedTokenAddress(receiver, takeMint);
        takerWallet = takerWallet || findAssociatedTokenAddress(taker, takeMint)[0];
        if (isNative) {
            // [0;32]
            takerWallet = taker;
            receiverWallet = receiver;
        }
        else {
            const receiverWalletData = await this.program.provider.connection.getAccountInfo(receiverWallet);
            if (initMissingRecieverWallet &&
                (receiverWalletData === null || receiverWalletData?.lamports === 0) &&
                order.externalCall === undefined) {
                const initIx = new TransactionInstruction({
                    keys: [
                        {
                            isSigner: true,
                            isWritable: true,
                            pubkey: taker,
                        },
                        {
                            isSigner: false,
                            isWritable: true,
                            pubkey: receiverWallet,
                        },
                        {
                            isSigner: false,
                            isWritable: false,
                            pubkey: receiver,
                        },
                        {
                            isSigner: false,
                            isWritable: false,
                            pubkey: takeMint,
                        },
                        {
                            isSigner: false,
                            isWritable: false,
                            pubkey: SystemProgram.programId,
                        },
                        {
                            isSigner: false,
                            isWritable: false,
                            pubkey: TOKEN_PROGRAM_ID,
                        },
                    ],
                    data: Buffer.from([0]),
                    programId: ASSOCIATED_TOKEN_PROGRAM_ID,
                });
                result.add(initIx);
            }
        }
        if (order.externalCall !== undefined) {
            receiverWallet = receiver;
        }
        builder.accountsStrict({
            receiverDst: receiverWallet,
            taker,
            authorizedSrcContract: authorizedAddress,
            takeOrderState: this.accountsResolver.getTakeOrderStateAddress(orderId)[0],
            takeOrderPatch: this.accountsResolver.getTakePatchAddress(orderId)[0],
            takerWallet,
            systemProgram: SystemProgram.programId,
            splTokenProgram: TOKEN_PROGRAM_ID,
        });
        if (order.externalCall?.externalCallData !== undefined) {
            const extcallProgram = new PublicKey(order.receiver);
            const executorWallet = findExtcallWalletAddress(extcallProgram, order.orderId, isNative);
            builder.remainingAccounts([
                {
                    // extcall state
                    isSigner: false,
                    isWritable: false,
                    pubkey: findExtcallStateAddress(extcallProgram),
                },
                {
                    // extcall meta
                    isSigner: false,
                    isWritable: true,
                    pubkey: findExtcallMetaAddress(extcallProgram, order.orderId),
                },
                {
                    // execute wallet
                    isSigner: false,
                    isWritable: true,
                    pubkey: executorWallet,
                },
                {
                    // token mint
                    isSigner: false,
                    isWritable: false,
                    pubkey: new PublicKey(order.take.tokenAddress),
                },
                {
                    isSigner: false,
                    isWritable: false,
                    pubkey: SYSVAR_INSTRUCTIONS_PUBKEY,
                },
            ]);
        }
        const fulfillIx = await builder.instruction();
        if (order.externalCall === undefined) {
            fulfillIx.keys[3].isWritable = true;
        }
        else {
            fulfillIx.keys[3].isWritable = false;
        }
        return result.add(fulfillIx);
    }
    async getPatchedTakeAmount(orderId) {
        const [takePatchAddress] = this.accountsResolver.getTakePatchAddress(typeof orderId === "string" ? helpers.hexToBuffer(orderId) : Buffer.from(orderId));
        const patchData = await this.program.account.takeOrderPatch.fetchNullable(takePatchAddress);
        if (patchData === null || patchData?.orderTakeFinalAmount === null)
            return null;
        return BigInt(patchData.orderTakeFinalAmount.toString());
    }
    async patchTake(patcher, order, subtrahend) {
        const builder = this.program.methods.patchTakeOrder(orderDataToAnchorFormat(order), Array.from(order.orderId), new BN(subtrahend.toString()));
        builder.accountsStrict({
            patcher,
            takeOrderPatch: this.accountsResolver.getTakePatchAddress(Buffer.from(order.orderId))[0],
            authorizedSrcContract: this.accountsResolver.getAuthorizedSrcContractAddress(Buffer.from(bigintToArray(order.give.chainId, "u256")))[0],
            systemProgram: SystemProgram.programId,
        });
        return builder.transaction();
    }
    async getTakeOrderState(orderId, commitment = "confirmed") {
        const result = await this.getMultipleTakeOrderState([orderId], commitment);
        return result[0];
    }
    async getMultipleTakeOrderState(orderId, commitment) {
        const takeAccounts = [];
        for (const oid of orderId) {
            if (oid instanceof Uint8Array || typeof oid === "string") {
                takeAccounts.push(this.accountsResolver.getTakeOrderStateAddress(oid instanceof Uint8Array ? Buffer.from(oid) : helpers.hexToBuffer(oid))[0]);
            }
            else {
                takeAccounts.push(oid);
            }
        }
        let decoder;
        const fethedData = await this.program.provider.connection.getMultipleAccountsInfo(takeAccounts, commitment);
        switch (this.version) {
            case Env.Lima: {
                decoder = new BorshAccountsCoder(LimaIDL);
                break;
            }
            case Env.Hanoi: {
                decoder = new BorshAccountsCoder(HanoiIDL);
                break;
            }
            case Env.Prod:
            case Env.Madrid: {
                decoder = new BorshAccountsCoder(IDL);
                break;
            }
        }
        const result = [];
        for (const takeStateAccount of fethedData) {
            if (!takeStateAccount || takeStateAccount.lamports === 0 || takeStateAccount.data.length === 0) {
                result.push(null);
                continue;
            }
            const state = decoder.decode("takeOrderState", takeStateAccount.data);
            const giveChainId = new BN(state.sourceChainId).toNumber();
            const orderState = state.orderState;
            if ("fulfilled" in orderState || "oldFulfilled" in orderState) {
                const fulfilled = (orderState.oldFulfilled || orderState.fulfilled);
                result.push({
                    status: 2 /* OrderState.Fulfilled */,
                    giveChainId,
                    takerAddress: fulfilled.unlockAuthority.toBuffer(),
                    orderId: fulfilled.orderId ? Uint8Array.from(fulfilled.orderId) : undefined,
                });
            }
            else if ("cancelled" in orderState)
                result.push({
                    status: 4 /* OrderState.Canceled */,
                    giveChainId,
                    takerAddress: orderState.cancelled.canceler.toBuffer(),
                });
            else if ("sentCancel" in orderState)
                result.push({
                    status: 5 /* OrderState.SentCancel */,
                    giveChainId,
                    takerAddress: orderState.sentCancel.canceler.toBuffer(),
                });
            else if ("sentUnlock" in orderState)
                result.push({
                    status: 3 /* OrderState.SentUnlock */,
                    giveChainId,
                    takerAddress: orderState.sentUnlock.unlocker.toBuffer(),
                });
            else
                result.push(null);
        }
        return result;
    }
}
//# sourceMappingURL=dlnDst.js.map
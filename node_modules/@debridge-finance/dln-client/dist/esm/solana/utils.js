import { Buffer } from "buffer";
import { nu64, f64, u8, struct } from "@solana/buffer-layout";
import { ASSOCIATED_TOKEN_PROGRAM_ID, findAssociatedTokenAddress, helpers, spl, TOKEN_PROGRAM_ID, WRAPPED_SOL_MINT, } from "@debridge-finance/solana-utils";
import { BN, utils } from "@coral-xyz/anchor";
import { AddressLookupTableAccount, AddressLookupTableProgram, PublicKey, SystemProgram, SYSVAR_RENT_PUBKEY, Transaction, TransactionInstruction, } from "@solana/web3.js";
import { Logger } from "../common/logger";
import { Order } from "../order";
const CACHE = new Map();
export async function getAccountInfoCached(connection, acc) {
    const key = `acc_${acc.toBase58()}`;
    const entry = CACHE.get(key);
    if (entry && entry !== null) {
        return entry;
    }
    else {
        const resp = await connection.getAccountInfo(acc);
        CACHE.set(key, resp);
        return resp;
    }
}
function decodeRentSysvar(rent) {
    const rentStruct = struct([nu64("lamportsPerByteYear"), f64("exemptionThreshold"), u8("burnPercent")]);
    return rentStruct.decode(rent.data);
}
export async function getMinimumBalanceForRentExemption(connection, size) {
    const rentAccount = await connection.getAccountInfo(SYSVAR_RENT_PUBKEY);
    const BASE = 890880;
    if (!rentAccount)
        throw new Error(`Failed to fetch rent account`);
    const decodedRent = decodeRentSysvar(rentAccount);
    // rent = base + bytesCount * (2 years * lamportsPerYear)
    return BASE + decodedRent.lamportsPerByteYear * size * decodedRent.exemptionThreshold;
}
export function bigintToBN(n) {
    return new BN(n.toString());
}
export function bigintToArray(n, type) {
    let size;
    switch (type) {
        case "u256":
            size = 32;
            break;
        case "u64":
            size = 8;
            break;
    }
    return new BN(n.toString()).toArray("be", size);
}
export function orderDataToAnchorFormat(order) {
    return {
        makerOrderNonce: bigintToBN(order.nonce),
        makerSrc: Buffer.from(order.maker),
        give: {
            amount: bigintToArray(order.give.amount, "u256"),
            chainId: bigintToArray(order.give.chainId, "u256"),
            tokenAddress: Buffer.from(order.give.tokenAddress),
        },
        take: {
            amount: bigintToArray(order.take.amount, "u256"),
            chainId: bigintToArray(order.take.chainId, "u256"),
            tokenAddress: Buffer.from(order.take.tokenAddress),
        },
        receiverDst: Buffer.from(order.receiver),
        givePatchAuthoritySrc: Buffer.from(order.givePatchAuthority),
        orderAuthorityAddressDst: Buffer.from(order.orderAuthorityDstAddress),
        allowedTakerDst: order.allowedTaker ? Buffer.from(order.allowedTaker) : null,
        allowedCancelBeneficiarySrc: order.allowedCancelBeneficiary ? Buffer.from(order.allowedCancelBeneficiary) : null,
        externalCall: order.externalCall === undefined
            ? null
            : {
                externalCallShortcut: Array.from(Order.getExternalCallHash(order.externalCall)),
            },
    };
}
function numToBigint(num) {
    return BigInt(new BN(num).toString());
}
export function solanaOrderToOrderData(order) {
    return {
        give: {
            amount: numToBigint(order.give.amount),
            chainId: Number(numToBigint(order.give.chainId)),
            tokenAddress: Uint8Array.from(order.give.tokenAddress),
        },
        take: {
            amount: numToBigint(order.take.amount),
            chainId: Number(numToBigint(order.take.chainId)),
            tokenAddress: Uint8Array.from(order.take.tokenAddress),
        },
        givePatchAuthority: Uint8Array.from(order.givePatchAuthoritySrc),
        maker: Uint8Array.from(order.makerSrc),
        nonce: BigInt(order.makerOrderNonce.toString()),
        orderAuthorityDstAddress: Uint8Array.from(order.orderAuthorityAddressDst),
        receiver: Uint8Array.from(order.receiverDst),
        allowedCancelBeneficiary: order.allowedCancelBeneficiarySrc
            ? Uint8Array.from(order.allowedCancelBeneficiarySrc)
            : undefined,
        allowedTaker: order.allowedTakerDst ? Uint8Array.from(order.allowedTakerDst) : undefined,
        externalCall: order.externalCall
            ? {
                externalCallHash: Uint8Array.from(order.externalCall.externalCallShortcut),
                // TODO
                externalCallData: new Uint8Array(),
            }
            : undefined,
    };
}
export async function findALT(connection, pattern) {
    const encoded = utils.bytes.bs58.encode(Buffer.from(pattern));
    const tableStartOffset = 0x38;
    const [active] = await Promise.all([
        connection.getProgramAccounts(AddressLookupTableProgram.programId, {
            filters: [{ memcmp: { offset: tableStartOffset, bytes: encoded } }], // active not frozen
        }),
    ]);
    return active;
}
export async function getSolanaDecimals(connection, tokenAddress) {
    const tokenMint = new PublicKey(tokenAddress.startsWith("0x") ? helpers.hexToBuffer(tokenAddress) : tokenAddress);
    // native sol
    if (tokenMint.toBase58() === "1".repeat(32) || tokenMint.equals(WRAPPED_SOL_MINT))
        return 9;
    const mintAccountData = await connection.getParsedAccountInfo(tokenMint);
    if (!mintAccountData || !mintAccountData?.value?.data?.parsed?.info)
        throw new Error("failed to get token mint info");
    const parsedData = (mintAccountData.value?.data).parsed;
    return parsedData.info.decimals;
}
export async function getTokenInfo(connection, tokenAddress) {
    if (tokenAddress.toBase58() === "1".repeat(32)) {
        return {
            name: "Native SOL",
            symbol: "SOL",
        };
    }
    try {
        const result = await spl.getTokenInfo(connection, tokenAddress);
        if (result === null)
            throw new Error(`Failed to get info for token: ${tokenAddress.toBase58()}`);
        return {
            name: result.name,
            symbol: result.symbol,
        };
    }
    catch (e) {
        // TODO: monitoring
        const l = new Logger();
        l.error(e);
        return {
            name: "-",
            symbol: "-",
        };
    }
}
export function parseALT(message, alts) {
    const altMap = new Map(alts.map((alt) => [alt.key.toBase58(), alt]));
    const writable = [];
    const readonly = [];
    for (const msgALTref of message.addressTableLookups) {
        const altData = altMap.get(msgALTref.accountKey.toBase58());
        if (!altData)
            continue;
        // get writable
        msgALTref.writableIndexes.map((wIdx) => writable.push(altData.state.addresses[wIdx]));
        msgALTref.readonlyIndexes.map((roIdx) => readonly.push(altData.state.addresses[roIdx]));
    }
    return { writable, readonly };
}
export function prepareALT(slot, payer, addresses) {
    const [lookupTableInst, lookupTableAddress] = AddressLookupTableProgram.createLookupTable({
        authority: payer,
        payer,
        recentSlot: slot,
    });
    const ACCOUNTS_CHUNK_SIZE = 25;
    const txs = [
        new Transaction({ feePayer: payer }).add(lookupTableInst).add(AddressLookupTableProgram.extendLookupTable({
            payer,
            authority: payer,
            lookupTable: lookupTableAddress,
            addresses: addresses.slice(0, ACCOUNTS_CHUNK_SIZE),
        })),
    ];
    for (let i = ACCOUNTS_CHUNK_SIZE; i < addresses.length; i += ACCOUNTS_CHUNK_SIZE) {
        txs.push(new Transaction({ feePayer: payer }).add(AddressLookupTableProgram.extendLookupTable({
            payer,
            authority: payer,
            lookupTable: lookupTableAddress,
            addresses: addresses.slice(i, i + ACCOUNTS_CHUNK_SIZE),
        })));
    }
    return [lookupTableAddress, txs];
}
export function extendALT(lookupTableAddress, payer, addresses) {
    const extendInstruction = AddressLookupTableProgram.extendLookupTable({
        payer: payer,
        authority: payer,
        lookupTable: lookupTableAddress,
        addresses,
    });
    return extendInstruction;
}
/**
 *
 * @param alt
 * @param expectedAddresses
 * @returns false if ALT is broken
 */
export function verifyALT(alt, expectedAddresses) {
    if (!alt || !alt.isActive())
        return false;
    // some bug with PublicKey[] includes, 0 element couldnt be found
    const stateAccounts = alt.state.addresses.map((addr) => addr.toBase58());
    const missing = [];
    for (const expected of expectedAddresses) {
        if (!stateAccounts.includes(expected.toBase58())) {
            missing.push(expected.toBase58());
            // TODO: add logger with context (#65)
            // console.log(`Missing ${expected.toBase58()} in ${stateAccounts.join(",")}`);
        }
    }
    if (missing.length < 15) {
        console.log(`Missing: ${missing.length}`, missing, expectedAddresses.length, stateAccounts.length);
    }
    return missing.length === 0;
}
export function createATA(tokenMint, owner, payer, associatedTokenProgram) {
    return new TransactionInstruction({
        programId: associatedTokenProgram || ASSOCIATED_TOKEN_PROGRAM_ID,
        keys: [
            {
                pubkey: payer,
                isSigner: true,
                isWritable: true,
            },
            {
                pubkey: findAssociatedTokenAddress(owner, tokenMint)[0],
                isSigner: false,
                isWritable: true,
            },
            {
                pubkey: owner,
                isSigner: false,
                isWritable: false,
            },
            {
                pubkey: tokenMint,
                isSigner: false,
                isWritable: false,
            },
            {
                pubkey: SystemProgram.programId,
                isSigner: false,
                isWritable: false,
            },
            {
                pubkey: TOKEN_PROGRAM_ID,
                isSigner: false,
                isWritable: false,
            },
        ],
        data: Buffer.from([0]),
    });
}
/**
 * Shared map for all juipter instances
 */
const fetchedALTMap = new Map();
export async function getALTs(connection, altKeys) {
    const stringifiedKeys = altKeys.map((k) => k.toBase58());
    const altsToFetch = [];
    const result = [];
    for (const [idx, stringifiedKey] of stringifiedKeys.entries()) {
        const cacheEntry = fetchedALTMap.get(stringifiedKey);
        if (cacheEntry) {
            result.push(cacheEntry);
        }
        else {
            altsToFetch.push(altKeys[idx]);
        }
    }
    if (altsToFetch.length > 0) {
        const fetchedALTs = await connection.getMultipleAccountsInfo(altsToFetch);
        const parsedALTs = fetchedALTs
            .map((fetched, i) => fetched
            ? new AddressLookupTableAccount({
                state: AddressLookupTableAccount.deserialize(fetched.data),
                key: altsToFetch[i],
            })
            : null)
            .filter((x) => x != null);
        for (const parsedALT of parsedALTs) {
            fetchedALTMap.set(parsedALT.key.toBase58(), parsedALT);
        }
        result.push(...parsedALTs);
    }
    return result;
}
export async function prepareV0Transaction(connection, payer, instructions, addressLookupTables) {
    const toFetch = [];
    const provided = [];
    for (const maybeParsed of addressLookupTables ?? []) {
        if ("state" in maybeParsed && "key" in maybeParsed) {
            provided.push(maybeParsed);
        }
        else {
            toFetch.push(maybeParsed);
        }
    }
    const fetched = await getALTs(connection, toFetch);
    const ALTs = [...provided, ...fetched].filter((alt) => alt !== null);
    return {
        instructions,
        ALTs,
        payer,
    };
}
//# sourceMappingURL=utils.js.map
import { Buffer } from "buffer";
import { keccak256 } from "js-sha3";
import * as bl from "@solana/buffer-layout";
import * as blu from "@solana/buffer-layout-utils";
import { helpers } from "@debridge-finance/solana-utils";
import { ClientError } from "./errors/client-error.error";
import { ClientErrorType } from "./errors/client-error-type.enum";
class Optional extends bl.Layout {
    constructor(layout, property) {
        super(-1, property);
        this.layout = layout;
        this.discriminator = bl.u8();
    }
    encode(src, b, offset = 0) {
        if (src === null || src === undefined) {
            return this.discriminator.encode(0, b, offset);
        }
        this.discriminator.encode(1, b, offset);
        return this.layout.encode(src, b, offset + 1) + 1;
    }
    decode(b, offset = 0) {
        const discriminator = this.discriminator.decode(b, offset);
        if (discriminator === 0) {
            return null;
        }
        else if (discriminator === 1) {
            return this.layout.decode(b, offset + 1);
        }
        throw new Error(`Invalid option: ${this.property || "not set"}`);
    }
    getSpan(b, offset = 0) {
        const discriminator = this.discriminator.decode(b, offset);
        if (discriminator === 0) {
            return 1;
        }
        else if (discriminator === 1) {
            return this.layout.getSpan(b, offset + 1) + 1;
        }
        throw new Error(`Invalid option: ${this.property || "not set"}`);
    }
}
class U8Vec extends bl.Layout {
    constructor(property) {
        super(-1, property);
        const size = bl.u8("size");
        const elements = bl.seq(bl.u8(), bl.offset(size, -1), "elements");
        this.layout = bl.struct([size, elements], property);
    }
    encode(src, b, offset = 0) {
        if (src === null || src === undefined || src.length === 0) {
            return bl.u8().encode(0, b, offset);
        }
        return this.layout.encode({ size: src.length, elements: Array.from(src) }, b, offset);
    }
    decode(b, offset = 0) {
        const decoded = this.layout.decode(b, offset);
        if (decoded.size === 0)
            return Buffer.from([]);
        return Buffer.from(decoded.elements);
    }
    getSpan(b, offset = 0) {
        if (!b)
            return 0;
        return b[offset] + 1;
    }
}
export class Order {
    static initLayout() {
        const extCall = new Optional(bl.struct([bl.blob(32, "externalCallHash")]), "extCall");
        return bl.struct([
            blu.u64be("nonce"),
            new U8Vec("makerSrcAddress"),
            blu.u256be("giveChainId"),
            new U8Vec("giveTokenAddress"),
            blu.u256be("giveAmount"),
            blu.u256be("takeChainId"),
            new U8Vec("takeTokenAddress"),
            blu.u256be("takeAmount"),
            new U8Vec("receiverDstAddress"),
            new U8Vec("givePatchAuthorityAddress"),
            new U8Vec("orderAuthorityDstAddress"),
            new U8Vec("allowedTakerDstAddress"),
            new U8Vec("allowedCancelBeneficiaryAddress"),
            extCall,
        ]);
    }
    static orderDataToOrderLayout(data) {
        let extCall = null;
        if (data.externalCall) {
            extCall = {
                externalCallHash: data.externalCall.externalCallHash ??
                    helpers.hexToBuffer(`0x${keccak256(data.externalCall?.externalCallData)}`),
            };
        }
        return {
            nonce: data.nonce,
            giveAmount: data.give.amount,
            giveChainId: BigInt(data.give.chainId),
            giveTokenAddress: data.give.tokenAddress,
            takeAmount: data.take.amount,
            takeChainId: BigInt(data.take.chainId),
            takeTokenAddress: data.take.tokenAddress,
            makerSrcAddress: data.maker,
            receiverDstAddress: data.receiver,
            givePatchAuthorityAddress: data.givePatchAuthority,
            orderAuthorityDstAddress: data.orderAuthorityDstAddress,
            allowedTakerDstAddress: data.allowedTaker || null,
            allowedCancelBeneficiaryAddress: data.allowedCancelBeneficiary || null,
            extCall,
        };
    }
    static serialize(data) {
        const orderLayout = Order.orderDataToOrderLayout(data);
        const buffer = Buffer.alloc(1000);
        const layout = Order.initLayout();
        const encoded = layout.encode(orderLayout, buffer, 0);
        return Buffer.from(buffer.subarray(0, encoded));
    }
    static deserialize(data, omitCalldata = true) {
        const layout = Order.initLayout();
        const decoded = layout.decode(data);
        return {
            nonce: decoded.nonce,
            give: {
                amount: decoded.giveAmount,
                chainId: Number(decoded.giveChainId),
                tokenAddress: decoded.giveTokenAddress,
            },
            take: {
                amount: decoded.takeAmount,
                chainId: Number(decoded.takeChainId),
                tokenAddress: decoded.takeTokenAddress,
            },
            givePatchAuthority: decoded.givePatchAuthorityAddress,
            maker: decoded.makerSrcAddress,
            orderAuthorityDstAddress: decoded.orderAuthorityDstAddress,
            receiver: decoded.receiverDstAddress,
            allowedCancelBeneficiary: decoded.allowedCancelBeneficiaryAddress || undefined,
            allowedTaker: decoded.allowedTakerDstAddress || undefined,
            externalCall: decoded.extCall
                ? {
                    externalCallHash: Uint8Array.from(decoded.extCall.externalCallHash),
                    externalCallData: Uint8Array.from(decoded.extCall.externalCallHash),
                }
                : undefined,
        };
    }
    static getExternalCallHash(data) {
        if (data.externalCallHash)
            return data.externalCallHash;
        return helpers.hexToBuffer(`0x${keccak256(data.externalCallData)}`);
    }
    static calculateId(order) {
        const serialized = Order.serialize(order);
        // logger.debug(serialized.toString("hex"));
        return `0x${keccak256(serialized)}`;
    }
    static verify(order) {
        return Order.calculateId(order) === helpers.bufferToHex(order.orderId);
    }
    static buildOrderDataWithId(order) {
        const orderId = this.calculateId(order);
        return {
            ...order,
            orderId: helpers.hexToBuffer(orderId),
        };
    }
    /**
     * Verifies order if order id is present else builds OrderDataWithId.
     * If order id is present but verification fails throws `ClientErrorType.WrongOrderId`
     * @param order order data with or without orderId
     * @returns
     */
    static getVerified(order) {
        if ("orderId" in order) {
            if (this.verify(order)) {
                return order;
            }
            throw new ClientError(ClientErrorType.WrongOrderId);
        }
        else {
            return this.buildOrderDataWithId(order);
        }
    }
}
export class PartialOrder {
}
PartialOrder.decimals = 1e6;
//# sourceMappingURL=order.js.map
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.calcBigIntAmountViaCrossRate = exports.formatAmount = exports.fixDecimals = exports.calcAmountViaCrossRate = exports.getNativeToken = exports.buffersAreEqual = exports.tokenStringToBuffer = exports.tokenAddressToString = exports.TransactionFee = exports.ATASize = void 0;
const tslib_1 = require("tslib");
const buffer_1 = require("buffer");
const solana_utils_1 = require("@debridge-finance/solana-utils");
const web3_js_1 = require("@solana/web3.js");
const bignumber_js_1 = tslib_1.__importDefault(require("bignumber.js"));
const common_types_1 = require("./common.types");
// TODO: move to @debridge-finance/solana-utils
exports.ATASize = 165;
exports.TransactionFee = 5000;
/**
 * Lambda for quick convertation of Address into string. At the moment supports only evm and solana.
 * It's better to call `clientImplementation.fromAddress(chain, token).toString()`
 * @returns stringified address
 */
const tokenAddressToString = (chain, address) => {
    let result;
    switch (chain) {
        case common_types_1.ChainId.Solana:
            result = new web3_js_1.PublicKey(address).toString();
            break;
        default:
            result = solana_utils_1.helpers.bufferToHex(buffer_1.Buffer.from(address));
    }
    return result;
};
exports.tokenAddressToString = tokenAddressToString;
/**
 * Lambda for quick convertation of Address into string. At the moment supports only evm and solana.
 * It's better to call `clientImplementation.parseAddress(chain, token)`
 * @returns parsed address
 */
const tokenStringToBuffer = (chain, address) => {
    let result;
    switch (chain) {
        case common_types_1.ChainId.Solana:
            if (address.startsWith("0x")) {
                result = solana_utils_1.helpers.hexToBuffer(address);
            }
            else {
                result = new web3_js_1.PublicKey(address).toBytes();
            }
            break;
        default:
            result = solana_utils_1.helpers.hexToBuffer(address);
    }
    return result;
};
exports.tokenStringToBuffer = tokenStringToBuffer;
/**
 * Helper for buffers comparison
 */
const buffersAreEqual = (a, b) => buffer_1.Buffer.compare(buffer_1.Buffer.from(a), buffer_1.Buffer.from(b)) === 0;
exports.buffersAreEqual = buffersAreEqual;
/**
 * Lambda for to get native token for specific chain. Could be used when clientImplementation is unavailable.
 * Better way to retrieve native token address is to read `clientImplementation.nativeAddress` field
 */
const getNativeToken = (chainId) => {
    if (chainId === common_types_1.ChainId.Solana) {
        return (0, exports.tokenStringToBuffer)(chainId, common_types_1.ZERO_SOLANA_ADDRESS);
    }
    else {
        return (0, exports.tokenStringToBuffer)(chainId, common_types_1.ZERO_EVM_ADDRESS);
    }
};
exports.getNativeToken = getNativeToken;
/**
 * @internal
 * @deprecated, use {@link calcBigIntAmountViaCrossRate}
 * Converts the amount of inToken to outToken using the given exchange rates
 */
const calcAmountViaCrossRate = (inAmount, inTokenExchangeRate, inTokenDecimals, outTokenExchangeRate, outTokenDecimals, payload) => {
    const inAmountIntermediaryValue = inAmount
        .multipliedBy(inTokenExchangeRate)
        .div(new bignumber_js_1.default(10).pow(inTokenDecimals));
    const outAmount = inAmountIntermediaryValue
        .multipliedBy(new bignumber_js_1.default(10).pow(outTokenDecimals))
        .div(outTokenExchangeRate);
    return outAmount;
};
exports.calcAmountViaCrossRate = calcAmountViaCrossRate;
/**
 * @internal
 */
function fixDecimals(amount, decimalsIn, decimalsOut) {
    if (decimalsIn === decimalsOut)
        return amount;
    const delta = decimalsIn - decimalsOut;
    if (delta > 0) {
        return amount / 10n ** BigInt(delta);
    }
    else {
        return amount * 10n ** BigInt(-delta);
    }
}
exports.fixDecimals = fixDecimals;
function formatAmount(amount, decimals) {
    const amountString = amount.toString();
    const length = amountString.length;
    const decimalIndex = length - decimals;
    if (decimals <= 0) {
        return amountString;
    }
    else if (decimalIndex <= 0) {
        const leadingZeros = "0".repeat(Math.abs(decimalIndex));
        return `0.${leadingZeros}${amountString}`;
    }
    else {
        const integerPart = amountString.slice(0, decimalIndex);
        const decimalPart = amountString.slice(decimalIndex).padStart(decimals, "0");
        return `${integerPart}.${decimalPart}`;
    }
}
exports.formatAmount = formatAmount;
/**
 * @internal
 */
const calcBigIntAmountViaCrossRate = (inAmount, inTokenExchangeRate, inTokenDecimals, outTokenExchangeRate, outTokenDecimals) => {
    const rateDecimalsFixer = 1e6;
    const exchangeRatio = BigInt(Math.ceil((inTokenExchangeRate * rateDecimalsFixer) / outTokenExchangeRate));
    const amount = (inAmount * exchangeRatio) / BigInt(rateDecimalsFixer);
    return fixDecimals(amount, inTokenDecimals, outTokenDecimals);
};
exports.calcBigIntAmountViaCrossRate = calcBigIntAmountViaCrossRate;
//# sourceMappingURL=utils.js.map
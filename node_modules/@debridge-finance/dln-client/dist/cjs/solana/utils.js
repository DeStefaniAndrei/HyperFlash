"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.prepareV0Transaction = exports.getALTs = exports.createATA = exports.verifyALT = exports.extendALT = exports.prepareALT = exports.parseALT = exports.getTokenInfo = exports.getSolanaDecimals = exports.findALT = exports.solanaOrderToOrderData = exports.orderDataToAnchorFormat = exports.bigintToArray = exports.bigintToBN = exports.getMinimumBalanceForRentExemption = exports.getAccountInfoCached = void 0;
const buffer_1 = require("buffer");
const buffer_layout_1 = require("@solana/buffer-layout");
const solana_utils_1 = require("@debridge-finance/solana-utils");
const anchor_1 = require("@coral-xyz/anchor");
const web3_js_1 = require("@solana/web3.js");
const logger_1 = require("../common/logger");
const order_1 = require("../order");
const CACHE = new Map();
async function getAccountInfoCached(connection, acc) {
    const key = `acc_${acc.toBase58()}`;
    const entry = CACHE.get(key);
    if (entry && entry !== null) {
        return entry;
    }
    else {
        const resp = await connection.getAccountInfo(acc);
        CACHE.set(key, resp);
        return resp;
    }
}
exports.getAccountInfoCached = getAccountInfoCached;
function decodeRentSysvar(rent) {
    const rentStruct = (0, buffer_layout_1.struct)([(0, buffer_layout_1.nu64)("lamportsPerByteYear"), (0, buffer_layout_1.f64)("exemptionThreshold"), (0, buffer_layout_1.u8)("burnPercent")]);
    return rentStruct.decode(rent.data);
}
async function getMinimumBalanceForRentExemption(connection, size) {
    const rentAccount = await connection.getAccountInfo(web3_js_1.SYSVAR_RENT_PUBKEY);
    const BASE = 890880;
    if (!rentAccount)
        throw new Error(`Failed to fetch rent account`);
    const decodedRent = decodeRentSysvar(rentAccount);
    // rent = base + bytesCount * (2 years * lamportsPerYear)
    return BASE + decodedRent.lamportsPerByteYear * size * decodedRent.exemptionThreshold;
}
exports.getMinimumBalanceForRentExemption = getMinimumBalanceForRentExemption;
function bigintToBN(n) {
    return new anchor_1.BN(n.toString());
}
exports.bigintToBN = bigintToBN;
function bigintToArray(n, type) {
    let size;
    switch (type) {
        case "u256":
            size = 32;
            break;
        case "u64":
            size = 8;
            break;
    }
    return new anchor_1.BN(n.toString()).toArray("be", size);
}
exports.bigintToArray = bigintToArray;
function orderDataToAnchorFormat(order) {
    return {
        makerOrderNonce: bigintToBN(order.nonce),
        makerSrc: buffer_1.Buffer.from(order.maker),
        give: {
            amount: bigintToArray(order.give.amount, "u256"),
            chainId: bigintToArray(order.give.chainId, "u256"),
            tokenAddress: buffer_1.Buffer.from(order.give.tokenAddress),
        },
        take: {
            amount: bigintToArray(order.take.amount, "u256"),
            chainId: bigintToArray(order.take.chainId, "u256"),
            tokenAddress: buffer_1.Buffer.from(order.take.tokenAddress),
        },
        receiverDst: buffer_1.Buffer.from(order.receiver),
        givePatchAuthoritySrc: buffer_1.Buffer.from(order.givePatchAuthority),
        orderAuthorityAddressDst: buffer_1.Buffer.from(order.orderAuthorityDstAddress),
        allowedTakerDst: order.allowedTaker ? buffer_1.Buffer.from(order.allowedTaker) : null,
        allowedCancelBeneficiarySrc: order.allowedCancelBeneficiary ? buffer_1.Buffer.from(order.allowedCancelBeneficiary) : null,
        externalCall: order.externalCall === undefined
            ? null
            : {
                externalCallShortcut: Array.from(order_1.Order.getExternalCallHash(order.externalCall)),
            },
    };
}
exports.orderDataToAnchorFormat = orderDataToAnchorFormat;
function numToBigint(num) {
    return BigInt(new anchor_1.BN(num).toString());
}
function solanaOrderToOrderData(order) {
    return {
        give: {
            amount: numToBigint(order.give.amount),
            chainId: Number(numToBigint(order.give.chainId)),
            tokenAddress: Uint8Array.from(order.give.tokenAddress),
        },
        take: {
            amount: numToBigint(order.take.amount),
            chainId: Number(numToBigint(order.take.chainId)),
            tokenAddress: Uint8Array.from(order.take.tokenAddress),
        },
        givePatchAuthority: Uint8Array.from(order.givePatchAuthoritySrc),
        maker: Uint8Array.from(order.makerSrc),
        nonce: BigInt(order.makerOrderNonce.toString()),
        orderAuthorityDstAddress: Uint8Array.from(order.orderAuthorityAddressDst),
        receiver: Uint8Array.from(order.receiverDst),
        allowedCancelBeneficiary: order.allowedCancelBeneficiarySrc
            ? Uint8Array.from(order.allowedCancelBeneficiarySrc)
            : undefined,
        allowedTaker: order.allowedTakerDst ? Uint8Array.from(order.allowedTakerDst) : undefined,
        externalCall: order.externalCall
            ? {
                externalCallHash: Uint8Array.from(order.externalCall.externalCallShortcut),
                // TODO
                externalCallData: new Uint8Array(),
            }
            : undefined,
    };
}
exports.solanaOrderToOrderData = solanaOrderToOrderData;
async function findALT(connection, pattern) {
    const encoded = anchor_1.utils.bytes.bs58.encode(buffer_1.Buffer.from(pattern));
    const tableStartOffset = 0x38;
    const [active] = await Promise.all([
        connection.getProgramAccounts(web3_js_1.AddressLookupTableProgram.programId, {
            filters: [{ memcmp: { offset: tableStartOffset, bytes: encoded } }], // active not frozen
        }),
    ]);
    return active;
}
exports.findALT = findALT;
async function getSolanaDecimals(connection, tokenAddress) {
    const tokenMint = new web3_js_1.PublicKey(tokenAddress.startsWith("0x") ? solana_utils_1.helpers.hexToBuffer(tokenAddress) : tokenAddress);
    // native sol
    if (tokenMint.toBase58() === "1".repeat(32) || tokenMint.equals(solana_utils_1.WRAPPED_SOL_MINT))
        return 9;
    const mintAccountData = await connection.getParsedAccountInfo(tokenMint);
    if (!mintAccountData || !mintAccountData?.value?.data?.parsed?.info)
        throw new Error("failed to get token mint info");
    const parsedData = (mintAccountData.value?.data).parsed;
    return parsedData.info.decimals;
}
exports.getSolanaDecimals = getSolanaDecimals;
async function getTokenInfo(connection, tokenAddress) {
    if (tokenAddress.toBase58() === "1".repeat(32)) {
        return {
            name: "Native SOL",
            symbol: "SOL",
        };
    }
    try {
        const result = await solana_utils_1.spl.getTokenInfo(connection, tokenAddress);
        if (result === null)
            throw new Error(`Failed to get info for token: ${tokenAddress.toBase58()}`);
        return {
            name: result.name,
            symbol: result.symbol,
        };
    }
    catch (e) {
        // TODO: monitoring
        const l = new logger_1.Logger();
        l.error(e);
        return {
            name: "-",
            symbol: "-",
        };
    }
}
exports.getTokenInfo = getTokenInfo;
function parseALT(message, alts) {
    const altMap = new Map(alts.map((alt) => [alt.key.toBase58(), alt]));
    const writable = [];
    const readonly = [];
    for (const msgALTref of message.addressTableLookups) {
        const altData = altMap.get(msgALTref.accountKey.toBase58());
        if (!altData)
            continue;
        // get writable
        msgALTref.writableIndexes.map((wIdx) => writable.push(altData.state.addresses[wIdx]));
        msgALTref.readonlyIndexes.map((roIdx) => readonly.push(altData.state.addresses[roIdx]));
    }
    return { writable, readonly };
}
exports.parseALT = parseALT;
function prepareALT(slot, payer, addresses) {
    const [lookupTableInst, lookupTableAddress] = web3_js_1.AddressLookupTableProgram.createLookupTable({
        authority: payer,
        payer,
        recentSlot: slot,
    });
    const ACCOUNTS_CHUNK_SIZE = 25;
    const txs = [
        new web3_js_1.Transaction({ feePayer: payer }).add(lookupTableInst).add(web3_js_1.AddressLookupTableProgram.extendLookupTable({
            payer,
            authority: payer,
            lookupTable: lookupTableAddress,
            addresses: addresses.slice(0, ACCOUNTS_CHUNK_SIZE),
        })),
    ];
    for (let i = ACCOUNTS_CHUNK_SIZE; i < addresses.length; i += ACCOUNTS_CHUNK_SIZE) {
        txs.push(new web3_js_1.Transaction({ feePayer: payer }).add(web3_js_1.AddressLookupTableProgram.extendLookupTable({
            payer,
            authority: payer,
            lookupTable: lookupTableAddress,
            addresses: addresses.slice(i, i + ACCOUNTS_CHUNK_SIZE),
        })));
    }
    return [lookupTableAddress, txs];
}
exports.prepareALT = prepareALT;
function extendALT(lookupTableAddress, payer, addresses) {
    const extendInstruction = web3_js_1.AddressLookupTableProgram.extendLookupTable({
        payer: payer,
        authority: payer,
        lookupTable: lookupTableAddress,
        addresses,
    });
    return extendInstruction;
}
exports.extendALT = extendALT;
/**
 *
 * @param alt
 * @param expectedAddresses
 * @returns false if ALT is broken
 */
function verifyALT(alt, expectedAddresses) {
    if (!alt || !alt.isActive())
        return false;
    // some bug with PublicKey[] includes, 0 element couldnt be found
    const stateAccounts = alt.state.addresses.map((addr) => addr.toBase58());
    const missing = [];
    for (const expected of expectedAddresses) {
        if (!stateAccounts.includes(expected.toBase58())) {
            missing.push(expected.toBase58());
            // TODO: add logger with context (#65)
            // console.log(`Missing ${expected.toBase58()} in ${stateAccounts.join(",")}`);
        }
    }
    if (missing.length < 15) {
        console.log(`Missing: ${missing.length}`, missing, expectedAddresses.length, stateAccounts.length);
    }
    return missing.length === 0;
}
exports.verifyALT = verifyALT;
function createATA(tokenMint, owner, payer, associatedTokenProgram) {
    return new web3_js_1.TransactionInstruction({
        programId: associatedTokenProgram || solana_utils_1.ASSOCIATED_TOKEN_PROGRAM_ID,
        keys: [
            {
                pubkey: payer,
                isSigner: true,
                isWritable: true,
            },
            {
                pubkey: (0, solana_utils_1.findAssociatedTokenAddress)(owner, tokenMint)[0],
                isSigner: false,
                isWritable: true,
            },
            {
                pubkey: owner,
                isSigner: false,
                isWritable: false,
            },
            {
                pubkey: tokenMint,
                isSigner: false,
                isWritable: false,
            },
            {
                pubkey: web3_js_1.SystemProgram.programId,
                isSigner: false,
                isWritable: false,
            },
            {
                pubkey: solana_utils_1.TOKEN_PROGRAM_ID,
                isSigner: false,
                isWritable: false,
            },
        ],
        data: buffer_1.Buffer.from([0]),
    });
}
exports.createATA = createATA;
/**
 * Shared map for all juipter instances
 */
const fetchedALTMap = new Map();
async function getALTs(connection, altKeys) {
    const stringifiedKeys = altKeys.map((k) => k.toBase58());
    const altsToFetch = [];
    const result = [];
    for (const [idx, stringifiedKey] of stringifiedKeys.entries()) {
        const cacheEntry = fetchedALTMap.get(stringifiedKey);
        if (cacheEntry) {
            result.push(cacheEntry);
        }
        else {
            altsToFetch.push(altKeys[idx]);
        }
    }
    if (altsToFetch.length > 0) {
        const fetchedALTs = await connection.getMultipleAccountsInfo(altsToFetch);
        const parsedALTs = fetchedALTs
            .map((fetched, i) => fetched
            ? new web3_js_1.AddressLookupTableAccount({
                state: web3_js_1.AddressLookupTableAccount.deserialize(fetched.data),
                key: altsToFetch[i],
            })
            : null)
            .filter((x) => x != null);
        for (const parsedALT of parsedALTs) {
            fetchedALTMap.set(parsedALT.key.toBase58(), parsedALT);
        }
        result.push(...parsedALTs);
    }
    return result;
}
exports.getALTs = getALTs;
async function prepareV0Transaction(connection, payer, instructions, addressLookupTables) {
    const toFetch = [];
    const provided = [];
    for (const maybeParsed of addressLookupTables ?? []) {
        if ("state" in maybeParsed && "key" in maybeParsed) {
            provided.push(maybeParsed);
        }
        else {
            toFetch.push(maybeParsed);
        }
    }
    const fetched = await getALTs(connection, toFetch);
    const ALTs = [...provided, ...fetched].filter((alt) => alt !== null);
    return {
        instructions,
        ALTs,
        payer,
    };
}
exports.prepareV0Transaction = prepareV0Transaction;
//# sourceMappingURL=utils.js.map
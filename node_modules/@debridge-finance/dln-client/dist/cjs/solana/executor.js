"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Executor = exports.ExecutionState = exports.findExtcallWalletAddress = exports.findExtcallAuthAddress = exports.findExtcallStorageAddress = exports.findExtcallMetaAddress = exports.findExtcallStateAddress = void 0;
const tslib_1 = require("tslib");
const anchor_1 = require("@coral-xyz/anchor");
const web3_js_1 = require("@solana/web3.js");
const wasm = tslib_1.__importStar(require("@debridge-finance/debridge-external-call"));
const solana_utils_1 = require("@debridge-finance/solana-utils");
const solana_utils_2 = require("@debridge-finance/solana-utils");
const solana_contracts_client_1 = require("@debridge-finance/solana-contracts-client");
const logger_1 = require("../common/logger");
const executor_1 = require("./idl/executor");
const ACCOUNT_DISCRIMINATOR_SIZE = 8;
const findExtcallStateAddress = (extcallProgram) => web3_js_1.PublicKey.findProgramAddressSync([Buffer.from("STATE", "utf-8")], extcallProgram)[0];
exports.findExtcallStateAddress = findExtcallStateAddress;
const findExtcallMetaAddress = (extcallProgram, id) => web3_js_1.PublicKey.findProgramAddressSync([Buffer.from("META", "utf-8"), id], new web3_js_1.PublicKey(extcallProgram))[0];
exports.findExtcallMetaAddress = findExtcallMetaAddress;
const findExtcallStorageAddress = (extcallProgram, id, owner) => web3_js_1.PublicKey.findProgramAddressSync([Buffer.from("STORAGE", "utf-8"), id, owner.toBuffer()], new web3_js_1.PublicKey(extcallProgram))[0];
exports.findExtcallStorageAddress = findExtcallStorageAddress;
const findExtcallAuthAddress = (extcallProgram, id) => web3_js_1.PublicKey.findProgramAddressSync([Buffer.from("AUTH", "utf-8"), id], new web3_js_1.PublicKey(extcallProgram))[0];
exports.findExtcallAuthAddress = findExtcallAuthAddress;
const findExtcallWalletAddress = (extcallProgram, id, isNative) => isNative
    ? (0, exports.findExtcallAuthAddress)(extcallProgram, id)
    : web3_js_1.PublicKey.findProgramAddressSync([Buffer.from("WALLET", "utf-8"), id], extcallProgram)[0];
exports.findExtcallWalletAddress = findExtcallWalletAddress;
var ExecutionState;
(function (ExecutionState) {
    ExecutionState["Executed"] = "Executed";
    ExecutionState["Execution"] = "Execution";
    ExecutionState["Failed"] = "Failed";
    ExecutionState["Fallbacked"] = "Fallbacked";
    ExecutionState["Initializing"] = "Initializing";
})(ExecutionState || (exports.ExecutionState = ExecutionState = {}));
const CHUNK_SIZE = 850;
const STORAGE_OFFSET = ACCOUNT_DISCRIMINATOR_SIZE + 9; // discriminator (8) + u64 (8) + bool (1)
function ixToIExtIx(ix) {
    return {
        keys: ix.keys.map((meta) => ({
            pubkey: meta.pubkey.toBase58(),
            isSigner: meta.isSigner,
            isWritable: meta.isWritable,
        })),
        programId: ix.programId.toBase58(),
        data: ix.data,
    };
}
function bufferChunks(data, chunkSize) {
    let offset = 0;
    const chunks = [];
    while (offset < data.length) {
        chunks.push([offset, data.subarray(offset, offset + chunkSize)]);
        offset += chunkSize;
    }
    return chunks;
}
class Executor {
    constructor(programId, connection) {
        this.program = new anchor_1.Program(executor_1.IDL, programId, new anchor_1.AnchorProvider(connection, {}, {}));
    }
    /**
     * @deprecated use `extCallDataToInstructions` from solana-contracts-client
     * @param calldata
     * @param offset
     * @returns
     */
    static deserializeCalldata(calldata, offset = 0) {
        return (0, solana_contracts_client_1.extCallDataToInstructions)(calldata, offset);
    }
    isNative(tokenMint) {
        return tokenMint.toBase58() === Executor.nativeAddress;
    }
    /**
     *
     * @param takeTokenAddress
     * @param solPrice in usd
     * @param takeTokenPrice in usd
     * @param takeTokenDecimals
     * @param calldata
     * @param profitabilityMultiplier value in range 0..1, rewards will be equal (multiplier+1)*expensesInTakeToken
     * @returns
     */
    static setExecutionFeeRewards(takeTokenAddress, solPrice, takeTokenPrice, takeTokenDecimals, calldata, profitabilityMultiplier = 0.2) {
        const takeTokenStr = new web3_js_1.PublicKey(takeTokenAddress).toBase58();
        if (takeTokenStr === Executor.nativeAddress || takeTokenStr === solana_utils_1.WRAPPED_SOL_MINT.toBase58()) {
            takeTokenPrice = 1;
            solPrice = 1;
        }
        const wasmInput = new wasm.CostCalculationInput(takeTokenAddress.length, false, 10, 3480n, 2, 5000n, solPrice, takeTokenPrice, takeTokenDecimals, true, true, profitabilityMultiplier, BigInt(calldata.length));
        const result = wasmInput.calculate_recomended_reward_for_external_call(calldata);
        wasmInput.free();
        return result;
    }
    async getStorageData(orderId, executor) {
        const storageAddress = (0, exports.findExtcallStorageAddress)(this.program.programId, orderId, executor);
        const storageData = await this.program.provider.connection.getAccountInfo(storageAddress);
        if (storageData === null || storageData.lamports === 0) {
            return null;
        }
        return storageData.data;
    }
    initExtCallStorage(extcallId, calldata, owner, chunkSize = CHUNK_SIZE) {
        const builders = [];
        const extcallStorage = (0, exports.findExtcallStorageAddress)(this.program.programId, extcallId, owner);
        for (const [offset, chunk] of bufferChunks(Buffer.from(calldata), chunkSize)) {
            const builder = this.program.methods.fillExtcallStorage(Array.from(extcallId), new anchor_1.BN(calldata.length), new anchor_1.BN(offset), chunk);
            builder.accountsStrict({ systemProgram: web3_js_1.SystemProgram.programId, owner, extcallStorage });
            builders.push(builder);
        }
        return Promise.all(builders.map(async (b) => {
            const ix = await b.instruction();
            const result = {
                instructions: [ix],
                payer: owner,
            };
            return result;
        }));
    }
    /**
     * Transforms solana's TransactionInstruction into serialized format executable by debridge calldata executor
     * @param instruction
     * @param substitutions object that allows to substitute amount at offset/wallet at index
     * @param expense cost of ix execution, before execution this amount (of native SOL) will be transferred to submissionAuthority wallet and will be used to pay for actions in solana (usually rent)
     * @param reward this amount will be deducted from balance of submissionWallet, meant to cover expense
     * @param isInMandatoryBlock is this instruction should be executed in the same transaction as other sequental instructions with this flag?
     * @returns serialized calldata
     */
    static serializeExternalInstruction(instruction, substitutions, expense, reward, zeroRentAlreadyIncluded = false, isInMandatoryBlock = false) {
        const ZERO_ACCOUNT_RENT = 890880n;
        const ixWrapper = new wasm.ExternalInstructionWrapper(reward, expense !== undefined ? expense + (zeroRentAlreadyIncluded ? 0n : ZERO_ACCOUNT_RENT) : undefined, isInMandatoryBlock, substitutions?.amountSubstitutions ?? [], substitutions?.walletSubstitutions ?? [], ixToIExtIx(instruction));
        // IDK why, but that line emits 0 pointer passed to the wasm module
        // ixWrapper.free();
        return ixWrapper.serialize();
    }
    convertExtcallState(raw) {
        if (raw.state.executed) {
            return {
                state: ExecutionState.Executed,
                buffer: raw.state.executed.buffer,
            };
        }
        else if (raw.state.execution) {
            return {
                state: ExecutionState.Execution,
                executedInstructionsCount: raw.state.execution.executedInstructionsCount.toNumber(),
                offset: raw.state.execution.offset.toNumber(),
            };
        }
        else if (raw.state.failed) {
            return {
                state: ExecutionState.Failed,
                buffer: raw.state.failed.buffer,
            };
        }
        else if (raw.state.fallbacked) {
            return {
                state: ExecutionState.Fallbacked,
            };
        }
        else if (raw.state.initializing) {
            return {
                state: ExecutionState.Initializing,
            };
        }
        else {
            throw new Error("Unknown extcall meta state");
        }
    }
    normalizeExtcallMeta(data) {
        return {
            ...this.convertExtcallState(data),
            authority: data.providedAuthority,
            amount: BigInt(data.providedAmount.toString()),
            flow: data.providedToken.nativeSol ? "native" : "spl",
        };
    }
    async buildFallbackIx(extcallId, fallbackAuthority, tokenMint) {
        const builder = this.program.methods.makeFallback(Array.from(extcallId));
        const isNative = this.isNative(tokenMint);
        const fallbackWallet = isNative ? fallbackAuthority : (0, solana_utils_1.findAssociatedTokenAddress)(fallbackAuthority, tokenMint)[0];
        const instructions = [];
        if (!isNative) {
            instructions.push(solana_utils_2.spl.createAssociatedWalletInstruction(tokenMint, fallbackWallet, fallbackAuthority, fallbackAuthority));
        }
        builder.accountsStrict({
            systemProgram: web3_js_1.SystemProgram.programId,
            splTokenProgram: solana_utils_1.TOKEN_PROGRAM_ID,
            extcallMeta: (0, exports.findExtcallMetaAddress)(this.program.programId, extcallId),
            executeAuth: (0, exports.findExtcallAuthAddress)(this.program.programId, extcallId),
            executeWallet: (0, exports.findExtcallWalletAddress)(this.program.programId, extcallId, isNative),
            fallbackAuthority,
            fallbackWallet,
        });
        instructions.push(await builder.instruction());
        return { instructions, payer: fallbackAuthority };
    }
    async buildExecuteExternalCallIx(extcallId, calldata, offset, count, accounts) {
        const context = wasm.get_external_call_account_meta(calldata, offset, calldata.length, count, accounts.extcallMeta.toBase58(), accounts.executeAuth.toBase58(), accounts.executeWallet.toBase58());
        const subsitutionBumps = context.reversed_subsitution_bumps();
        const remainingAccounts = context.remaning_accounts().map((item) => {
            const pk = new web3_js_1.PublicKey(item.pubkey);
            return {
                isSigner: item.is_signer,
                isWritable: item.is_writable,
                pubkey: pk,
            };
        });
        context.free();
        const builder = this.program.methods.executeExtcall(Array.from(extcallId), new anchor_1.BN(count), Buffer.from(subsitutionBumps));
        builder.accountsStrict({
            ...accounts,
            splTokenProgram: solana_utils_1.TOKEN_PROGRAM_ID,
            systemProgram: web3_js_1.SystemProgram.programId,
        });
        builder.remainingAccounts(remainingAccounts);
        return builder.instruction();
    }
    async getExternalCallMeta(extcallId) {
        const address = (0, exports.findExtcallMetaAddress)(this.program.programId, extcallId);
        const fetched = this.program.account.extcallMeta.fetchNullable(address);
        return fetched;
    }
    async buildOptimalExecuteExternalCallTransaction(extcallId, executor, tokenMint) {
        const logger = new logger_1.Logger();
        const accounts = {
            extcallMeta: (0, exports.findExtcallMetaAddress)(this.program.programId, extcallId),
            extcallStorage: (0, exports.findExtcallStorageAddress)(this.program.programId, extcallId, executor),
            executeAuth: (0, exports.findExtcallAuthAddress)(this.program.programId, extcallId),
            executeWallet: (0, exports.findExtcallWalletAddress)(this.program.programId, extcallId, this.isNative(tokenMint)),
            executor,
        };
        const [rawStorage, rawMeta] = await this.program.provider.connection.getMultipleAccountsInfo([
            accounts.extcallStorage,
            accounts.extcallMeta,
        ]);
        if (rawMeta === null)
            throw new Error("Failed to get ext call meta");
        if (rawStorage === null)
            throw new Error("Failed to get ext call storage");
        const parsedMeta = this.normalizeExtcallMeta(this.program.coder.accounts.decode("extcallMeta", rawMeta.data));
        let rewardDst;
        if (parsedMeta.flow === "native") {
            rewardDst = executor;
            accounts.executeWallet = accounts.executeAuth;
        }
        else {
            rewardDst = (0, solana_utils_1.findAssociatedTokenAddress)(executor, tokenMint)[0];
        }
        let offset = STORAGE_OFFSET;
        if (parsedMeta.state in [ExecutionState.Executed, ExecutionState.Failed, ExecutionState.Fallbacked]) {
            throw new Error(`Can't execute submission with state: ${JSON.stringify(parsedMeta.state)}`);
        }
        else if (parsedMeta.state === ExecutionState.Execution) {
            offset = parsedMeta.offset;
        }
        const calldata = rawStorage.data;
        let execIx = null;
        let vtx = null;
        let optimalCountMin = 0;
        let optimalCountMax = (0, solana_contracts_client_1.extCallDataToInstructions)(calldata, offset).length + 1;
        let middle = 0;
        let err = null;
        while (optimalCountMax - optimalCountMin > 1) {
            middle = Math.floor((optimalCountMin + optimalCountMax) / 2);
            logger.verbose(`Current min: ${optimalCountMin}, max: ${optimalCountMax}, middle: ${middle}`);
            try {
                execIx = await this.buildExecuteExternalCallIx(extcallId, calldata, offset, middle, { ...accounts, rewardDst });
                vtx = new web3_js_1.VersionedTransaction(web3_js_1.MessageV0.compile({
                    instructions: [execIx],
                    payerKey: executor,
                    recentBlockhash: solana_utils_1.constants.FAKE_BLOCKHASH,
                    addressLookupTableAccounts: [],
                }));
                if ((solana_utils_1.txs.getTransactionSize(vtx) ?? 1250) > 1232) {
                    err = "tx too big";
                }
                else {
                    //console.log(Buffer.from(vtx.serialize()).toString("base64"));
                    const simulation = await this.program.provider.connection.simulateTransaction(vtx, {
                        replaceRecentBlockhash: true,
                    });
                    logger.verbose(simulation.value.err);
                    err = simulation.value.err;
                }
                if (err === null) {
                    optimalCountMin = middle;
                }
                else {
                    optimalCountMax = middle;
                }
            }
            catch (e) {
                logger.verbose(e);
                optimalCountMax = middle;
            }
        }
        let optimal = Math.floor((optimalCountMax + optimalCountMin) / 2);
        optimal = optimal === 0 ? 1 : optimal;
        logger.verbose(`Optimal count: ${optimal}`);
        execIx = await this.buildExecuteExternalCallIx(extcallId, calldata, offset, optimal, { ...accounts, rewardDst });
        return [
            {
                instructions: [execIx],
                payer: executor,
            },
            optimal,
        ];
    }
}
exports.Executor = Executor;
Executor.nativeAddress = "11111111111111111111111111111111";
//# sourceMappingURL=executor.js.map
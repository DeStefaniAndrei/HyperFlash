"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DLNSrc = void 0;
const buffer_1 = require("buffer");
const web3_js_1 = require("@solana/web3.js");
const anchor_1 = require("@coral-xyz/anchor");
const solana_utils_1 = require("@debridge-finance/solana-utils");
const solana_transaction_parser_1 = require("@debridge-finance/solana-transaction-parser");
const order_1 = require("../order");
const common_types_1 = require("../common.types");
const client_error_error_1 = require("../errors/client-error.error");
const client_error_type_enum_1 = require("../errors/client-error-type.enum");
const env_1 = require("../common/env");
const src_1 = require("./idl/src");
const hanoi_src_1 = require("./idl/hanoi_src");
const utils_1 = require("./utils");
const BPS_DENOMINATOR = BigInt(solana_utils_1.constants.BPS_DENOMINATOR);
class DLNSrc {
    constructor(programId, connection, logger, version = env_1.Env.Prod) {
        this.logger = logger;
        this.version = version;
        switch (version) {
            case env_1.Env.Lima:
            case env_1.Env.Madrid:
            case env_1.Env.Prod: {
                this.program = new anchor_1.Program(src_1.IDL, programId, new anchor_1.AnchorProvider(connection, {}, {}));
                break;
            }
            case env_1.Env.Hanoi: {
                this.program = new anchor_1.Program(hanoi_src_1.IDL, programId, new anchor_1.AnchorProvider(connection, {}, {}));
            }
        }
        this.accountsResolver = (0, solana_utils_1.dlnSrcResolver)(this.program.programId).methods;
        this.state = null;
    }
    setConnection(connection) {
        this.program = new anchor_1.Program(this.program.idl, this.program.programId, new anchor_1.AnchorProvider(connection, {}, {}));
    }
    async getOrderFromTransaction(txId) {
        const tx = await this.program.provider.connection.getTransaction(txId, {
            maxSupportedTransactionVersion: 0,
            commitment: "confirmed",
        });
        if (tx === null)
            throw new client_error_error_1.ClientError(client_error_type_enum_1.ClientErrorType.MissingTransaction);
        if ((tx.meta?.err ?? null) !== null)
            throw new client_error_error_1.ClientError(client_error_type_enum_1.ClientErrorType.FailedTransaction);
        let createdEventInfo = null;
        let orderId = null;
        for (const log of tx?.meta?.logMessages || []) {
            if (!log.startsWith("Program data: "))
                continue;
            const decoded = this.program.coder.events.decode(log.slice("Program data: ".length));
            if (decoded && decoded.name === "CreatedOrder")
                createdEventInfo = decoded.data;
            if (decoded && decoded.name === "CreatedOrderId")
                orderId = buffer_1.Buffer.from(decoded.data.orderId);
        }
        if (!orderId || !createdEventInfo)
            return null;
        const transferFee = BigInt(createdEventInfo.percentFee.toString());
        const fixFee = BigInt(createdEventInfo.fixFee.toString());
        const orderData = (0, utils_1.solanaOrderToOrderData)(createdEventInfo.order);
        const parser = new solana_transaction_parser_1.SolanaParser([{ idl: this.program.idl, programId: this.program.programId }]);
        let extCallData = undefined;
        const parsedTx = parser.parseTransactionData(tx?.transaction.message, tx?.meta?.loadedAddresses);
        let affiliateInfo = undefined;
        let referralCode = undefined;
        for (const parsedIx of parsedTx) {
            let continueParsingInstructions = true;
            if (parsedIx.programId.equals(this.program.programId)) {
                switch (parsedIx.name) {
                    case "createOrderWithNonce":
                    case "createOrder": {
                        const createOrderIx = parsedIx;
                        extCallData = createOrderIx.args.orderArgs?.externalCall;
                        referralCode = createOrderIx.args.referralCode;
                        if (createOrderIx.args.affiliateFee === null) {
                            affiliateInfo = undefined;
                        }
                        else {
                            const affiliateFeeAmount = BigInt(createOrderIx.args.affiliateFee.amount.toString());
                            affiliateInfo = {
                                beneficiary: createOrderIx.args.affiliateFee.beneficiary.toBuffer(),
                                amount: affiliateFeeAmount,
                            };
                        }
                        continueParsingInstructions = false;
                        break;
                    }
                }
            }
            if (!continueParsingInstructions)
                break;
        }
        return {
            ...orderData,
            externalCall: extCallData
                ? {
                    externalCallData: extCallData,
                }
                : undefined,
            orderId: orderId,
            transferFee,
            fixFee,
            referralCode,
            createTimestamp: tx.blockTime ?? undefined,
            affiliateInfo,
        };
    }
    async getState() {
        if (this.state) {
            return this.state;
        }
        const [stateAccount] = this.accountsResolver.getStateAccount();
        const state = await this.program.account.state.fetchNullable(stateAccount);
        if (state === null) {
            throw new client_error_error_1.ClientError(client_error_type_enum_1.ClientErrorType.SolanaNoSrcState);
        }
        this.state = state;
        return state;
    }
    async getFees(amount) {
        const state = await this.getState();
        const transferFeeBps = Number(state.percentFeeBps.toString());
        return {
            fixFee: BigInt(state.fixedFee.toString()),
            transferFee: amount ? (BigInt(transferFeeBps) * amount) / BPS_DENOMINATOR : BigInt(0),
            transferFeeBps,
        };
    }
    async getGiveOrderState(orderId, commitment = "finalized") {
        const [stateAcc] = this.accountsResolver.getGiveOrderStateAccount(typeof orderId === "string" ? solana_utils_1.helpers.hexToBuffer(orderId) : buffer_1.Buffer.from(orderId));
        const giveState = await this.program.account.giveOrderState.fetchNullable(stateAcc, commitment);
        if (!giveState)
            return null;
        if ("created" in giveState.status) {
            return {
                status: 1 /* OrderState.Created */,
                takeChainId: new anchor_1.BN(giveState.status.created.takeChainId).toNumber(),
                // fetched.status.created!.giveAmount can't be null
                giveAmount: BigInt(giveState.status.created.giveAmount.toString()),
            };
        }
        else if ("claimedCancel" in giveState.status) {
            return {
                status: 7 /* OrderState.ClaimedCancel */,
            };
        }
        else if ("claimedUnlock" in giveState.status) {
            return {
                status: 6 /* OrderState.ClaimedUnlock */,
            };
        }
        throw new client_error_error_1.ClientError(client_error_type_enum_1.ClientErrorType.UnknownStatus, `Unkown give status: ${JSON.stringify(giveState.status)}`);
    }
    async getCreateCost(ataRent, maker) {
        let dlnNonceAccountRent = 0;
        // cost = locker wallet creation + give order state creation
        let giveOrderStateSize = 211;
        // TODO remove after contract 3.0 release on prod
        if (this.version === env_1.Env.Hanoi) {
            giveOrderStateSize = 176;
        }
        const nonceSize = 8 + 8;
        const [state, giveStateRent, nonceRent, dlnNonceAccount] = await Promise.all([
            this.getState(),
            (0, utils_1.getMinimumBalanceForRentExemption)(this.program.provider.connection, giveOrderStateSize),
            (0, utils_1.getMinimumBalanceForRentExemption)(this.program.provider.connection, nonceSize),
            (0, utils_1.getAccountInfoCached)(this.program.provider.connection, this.accountsResolver.getNonceAccount(new web3_js_1.PublicKey(maker))[0]),
        ]);
        // TODO remove after contract 3.0 release on prod
        if (dlnNonceAccount?.lamports !== 0 && this.version !== env_1.Env.Hanoi) {
            dlnNonceAccountRent = nonceRent;
        }
        return state.fixedFee.addn(giveStateRent).addn(ataRent).addn(dlnNonceAccountRent).toNumber();
    }
    /**
     *
     * @param order order data with order id
     * @param amount amount to add to order.give part
     * @returns transaction to modify give part of the order
     */
    async patchGive(order, amount) {
        if (order.give.chainId !== common_types_1.ChainId.Solana)
            throw new client_error_error_1.ClientError(client_error_type_enum_1.ClientErrorType.WrongChain, `Can't patch orders created in ${order.give.chainId} using Solana client`);
        const builder = this.program.methods.patchOrderGive(Array.from(order.orderId), new anchor_1.BN(amount.toString()));
        const orderIdBuf = buffer_1.Buffer.from(order.orderId);
        const givePatchAuthority = new web3_js_1.PublicKey(order.givePatchAuthority);
        builder.accountsStrict({
            giveOrderState: this.accountsResolver.getGiveOrderStateAccount(orderIdBuf)[0],
            giveOrderWallet: this.accountsResolver.getGiveOrderWalletAddress(orderIdBuf)[0],
            givePatchAuthority,
            givePatchAuthorityWallet: (0, solana_utils_1.findAssociatedTokenAddress)(givePatchAuthority, new web3_js_1.PublicKey(order.give.tokenAddress))[0],
            state: this.accountsResolver.getStateAccount()[0],
            splTokenProgram: solana_utils_1.TOKEN_PROGRAM_ID,
        });
        return builder.transaction();
    }
    async createOrder(order, referralCode, affiliateFee, makerWallet, metadata) {
        let useExplicitNonce = false;
        if (Object.prototype.hasOwnProperty.call(order, "nonce") && order.nonce !== undefined) {
            useExplicitNonce = true;
        }
        const [[stateAccount], [nonceAccount]] = await Promise.all([
            this.accountsResolver.getStateAccount(),
            this.accountsResolver.getNonceAccount(buffer_1.Buffer.from(order.maker)),
        ]);
        const [state, nonceData] = await Promise.all([
            this.getState(),
            useExplicitNonce
                ? Promise.resolve({ nonce: new anchor_1.BN(order.nonce.toString()) })
                : this.program.account.nonceMaster.fetchNullable(nonceAccount),
        ]);
        if (state === null) {
            throw new client_error_error_1.ClientError(client_error_type_enum_1.ClientErrorType.SolanaNoSrcState);
        }
        const giveAmountWithoutFee = order.give.amount -
            (BigInt(state.percentFeeBps.toString()) * order.give.amount) / BPS_DENOMINATOR -
            (affiliateFee?.amount || BigInt(0));
        const nonce = nonceData?.nonce;
        if (order.give.chainId != common_types_1.ChainId.Solana) {
            throw new client_error_error_1.ClientError(client_error_type_enum_1.ClientErrorType.SolanaWrongSrcChainId);
        }
        const realOrder = {
            nonce: BigInt(nonce === undefined ? 0 : nonce.toString()),
            give: {
                amount: giveAmountWithoutFee,
                chainId: common_types_1.ChainId.Solana,
                tokenAddress: order.give.tokenAddress,
            },
            take: order.take,
            maker: order.maker,
            receiver: order.receiver,
            givePatchAuthority: order.givePatchAuthority,
            orderAuthorityDstAddress: order.orderAuthorityDstAddress,
            allowedCancelBeneficiary: order.allowedCancelBeneficiary ? order.allowedCancelBeneficiary : undefined,
            allowedTaker: order.allowedTaker,
            externalCall: order.externalCall,
        };
        const orderId = buffer_1.Buffer.from(order_1.Order.calculateId(realOrder).slice(2), "hex");
        const giveMint = new web3_js_1.PublicKey(order.give.tokenAddress);
        const maker = new web3_js_1.PublicKey(order.maker);
        makerWallet = makerWallet || (0, solana_utils_1.findAssociatedTokenAddress)(maker, giveMint)[0];
        const [[giveOrderState], [giveOrderWallet]] = await Promise.all([
            this.accountsResolver.getGiveOrderStateAccount(orderId),
            this.accountsResolver.getGiveOrderWalletAddress(orderId),
        ]);
        const anchorOrder = (0, utils_1.orderDataToAnchorFormat)(realOrder);
        const createOrderArgs = {
            ...anchorOrder,
            giveOriginalAmount: (0, utils_1.bigintToBN)(order.give.amount),
            givePatchAuthoritySrc: new web3_js_1.PublicKey(anchorOrder.givePatchAuthoritySrc),
            allowedCancelBeneficiarySrc: anchorOrder.allowedCancelBeneficiarySrc
                ? new web3_js_1.PublicKey(anchorOrder.allowedCancelBeneficiarySrc)
                : null,
            externalCall: order.externalCall?.externalCallData ? buffer_1.Buffer.from(order.externalCall.externalCallData) : null,
        };
        let builderFn;
        if (useExplicitNonce || metadata?.length !== 0) {
            builderFn = (createArgs, affiliateFee, referralCode) => this.program.methods.createOrderWithNonce(createArgs, affiliateFee, referralCode, nonce, buffer_1.Buffer.from(metadata ?? []));
        }
        else {
            builderFn = this.program.methods.createOrder;
        }
        const orderBuilder = builderFn(createOrderArgs, affiliateFee
            ? {
                beneficiary: new web3_js_1.PublicKey(affiliateFee.beneficiary),
                amount: new anchor_1.BN(affiliateFee.amount.toString()),
            }
            : null, referralCode ?? null);
        orderBuilder.accountsStrict({
            maker,
            state: stateAccount,
            tokenMint: giveMint,
            giveOrderState: giveOrderState,
            authorizedNativeSender: this.accountsResolver.getAuthorizedNativeSenderAddress(buffer_1.Buffer.from((0, utils_1.bigintToArray)(order.take.chainId, "u256")))[0],
            makerWallet: makerWallet,
            feeLedgerWallet: this.accountsResolver.getFeeLedgerWalletAddress(giveMint)[0],
            giveOrderWallet: giveOrderWallet,
            nonceMaster: nonceAccount,
            systemProgram: web3_js_1.SystemProgram.programId,
            splTokenProgram: solana_utils_1.TOKEN_PROGRAM_ID,
            associatedSplTokenProgram: solana_utils_1.ASSOCIATED_TOKEN_PROGRAM_ID,
        });
        return orderBuilder.instruction();
    }
    async withdrawAffiliateFee(orderId, beneficiary, beneficiaryWallet) {
        const orderIdBuffer = typeof orderId === "string" ? solana_utils_1.helpers.hexToBuffer(orderId) : buffer_1.Buffer.from(orderId);
        const builder = this.program.methods.withdrawAffiliateFee(Array.from(orderIdBuffer));
        builder.accountsStrict({
            affiliateFeeBeneficiary: beneficiary,
            affiliateFeeWallet: beneficiaryWallet,
            giveOrderState: this.accountsResolver.getGiveOrderStateAccount(orderIdBuffer)[0],
            giveOrderWallet: this.accountsResolver.getGiveOrderWalletAddress(orderIdBuffer)[0],
            splTokenProgram: solana_utils_1.TOKEN_PROGRAM_ID,
        });
        return builder.transaction();
    }
}
exports.DLNSrc = DLNSrc;
//# sourceMappingURL=dlnSrc.js.map
"use strict";
var _MappedPriceFeed_mapping, _MappedPriceFeed_defaultPriceTokenService;
Object.defineProperty(exports, "__esModule", { value: true });
exports.MappedPriceFeed = void 0;
const tslib_1 = require("tslib");
const common_types_1 = require("../common.types");
const utils_1 = require("../utils");
const price_token_service_1 = require("./price.token.service");
class MappedPriceFeed extends price_token_service_1.PriceTokenService {
    constructor(mapping, defaultPriceTokenService) {
        super();
        _MappedPriceFeed_mapping.set(this, void 0);
        _MappedPriceFeed_defaultPriceTokenService.set(this, void 0);
        tslib_1.__classPrivateFieldSet(this, _MappedPriceFeed_defaultPriceTokenService, defaultPriceTokenService, "f");
        tslib_1.__classPrivateFieldSet(this, _MappedPriceFeed_mapping, mapping || {}, "f");
    }
    async getPrice(chainId, token, context) {
        if (!token)
            token = this.getNativeAddress(chainId);
        const remappedSource = this.findRemapping(chainId, token);
        if (remappedSource) {
            return this.remapSource(chainId, token, remappedSource, context);
        }
        else if (tslib_1.__classPrivateFieldGet(this, _MappedPriceFeed_defaultPriceTokenService, "f")) {
            return tslib_1.__classPrivateFieldGet(this, _MappedPriceFeed_defaultPriceTokenService, "f").getPrice(chainId, token, context);
        }
        else
            throw new Error(`Unable to find price of ${token ? (0, utils_1.tokenAddressToString)(chainId, token) : "null"} on ${common_types_1.ChainId[chainId]}, and default price feed is not specified`);
    }
    calculateRelativeAmount(tokenIn, tokenOut, intermediary) {
        if (!tslib_1.__classPrivateFieldGet(this, _MappedPriceFeed_defaultPriceTokenService, "f")) {
            throw new Error(`For using calculateRelativeAmount need to be setup`);
        }
        return tslib_1.__classPrivateFieldGet(this, _MappedPriceFeed_defaultPriceTokenService, "f").calculateRelativeAmount(tokenIn, tokenOut, intermediary);
    }
    getNominalPrice(token, nominal) {
        if (!tslib_1.__classPrivateFieldGet(this, _MappedPriceFeed_defaultPriceTokenService, "f")) {
            throw new Error(`For using getNominalPrice need to be setup`);
        }
        return tslib_1.__classPrivateFieldGet(this, _MappedPriceFeed_defaultPriceTokenService, "f")?.getNominalPrice(token, nominal);
    }
    findRemapping(chainId, srcToken) {
        return Object.entries(tslib_1.__classPrivateFieldGet(this, _MappedPriceFeed_mapping, "f")[chainId] || {}).find(([token, priceSource]) => (0, utils_1.buffersAreEqual)((0, utils_1.tokenStringToBuffer)(chainId, token), srcToken))?.[1];
    }
    remapSource(chainId, token, source, context) {
        switch (source.type) {
            case "redirect":
                return this.getPrice(source.chainId, source.token, context);
            case "fixed":
                return Promise.resolve(source.hardcodedPrice);
            case "compute":
                return source.func(chainId, token, context);
            default:
                throw new Error(`Unexpected remap type`);
        }
    }
    getNativeAddress(chain) {
        switch ((0, common_types_1.getEngineByChainId)(chain)) {
            case common_types_1.ChainEngine.Solana:
                return (0, utils_1.tokenStringToBuffer)(chain, common_types_1.ZERO_SOLANA_ADDRESS);
            case common_types_1.ChainEngine.EVM:
                return (0, utils_1.tokenStringToBuffer)(chain, common_types_1.ZERO_EVM_ADDRESS);
            default:
                throw new Error();
        }
    }
}
exports.MappedPriceFeed = MappedPriceFeed;
_MappedPriceFeed_mapping = new WeakMap(), _MappedPriceFeed_defaultPriceTokenService = new WeakMap();
//# sourceMappingURL=mappedPriceTokenService.js.map
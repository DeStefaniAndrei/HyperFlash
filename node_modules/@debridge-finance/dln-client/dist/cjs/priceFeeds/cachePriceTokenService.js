"use strict";
var _CachePriceFeed_instances, _CachePriceFeed_cache, _CachePriceFeed_priceTokenService, _CachePriceFeed_getCacheKey;
Object.defineProperty(exports, "__esModule", { value: true });
exports.CachePriceFeed = void 0;
const tslib_1 = require("tslib");
const node_cache_1 = tslib_1.__importDefault(require("node-cache"));
const utils_1 = require("../utils");
const price_token_service_1 = require("./price.token.service");
class CachePriceFeed extends price_token_service_1.PriceTokenService {
    constructor(priceTokenService, ttl) {
        super();
        _CachePriceFeed_instances.add(this);
        _CachePriceFeed_cache.set(this, void 0);
        _CachePriceFeed_priceTokenService.set(this, void 0);
        tslib_1.__classPrivateFieldSet(this, _CachePriceFeed_priceTokenService, priceTokenService, "f");
        tslib_1.__classPrivateFieldSet(this, _CachePriceFeed_cache, new node_cache_1.default({ stdTTL: ttl }), "f");
    }
    async calculateRelativeAmount(tokenIn, tokenOut, nominal) {
        // price of 10 ** inTokenDecimals in nominal token
        const inNominalPrice = await this.getNominalPrice(tokenIn, nominal);
        const outNominalPrice = await this.getNominalPrice(tokenOut, nominal);
        if (inNominalPrice === undefined || outNominalPrice === undefined)
            return undefined;
        return (0, utils_1.fixDecimals)((inNominalPrice * tokenIn.amount) / outNominalPrice, tokenIn.decimals, tokenOut.decimals);
    }
    async getNominalPrice(token, nominal) {
        const cachedKey = `nominalPrice_chain_${token.chainId}_token_${(0, utils_1.tokenAddressToString)(token.chainId, token.tokenAddress)}_nominal_${nominal ? (0, utils_1.tokenAddressToString)(token.chainId, nominal) : "-"}`;
        const cachedValue = tslib_1.__classPrivateFieldGet(this, _CachePriceFeed_cache, "f").get(cachedKey);
        if (cachedValue) {
            return cachedValue;
        }
        const value = await tslib_1.__classPrivateFieldGet(this, _CachePriceFeed_priceTokenService, "f").getNominalPrice(token, nominal);
        tslib_1.__classPrivateFieldGet(this, _CachePriceFeed_cache, "f").set(cachedKey, value);
        return value;
    }
    async getPrice(chainId, token, context) {
        const logger = (...params) => context.logger.verbose(`[CachePriceFeed]`, ...params);
        const cachedKey = tslib_1.__classPrivateFieldGet(this, _CachePriceFeed_instances, "m", _CachePriceFeed_getCacheKey).call(this, chainId, token);
        const cachedValue = tslib_1.__classPrivateFieldGet(this, _CachePriceFeed_cache, "f").get(cachedKey);
        if (cachedValue) {
            logger("Cache hit:", cachedKey, JSON.stringify(cachedValue));
            return cachedValue;
        }
        logger("Cache missing", cachedKey);
        const value = await tslib_1.__classPrivateFieldGet(this, _CachePriceFeed_priceTokenService, "f").getPrice(chainId, token, context);
        tslib_1.__classPrivateFieldGet(this, _CachePriceFeed_cache, "f").set(cachedKey, value);
        return value;
    }
}
exports.CachePriceFeed = CachePriceFeed;
_CachePriceFeed_cache = new WeakMap(), _CachePriceFeed_priceTokenService = new WeakMap(), _CachePriceFeed_instances = new WeakSet(), _CachePriceFeed_getCacheKey = function _CachePriceFeed_getCacheKey(chainId, token) {
    return `CoingeckoPriceFeed$chainid=${chainId}$token=${token ? (0, utils_1.tokenAddressToString)(chainId, token) : "-"}`;
};
//# sourceMappingURL=cachePriceTokenService.js.map
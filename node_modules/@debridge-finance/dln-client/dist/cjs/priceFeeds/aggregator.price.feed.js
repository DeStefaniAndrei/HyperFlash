"use strict";
var _AggregatorPriceTokenService_instances, _AggregatorPriceTokenService_config, _AggregatorPriceTokenService_decimalsGetter, _AggregatorPriceTokenService_swapConnectorGetter, _AggregatorPriceTokenService_fixToken, _AggregatorPriceTokenService_swapConnector_get;
Object.defineProperty(exports, "__esModule", { value: true });
exports.AggregatorPriceTokenService = void 0;
const tslib_1 = require("tslib");
const __1 = require("..");
const common_types_1 = require("../common.types");
const price_token_service_1 = require("./price.token.service");
const defaultConfig = {
    [common_types_1.ChainId.Arbitrum]: ["0xff970a61a04b1ca14834a43f5de4533ebddb5cc8", 6],
    [common_types_1.ChainId.Avalanche]: ["0xB97EF9Ef8734C71904D8002F8b6Bc66Dd9c48a6E", 6],
    [common_types_1.ChainId.Bitrock]: ["0xD647a6E1F898c39bA594443c19De0872EA935310", 6],
    [common_types_1.ChainId.Base]: ["0xd9aaec86b65d86f6a7b5b1b0c42ffa531710b6ca", 6],
    [common_types_1.ChainId.BSC]: ["0x8ac76a51cc950d9822d68b83fe1ad97b32cd580d", 18],
    [common_types_1.ChainId.Ethereum]: ["0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48", 6],
    [common_types_1.ChainId.Gnosis]: ["0xDDAfbb505ad214D7b80b1f830fcCc89B60fb7A83", 6],
    [common_types_1.ChainId.Linea]: ["0x176211869cA2b568f2A7D4EE941E073a821EE1ff", 6],
    [common_types_1.ChainId.Optimism]: ["0x7f5c764cbc14f9669b88837ca1490cca17c31607", 6],
    [common_types_1.ChainId.Polygon]: ["0x2791bca1f2de4661ed88a30c99a7a9449aa84174", 6],
    [common_types_1.ChainId.Solana]: ["EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v", 6],
    [common_types_1.ChainId.Neon]: ["0xEA6B04272f9f62F997F666F07D3a974134f7FFb9", 6],
    [common_types_1.ChainId.Metis]: ["0xEA32A96608495e54156Ae48931A7c20f0dcc1a21", 6],
    [common_types_1.ChainId.LightLink]: ["0x18fB38404DADeE1727Be4b805c5b242B5413Fa40", 6],
};
const stablecoinBaseValue = 100n;
class AggregatorPriceTokenService extends price_token_service_1.PriceTokenService {
    constructor(decimalsGetter, swapConnectorGetter, config) {
        super();
        _AggregatorPriceTokenService_instances.add(this);
        _AggregatorPriceTokenService_config.set(this, void 0);
        _AggregatorPriceTokenService_decimalsGetter.set(this, void 0);
        _AggregatorPriceTokenService_swapConnectorGetter.set(this, void 0);
        tslib_1.__classPrivateFieldSet(this, _AggregatorPriceTokenService_decimalsGetter, decimalsGetter, "f");
        tslib_1.__classPrivateFieldSet(this, _AggregatorPriceTokenService_swapConnectorGetter, swapConnectorGetter, "f");
        tslib_1.__classPrivateFieldSet(this, _AggregatorPriceTokenService_config, { ...defaultConfig, ...config }, "f");
    }
    async getPrice(chain, token, context) {
        const logger = (...params) => context.logger.verbose(`[${AggregatorPriceTokenService.name} chain: ${chain}]`, ...params);
        if (!tslib_1.__classPrivateFieldGet(this, _AggregatorPriceTokenService_config, "f")[chain])
            throw new Error(`${AggregatorPriceTokenService.name}: not configured for ${chain}`);
        const [fromTokenRaw, fromTokenDecimals] = tslib_1.__classPrivateFieldGet(this, _AggregatorPriceTokenService_config, "f")[chain];
        const fromToken = typeof fromTokenRaw === "string" ? (0, __1.tokenStringToBuffer)(chain, fromTokenRaw) : fromTokenRaw;
        const toToken = tslib_1.__classPrivateFieldGet(this, _AggregatorPriceTokenService_instances, "m", _AggregatorPriceTokenService_fixToken).call(this, chain, token);
        if ((0, __1.buffersAreEqual)(toToken, fromToken))
            return Promise.resolve(1);
        const fromAmountRaw = stablecoinBaseValue;
        const toTokenDecimals = await tslib_1.__classPrivateFieldGet(this, _AggregatorPriceTokenService_decimalsGetter, "f").call(this, chain, toToken);
        const outcome = await tslib_1.__classPrivateFieldGet(this, _AggregatorPriceTokenService_instances, "a", _AggregatorPriceTokenService_swapConnector_get).getEstimate({
            chainId: chain,
            slippageBps: 100,
            fromTokenAddress: fromToken,
            amountIn: BigInt(fromAmountRaw) * 10n ** BigInt(fromTokenDecimals),
            toTokenAddress: toToken,
        }, context);
        logger(`swapping ${fromAmountRaw} of a stable coin to ${(0, __1.tokenAddressToString)(chain, toToken)} gives ${outcome.amountOut}`);
        const precision = 6;
        const rate = (fromAmountRaw * 10n ** BigInt(toTokenDecimals + precision)) / outcome.amountOut;
        const normalizedRate = Number(rate.toString()) / 10 ** precision;
        logger(`calculated rate: ${rate}, normalized: ${normalizedRate}`);
        return normalizedRate;
    }
    calculateRelativeAmount(tokenIn, tokenOut, intermediary) {
        throw new Error("Method not implemented.");
    }
    getNominalPrice(token, nominal) {
        throw new Error("Method not implemented.");
    }
}
exports.AggregatorPriceTokenService = AggregatorPriceTokenService;
_AggregatorPriceTokenService_config = new WeakMap(), _AggregatorPriceTokenService_decimalsGetter = new WeakMap(), _AggregatorPriceTokenService_swapConnectorGetter = new WeakMap(), _AggregatorPriceTokenService_instances = new WeakSet(), _AggregatorPriceTokenService_fixToken = function _AggregatorPriceTokenService_fixToken(chain, token) {
    if (!token) {
        if (chain === common_types_1.ChainId.Solana)
            return Buffer.alloc(32);
        return Buffer.alloc(20);
    }
    return token;
}, _AggregatorPriceTokenService_swapConnector_get = function _AggregatorPriceTokenService_swapConnector_get() {
    return typeof tslib_1.__classPrivateFieldGet(this, _AggregatorPriceTokenService_swapConnectorGetter, "f") === "function" ? tslib_1.__classPrivateFieldGet(this, _AggregatorPriceTokenService_swapConnectorGetter, "f").call(this) : tslib_1.__classPrivateFieldGet(this, _AggregatorPriceTokenService_swapConnectorGetter, "f");
};
//# sourceMappingURL=aggregator.price.feed.js.map
"use strict";
var _FallbackPriceFeed_priceTokenServices;
Object.defineProperty(exports, "__esModule", { value: true });
exports.FallbackPriceFeed = void 0;
const tslib_1 = require("tslib");
const price_token_service_1 = require("./price.token.service");
class FallbackPriceFeed extends price_token_service_1.PriceTokenService {
    constructor(priceTokenServices) {
        super();
        _FallbackPriceFeed_priceTokenServices.set(this, void 0);
        tslib_1.__classPrivateFieldSet(this, _FallbackPriceFeed_priceTokenServices, priceTokenServices, "f");
    }
    async calculateRelativeAmount(tokenIn, tokenOut, intermediary) {
        for (let i = 0; i < tslib_1.__classPrivateFieldGet(this, _FallbackPriceFeed_priceTokenServices, "f").length; i++) {
            const priceTokenService = tslib_1.__classPrivateFieldGet(this, _FallbackPriceFeed_priceTokenServices, "f")[i];
            const isLastStep = i === tslib_1.__classPrivateFieldGet(this, _FallbackPriceFeed_priceTokenServices, "f").length - 1;
            if (isLastStep)
                return priceTokenService.calculateRelativeAmount(tokenIn, tokenOut, intermediary);
            try {
                // eslint-disable-next-line no-await-in-loop -- intentional
                return await priceTokenService.calculateRelativeAmount(tokenIn, tokenOut, intermediary);
                // eslint-disable-next-line no-empty -- intentional
            }
            catch (e) { }
        }
        throw new Error("not reachable");
    }
    async getNominalPrice(token, nominal) {
        for (let i = 0; i < tslib_1.__classPrivateFieldGet(this, _FallbackPriceFeed_priceTokenServices, "f").length; i++) {
            const priceTokenService = tslib_1.__classPrivateFieldGet(this, _FallbackPriceFeed_priceTokenServices, "f")[i];
            const isLastStep = i === tslib_1.__classPrivateFieldGet(this, _FallbackPriceFeed_priceTokenServices, "f").length - 1;
            if (isLastStep)
                return priceTokenService.getNominalPrice(token, nominal);
            try {
                // eslint-disable-next-line no-await-in-loop -- intentional
                return await priceTokenService.getNominalPrice(token, nominal);
                // eslint-disable-next-line no-empty -- intentional
            }
            catch (e) { }
        }
        throw new Error("not reachable");
    }
    async getPrice(chain, token, context) {
        for (let i = 0; i < tslib_1.__classPrivateFieldGet(this, _FallbackPriceFeed_priceTokenServices, "f").length; i++) {
            const priceTokenService = tslib_1.__classPrivateFieldGet(this, _FallbackPriceFeed_priceTokenServices, "f")[i];
            const isLastStep = i === tslib_1.__classPrivateFieldGet(this, _FallbackPriceFeed_priceTokenServices, "f").length - 1;
            if (isLastStep)
                return priceTokenService.getPrice(chain, token, context);
            try {
                // eslint-disable-next-line no-await-in-loop -- intentional
                return await priceTokenService.getPrice(chain, token, context);
            }
            catch (e) {
                const error = e;
                context.logger.error(`${FallbackPriceFeed.name}::getPrice failed at price feed #${i + 1}: ${error.toString()}`);
                context.logger.error(e);
            }
        }
        throw new Error("not reachable");
    }
}
exports.FallbackPriceFeed = FallbackPriceFeed;
_FallbackPriceFeed_priceTokenServices = new WeakMap();
//# sourceMappingURL=fallback-price-feed.js.map
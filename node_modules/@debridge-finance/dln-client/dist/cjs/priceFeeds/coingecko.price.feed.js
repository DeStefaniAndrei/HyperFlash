"use strict";
var _CoingeckoPriceFeed_instances, _CoingeckoPriceFeed_domain, _CoingeckoPriceFeed_endpointTokenPrice, _CoingeckoPriceFeed_endpointGasPrice, _CoingeckoPriceFeed_currency, _CoingeckoPriceFeed_api_key, _CoingeckoPriceFeed_logger, _CoingeckoPriceFeed_defaultNominalTokens, _CoingeckoPriceFeed_getDecimals, _CoingeckoPriceFeed_fixNativeAddress, _CoingeckoPriceFeed_isNative, _CoingeckoPriceFeed_getGasPrice, _CoingeckoPriceFeed_fetch, _CoingeckoPriceFeed_getNativeCoinName, _CoingeckoPriceFeed_getCoinGeckoChainId;
Object.defineProperty(exports, "__esModule", { value: true });
exports.CoingeckoPriceFeed = void 0;
const tslib_1 = require("tslib");
const common_types_1 = require("../common.types");
const client_error_type_enum_1 = require("../errors/client-error-type.enum");
const client_error_error_1 = require("../errors/client-error.error");
const utils_1 = require("../utils");
const price_token_service_1 = require("./price.token.service");
class CoingeckoPriceFeed extends price_token_service_1.PriceTokenService {
    constructor(token, logger) {
        super();
        _CoingeckoPriceFeed_instances.add(this);
        _CoingeckoPriceFeed_domain.set(this, void 0);
        _CoingeckoPriceFeed_endpointTokenPrice.set(this, "/api/v3/simple/token_price/");
        _CoingeckoPriceFeed_endpointGasPrice.set(this, "/api/v3/simple/price");
        _CoingeckoPriceFeed_currency.set(this, "usd");
        _CoingeckoPriceFeed_api_key.set(this, void 0);
        _CoingeckoPriceFeed_logger.set(this, void 0);
        _CoingeckoPriceFeed_defaultNominalTokens.set(this, null);
        _CoingeckoPriceFeed_getDecimals.set(this, null);
        if (logger)
            tslib_1.__classPrivateFieldSet(this, _CoingeckoPriceFeed_logger, logger, "f");
        if (token) {
            tslib_1.__classPrivateFieldSet(this, _CoingeckoPriceFeed_domain, "https://pro-api.coingecko.com", "f");
            tslib_1.__classPrivateFieldSet(this, _CoingeckoPriceFeed_api_key, `&x_cg_pro_api_key=${token}`, "f");
        }
        else {
            tslib_1.__classPrivateFieldSet(this, _CoingeckoPriceFeed_domain, "https://api.coingecko.com", "f");
            tslib_1.__classPrivateFieldSet(this, _CoingeckoPriceFeed_api_key, "", "f");
        }
    }
    enableRelativeCalculations(defaultNominalTokens, getDecimals) {
        tslib_1.__classPrivateFieldSet(this, _CoingeckoPriceFeed_defaultNominalTokens, defaultNominalTokens, "f");
        tslib_1.__classPrivateFieldSet(this, _CoingeckoPriceFeed_getDecimals, getDecimals, "f");
    }
    async getNominalPrice(token, nominal) {
        if (tslib_1.__classPrivateFieldGet(this, _CoingeckoPriceFeed_defaultNominalTokens, "f") === null || tslib_1.__classPrivateFieldGet(this, _CoingeckoPriceFeed_getDecimals, "f") === null)
            throw new Error(`call enableRelativeCalculations to allow relative token amount calculation`);
        // price of 1e(token decimals) in usd
        // we can think of usd as a token with decimals = 2
        nominal = nominal || tslib_1.__classPrivateFieldGet(this, _CoingeckoPriceFeed_defaultNominalTokens, "f").get(token.chainId);
        if (nominal === undefined)
            throw new Error("Nominal token required!");
        if ((0, utils_1.buffersAreEqual)(nominal, token.tokenAddress)) {
            return 10n ** BigInt(token.decimals);
        }
        const [tokenUsdPrice, nominalUsdPrice, nominalDecimals] = await Promise.all([
            this.getPrice(token.chainId, tslib_1.__classPrivateFieldGet(this, _CoingeckoPriceFeed_instances, "m", _CoingeckoPriceFeed_fixNativeAddress).call(this, token.chainId, token.tokenAddress), { logger: tslib_1.__classPrivateFieldGet(this, _CoingeckoPriceFeed_logger, "f") }),
            this.getPrice(token.chainId, tslib_1.__classPrivateFieldGet(this, _CoingeckoPriceFeed_instances, "m", _CoingeckoPriceFeed_fixNativeAddress).call(this, token.chainId, nominal), { logger: tslib_1.__classPrivateFieldGet(this, _CoingeckoPriceFeed_logger, "f") }),
            tslib_1.__classPrivateFieldGet(this, _CoingeckoPriceFeed_getDecimals, "f").call(this, token.chainId, nominal),
        ]);
        const tokenUsdBigintPrice = BigInt(Math.floor(tokenUsdPrice * 100));
        const nominalUsdBigintPrice = BigInt(Math.floor(nominalUsdPrice * 100));
        return (0, utils_1.fixDecimals)((tokenUsdBigintPrice * BigInt(10 ** token.decimals)) / nominalUsdBigintPrice, token.decimals, nominalDecimals);
    }
    async calculateRelativeAmount(tokenIn, tokenOut, nominal) {
        // price of 10 ** inTokenDecimals in nominal token
        const inNominalPrice = await this.getNominalPrice(tokenIn, nominal);
        const outNominalPrice = await this.getNominalPrice(tokenOut, nominal);
        if (inNominalPrice === undefined || outNominalPrice === undefined)
            return undefined;
        return (0, utils_1.fixDecimals)((inNominalPrice * tokenIn.amount) / outNominalPrice, tokenIn.decimals, tokenOut.decimals);
    }
    async getPrice(chainId, token, context) {
        if (!token || tslib_1.__classPrivateFieldGet(this, _CoingeckoPriceFeed_instances, "m", _CoingeckoPriceFeed_isNative).call(this, chainId, token)) {
            context.logger.verbose({ context: CoingeckoPriceFeed.name }, "requested native token price, fallback to getGasPrice()");
            return tslib_1.__classPrivateFieldGet(this, _CoingeckoPriceFeed_instances, "m", _CoingeckoPriceFeed_getGasPrice).call(this, chainId, context);
        }
        const coinGeckoChainId = tslib_1.__classPrivateFieldGet(this, _CoingeckoPriceFeed_instances, "m", _CoingeckoPriceFeed_getCoinGeckoChainId).call(this, chainId);
        const tokenAddress = (0, utils_1.tokenAddressToString)(chainId, token);
        const url = tslib_1.__classPrivateFieldGet(this, _CoingeckoPriceFeed_domain, "f") +
            tslib_1.__classPrivateFieldGet(this, _CoingeckoPriceFeed_endpointTokenPrice, "f") +
            coinGeckoChainId +
            `?contract_addresses=${tokenAddress}&vs_currencies=${tslib_1.__classPrivateFieldGet(this, _CoingeckoPriceFeed_currency, "f")}`;
        const data = await tslib_1.__classPrivateFieldGet(this, _CoingeckoPriceFeed_instances, "m", _CoingeckoPriceFeed_fetch).call(this, url, context);
        return data[tokenAddress][tslib_1.__classPrivateFieldGet(this, _CoingeckoPriceFeed_currency, "f")];
    }
}
exports.CoingeckoPriceFeed = CoingeckoPriceFeed;
_CoingeckoPriceFeed_domain = new WeakMap(), _CoingeckoPriceFeed_endpointTokenPrice = new WeakMap(), _CoingeckoPriceFeed_endpointGasPrice = new WeakMap(), _CoingeckoPriceFeed_currency = new WeakMap(), _CoingeckoPriceFeed_api_key = new WeakMap(), _CoingeckoPriceFeed_logger = new WeakMap(), _CoingeckoPriceFeed_defaultNominalTokens = new WeakMap(), _CoingeckoPriceFeed_getDecimals = new WeakMap(), _CoingeckoPriceFeed_instances = new WeakSet(), _CoingeckoPriceFeed_fixNativeAddress = function _CoingeckoPriceFeed_fixNativeAddress(chain, address) {
    const nativeEvm = Buffer.allocUnsafe(20).fill(0);
    const nativeSol = Buffer.allocUnsafe(32).fill(0);
    if (chain === common_types_1.ChainId.Solana) {
        if ((0, utils_1.buffersAreEqual)(nativeSol, address))
            return null;
    }
    else {
        if ((0, utils_1.buffersAreEqual)(nativeEvm, address))
            return null;
    }
    return address;
}, _CoingeckoPriceFeed_isNative = function _CoingeckoPriceFeed_isNative(chain, token) {
    if (chain === common_types_1.ChainId.Solana && (0, utils_1.buffersAreEqual)(token, Buffer.alloc(32)))
        return true;
    if ((0, utils_1.buffersAreEqual)(token, Buffer.alloc(20)))
        return true;
    return false;
}, _CoingeckoPriceFeed_getGasPrice = 
// eslint-disable-next-line @typescript-eslint/ban-types
async function _CoingeckoPriceFeed_getGasPrice(chainId, context) {
    const getNativeCoinName = tslib_1.__classPrivateFieldGet(this, _CoingeckoPriceFeed_instances, "m", _CoingeckoPriceFeed_getNativeCoinName).call(this, chainId);
    const url = tslib_1.__classPrivateFieldGet(this, _CoingeckoPriceFeed_domain, "f") + tslib_1.__classPrivateFieldGet(this, _CoingeckoPriceFeed_endpointGasPrice, "f") + `?ids=${getNativeCoinName}&vs_currencies=${tslib_1.__classPrivateFieldGet(this, _CoingeckoPriceFeed_currency, "f")}`;
    const data = await tslib_1.__classPrivateFieldGet(this, _CoingeckoPriceFeed_instances, "m", _CoingeckoPriceFeed_fetch).call(this, url, context);
    return data[getNativeCoinName][tslib_1.__classPrivateFieldGet(this, _CoingeckoPriceFeed_currency, "f")];
}, _CoingeckoPriceFeed_fetch = 
// eslint-disable-next-line @typescript-eslint/ban-types, @typescript-eslint/no-explicit-any
async function _CoingeckoPriceFeed_fetch(url, context) {
    const startTime = Date.now();
    const parsedUrl = new URL(url);
    const reqCtx = {
        context: CoingeckoPriceFeed.name,
        url: parsedUrl.href,
        pathname: parsedUrl.pathname,
        host: parsedUrl.host,
        type: "external_request",
    };
    context.logger.log(reqCtx, `Fetching Coingecko`);
    const response = await fetch(url + tslib_1.__classPrivateFieldGet(this, _CoingeckoPriceFeed_api_key, "f")).then((r) => r.json());
    const resCtx = {
        ...reqCtx,
        response,
        duration: Date.now() - startTime,
    };
    context.logger.log(resCtx, `Fetched Coingecko`);
    return response;
}, _CoingeckoPriceFeed_getNativeCoinName = function _CoingeckoPriceFeed_getNativeCoinName(chainId) {
    switch (chainId) {
        case common_types_1.ChainId.Linea:
        case common_types_1.ChainId.Arbitrum:
        case common_types_1.ChainId.ArbitrumTest:
        case common_types_1.ChainId.Optimism:
        case common_types_1.ChainId.LightLink:
        case common_types_1.ChainId.Ethereum: {
            return "ethereum";
        }
        case common_types_1.ChainId.BSCTest:
        case common_types_1.ChainId.BSC: {
            return "binancecoin";
        }
        case common_types_1.ChainId.HecoTest:
        case common_types_1.ChainId.Heco: {
            return "huobi-token";
        }
        case common_types_1.ChainId.PolygonTest:
        case common_types_1.ChainId.Polygon: {
            return "matic-network";
        }
        case common_types_1.ChainId.AvalancheTest:
        case common_types_1.ChainId.Avalanche: {
            return "avalanche-2";
        }
        case common_types_1.ChainId.Solana: {
            return "solana";
        }
        case common_types_1.ChainId.Fantom: {
            return "fantom";
        }
        case common_types_1.ChainId.Neon: {
            return "neon";
        }
        case common_types_1.ChainId.Gnosis: {
            return "xdai";
        }
        case common_types_1.ChainId.Metis: {
            return "metis-token";
        }
        case common_types_1.ChainId.Bitrock: {
            return "bitrock";
        }
    }
    throw new client_error_error_1.ClientError(client_error_type_enum_1.ClientErrorType.UnsupportedChain);
}, _CoingeckoPriceFeed_getCoinGeckoChainId = function _CoingeckoPriceFeed_getCoinGeckoChainId(chainId) {
    switch (chainId) {
        case common_types_1.ChainId.Ethereum: {
            return "ethereum";
        }
        case common_types_1.ChainId.BSC: {
            return "binance-smart-chain";
        }
        case common_types_1.ChainId.BSCTest: {
            return "binance-smart-chain";
        }
        case common_types_1.ChainId.Heco: {
            return "huobi-token";
        }
        case common_types_1.ChainId.HecoTest: {
            return "huobi-token";
        }
        case common_types_1.ChainId.Polygon: {
            return "polygon-pos";
        }
        case common_types_1.ChainId.PolygonTest: {
            return "polygon-pos";
        }
        case common_types_1.ChainId.Arbitrum: {
            return "arbitrum-one";
        }
        case common_types_1.ChainId.Avalanche: {
            return "avalanche";
        }
        case common_types_1.ChainId.AvalancheTest: {
            return "avalanche";
        }
        case common_types_1.ChainId.ArbitrumTest: {
            return "arbitrum-one";
        }
        case common_types_1.ChainId.Solana: {
            return "solana";
        }
        case common_types_1.ChainId.Fantom: {
            return "fantom";
        }
        case common_types_1.ChainId.Neon: {
            return "neon-evm";
        }
        case common_types_1.ChainId.LightLink: {
            return "lightlink";
        }
        case common_types_1.ChainId.Gnosis: {
            return "xdai";
        }
        case common_types_1.ChainId.Metis: {
            return "metis-andromeda";
        }
        case common_types_1.ChainId.Optimism: {
            return "optimistic-ethereum";
        }
        case common_types_1.ChainId.Bitrock: {
            return "bitrock";
        }
    }
    throw new client_error_error_1.ClientError(client_error_type_enum_1.ClientErrorType.UnsupportedChain);
};
//# sourceMappingURL=coingecko.price.feed.js.map
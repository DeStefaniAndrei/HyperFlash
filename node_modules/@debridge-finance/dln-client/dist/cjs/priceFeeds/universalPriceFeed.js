"use strict";
var _UniversalPriceTokenService_defaultPriceTokenService;
Object.defineProperty(exports, "__esModule", { value: true });
exports.UniversalPriceTokenService = void 0;
const tslib_1 = require("tslib");
const common_types_1 = require("../common.types");
const utils_1 = require("../utils");
const cachePriceTokenService_1 = require("./cachePriceTokenService");
const coingecko_price_feed_1 = require("./coingecko.price.feed");
const mappedPriceTokenService_1 = require("./mappedPriceTokenService");
const price_token_service_1 = require("./price.token.service");
const defaultCoingeckoCacheTtl = 60 * 5; // 5m
/**
 * A price token service with predefined immutable configuration suitable for DLN API and dln-taker
 * It uses CoingeckoPriceFeed with 5m cache under the hood, and overrides some popular intermediary
 * tokens used inside buckets
 */
class UniversalPriceTokenService extends price_token_service_1.PriceTokenService {
    constructor(opts = {}) {
        super();
        _UniversalPriceTokenService_defaultPriceTokenService.set(this, void 0);
        tslib_1.__classPrivateFieldSet(this, _UniversalPriceTokenService_defaultPriceTokenService, new mappedPriceTokenService_1.MappedPriceFeed({
            [common_types_1.ChainId.Solana]: {
                // remap USDC@Solana price to USDC@Ethereum
                EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v: {
                    type: "redirect",
                    chainId: common_types_1.ChainId.Ethereum,
                    token: (0, utils_1.tokenStringToBuffer)(common_types_1.ChainId.Ethereum, "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48"),
                },
            },
            [common_types_1.ChainId.Linea]: {
                // remap ETH@Linea price to ETH@Ethereum
                [common_types_1.ZERO_EVM_ADDRESS]: {
                    type: "redirect",
                    chainId: common_types_1.ChainId.Ethereum,
                    token: (0, utils_1.tokenStringToBuffer)(common_types_1.ChainId.Ethereum, common_types_1.ZERO_EVM_ADDRESS),
                },
            },
        }, new cachePriceTokenService_1.CachePriceFeed(new coingecko_price_feed_1.CoingeckoPriceFeed(opts.coingeckoApiKey), opts.coingeckoCacheTTL || defaultCoingeckoCacheTtl)), "f");
    }
    async getPrice(chainId, token, context) {
        return tslib_1.__classPrivateFieldGet(this, _UniversalPriceTokenService_defaultPriceTokenService, "f").getPrice(chainId, token, context);
    }
    calculateRelativeAmount(tokenIn, tokenOut, intermediary) {
        if (!tslib_1.__classPrivateFieldGet(this, _UniversalPriceTokenService_defaultPriceTokenService, "f")) {
            throw new Error(`For using calculateRelativeAmount need to be setup`);
        }
        return tslib_1.__classPrivateFieldGet(this, _UniversalPriceTokenService_defaultPriceTokenService, "f").calculateRelativeAmount(tokenIn, tokenOut, intermediary);
    }
    getNominalPrice(token, nominal) {
        if (!tslib_1.__classPrivateFieldGet(this, _UniversalPriceTokenService_defaultPriceTokenService, "f")) {
            throw new Error(`For using getNominalPrice need to be setup`);
        }
        return tslib_1.__classPrivateFieldGet(this, _UniversalPriceTokenService_defaultPriceTokenService, "f")?.getNominalPrice(token, nominal);
    }
}
exports.UniversalPriceTokenService = UniversalPriceTokenService;
_UniversalPriceTokenService_defaultPriceTokenService = new WeakMap();
//# sourceMappingURL=universalPriceFeed.js.map
"use strict";
var _ZeroXSwapConnector_instances, _ZeroXSwapConnector_URL_PER_CHAIN, _ZeroXSwapConnector_apiKey, _ZeroXSwapConnector_customSources, _ZeroXSwapConnector_maskCredentialFunction, _ZeroXSwapConnector_feeRecipientTradeSurplus, _ZeroXSwapConnector_timeoutInMs, _ZeroXSwapConnector_call0x, _ZeroXSwapConnector_getUrlByChain, _ZeroXSwapConnector_nativeAddressToEvmFormat, _ZeroXSwapConnector_fixEvmNativeAddress;
Object.defineProperty(exports, "__esModule", { value: true });
exports.ZeroXSwapConnector = void 0;
const tslib_1 = require("tslib");
const solana_utils_1 = require("@debridge-finance/solana-utils");
const common_types_1 = require("../common.types");
const swap_connector_1 = require("./swap.connector");
const swap_connector_error_type_1 = require("./errors/swap-connector-error.type");
const swap_connector_error_1 = require("./errors/swap-connector.error");
const swap_connector_logger_1 = require("./swap-connector.logger");
var ZeroXSupportedChainId;
(function (ZeroXSupportedChainId) {
    ZeroXSupportedChainId[ZeroXSupportedChainId["Ethereum"] = 1] = "Ethereum";
    ZeroXSupportedChainId[ZeroXSupportedChainId["BSC"] = 56] = "BSC";
    ZeroXSupportedChainId[ZeroXSupportedChainId["Arbitrum"] = 42161] = "Arbitrum";
    ZeroXSupportedChainId[ZeroXSupportedChainId["Avalanche"] = 43114] = "Avalanche";
    ZeroXSupportedChainId[ZeroXSupportedChainId["Optimism"] = 10] = "Optimism";
    ZeroXSupportedChainId[ZeroXSupportedChainId["Polygon"] = 137] = "Polygon";
    ZeroXSupportedChainId[ZeroXSupportedChainId["Fantom"] = 250] = "Fantom";
    ZeroXSupportedChainId[ZeroXSupportedChainId["Base"] = 8453] = "Base";
})(ZeroXSupportedChainId || (ZeroXSupportedChainId = {}));
class ZeroXSwapConnector extends swap_connector_1.SwapConnector {
    constructor(apiKey, customSources, feeRecipientTradeSurplus, timeoutInMs) {
        super();
        _ZeroXSwapConnector_instances.add(this);
        _ZeroXSwapConnector_URL_PER_CHAIN.set(this, {
            [ZeroXSupportedChainId.Ethereum]: "",
            [ZeroXSupportedChainId.Polygon]: "polygon.",
            [ZeroXSupportedChainId.BSC]: "bsc.",
            [ZeroXSupportedChainId.Optimism]: "optimism.",
            [ZeroXSupportedChainId.Fantom]: "fantom.",
            [ZeroXSupportedChainId.Avalanche]: "avalanche.",
            [ZeroXSupportedChainId.Arbitrum]: "arbitrum.",
            [ZeroXSupportedChainId.Base]: "base.",
        });
        _ZeroXSwapConnector_apiKey.set(this, void 0);
        _ZeroXSwapConnector_customSources.set(this, void 0);
        _ZeroXSwapConnector_maskCredentialFunction.set(this, void 0);
        _ZeroXSwapConnector_feeRecipientTradeSurplus.set(this, void 0);
        _ZeroXSwapConnector_timeoutInMs.set(this, void 0);
        tslib_1.__classPrivateFieldSet(this, _ZeroXSwapConnector_feeRecipientTradeSurplus, feeRecipientTradeSurplus, "f");
        tslib_1.__classPrivateFieldSet(this, _ZeroXSwapConnector_apiKey, apiKey, "f");
        tslib_1.__classPrivateFieldSet(this, _ZeroXSwapConnector_customSources, customSources, "f");
        tslib_1.__classPrivateFieldSet(this, _ZeroXSwapConnector_maskCredentialFunction, (text) => text.replaceAll(apiKey, "<API KEY>"), "f");
        tslib_1.__classPrivateFieldSet(this, _ZeroXSwapConnector_timeoutInMs, timeoutInMs, "f");
    }
    getSupportedChains() {
        return Object.values(ZeroXSupportedChainId)
            .filter((v) => typeof v === "number")
            .map((_) => Number(_));
    }
    async getEstimate(request, context) {
        const logger = new swap_connector_logger_1.SwapConnectorLogger(context.logger, ZeroXSwapConnector.name, tslib_1.__classPrivateFieldGet(this, _ZeroXSwapConnector_maskCredentialFunction, "f"));
        if (!this.getSupportedChains().includes(request.chainId)) {
            const message = `Chain ${common_types_1.ChainId[request.chainId]} is not supported`;
            throw new swap_connector_error_1.SwapConnectorError(ZeroXSwapConnector.name, swap_connector_error_type_1.SwapConnectorErrorType.UnsupportedChain, message);
        }
        const params = new URLSearchParams({
            buyToken: tslib_1.__classPrivateFieldGet(this, _ZeroXSwapConnector_instances, "m", _ZeroXSwapConnector_nativeAddressToEvmFormat).call(this, request.toTokenAddress),
            sellToken: tslib_1.__classPrivateFieldGet(this, _ZeroXSwapConnector_instances, "m", _ZeroXSwapConnector_nativeAddressToEvmFormat).call(this, request.fromTokenAddress),
            sellAmount: request.amountIn.toString(),
            skipValidation: "true",
            slippagePercentage: `${(0, swap_connector_1.bpsToPercent)(request.slippageBps) / 100}`,
        });
        if (tslib_1.__classPrivateFieldGet(this, _ZeroXSwapConnector_feeRecipientTradeSurplus, "f")) {
            params.append("feeRecipientTradeSurplus", tslib_1.__classPrivateFieldGet(this, _ZeroXSwapConnector_feeRecipientTradeSurplus, "f"));
        }
        if (tslib_1.__classPrivateFieldGet(this, _ZeroXSwapConnector_customSources, "f")) {
            if (tslib_1.__classPrivateFieldGet(this, _ZeroXSwapConnector_customSources, "f").type === "excluded") {
                params.append("excludedSources", tslib_1.__classPrivateFieldGet(this, _ZeroXSwapConnector_customSources, "f").excluded.join(","));
            }
            else if (tslib_1.__classPrivateFieldGet(this, _ZeroXSwapConnector_customSources, "f").type === "included") {
                params.append("includedSources", tslib_1.__classPrivateFieldGet(this, _ZeroXSwapConnector_customSources, "f").included.join(","));
            }
        }
        const response = await tslib_1.__classPrivateFieldGet(this, _ZeroXSwapConnector_instances, "m", _ZeroXSwapConnector_call0x).call(this, request.chainId, "/swap/v1/quote", params, logger);
        return {
            amountIn: BigInt(response.sellAmount),
            amountOut: BigInt(response.buyAmount),
            chainId: Number(request.chainId),
            fromTokenAddress: tslib_1.__classPrivateFieldGet(this, _ZeroXSwapConnector_instances, "m", _ZeroXSwapConnector_fixEvmNativeAddress).call(this, response.sellTokenAddress),
            toTokenAddress: tslib_1.__classPrivateFieldGet(this, _ZeroXSwapConnector_instances, "m", _ZeroXSwapConnector_fixEvmNativeAddress).call(this, response.buyTokenAddress),
            rawConnectorResponse: response,
        };
    }
    async getSwap(request, context) {
        if (!this.getSupportedChains().includes(request.chainId)) {
            const message = `Chain ${common_types_1.ChainId[request.chainId]} is not supported`;
            throw new swap_connector_error_1.SwapConnectorError(ZeroXSwapConnector.name, swap_connector_error_type_1.SwapConnectorErrorType.UnsupportedChain, message);
        }
        const logger = new swap_connector_logger_1.SwapConnectorLogger(context.logger, ZeroXSwapConnector.name, tslib_1.__classPrivateFieldGet(this, _ZeroXSwapConnector_maskCredentialFunction, "f"));
        const params = new URLSearchParams({
            buyToken: tslib_1.__classPrivateFieldGet(this, _ZeroXSwapConnector_instances, "m", _ZeroXSwapConnector_nativeAddressToEvmFormat).call(this, request.toTokenAddress),
            sellToken: tslib_1.__classPrivateFieldGet(this, _ZeroXSwapConnector_instances, "m", _ZeroXSwapConnector_nativeAddressToEvmFormat).call(this, request.fromTokenAddress),
            sellAmount: request.amountIn.toString(),
            skipValidation: "true",
            takerAddress: solana_utils_1.helpers.bufferToHex(request.fromAddress),
            slippagePercentage: `${(0, swap_connector_1.bpsToPercent)(request.slippageBps) / 100}`,
        });
        if (tslib_1.__classPrivateFieldGet(this, _ZeroXSwapConnector_feeRecipientTradeSurplus, "f")) {
            params.append("feeRecipientTradeSurplus", tslib_1.__classPrivateFieldGet(this, _ZeroXSwapConnector_feeRecipientTradeSurplus, "f"));
        }
        if (tslib_1.__classPrivateFieldGet(this, _ZeroXSwapConnector_customSources, "f")) {
            if (tslib_1.__classPrivateFieldGet(this, _ZeroXSwapConnector_customSources, "f").type === "excluded") {
                params.append("excludedSources", tslib_1.__classPrivateFieldGet(this, _ZeroXSwapConnector_customSources, "f").excluded.join(","));
            }
            else if (tslib_1.__classPrivateFieldGet(this, _ZeroXSwapConnector_customSources, "f").type === "included") {
                params.append("includedSources", tslib_1.__classPrivateFieldGet(this, _ZeroXSwapConnector_customSources, "f").included.join(","));
            }
        }
        const response = await tslib_1.__classPrivateFieldGet(this, _ZeroXSwapConnector_instances, "m", _ZeroXSwapConnector_call0x).call(this, request.chainId, "/swap/v1/quote", params, logger);
        return {
            amountIn: BigInt(response.sellAmount),
            amountOut: BigInt(response.buyAmount),
            engine: "evm",
            tx: {
                data: response.data,
                to: response.to,
                value: response.value,
            },
            fromToken: tslib_1.__classPrivateFieldGet(this, _ZeroXSwapConnector_instances, "m", _ZeroXSwapConnector_fixEvmNativeAddress).call(this, response.sellTokenAddress),
            toToken: tslib_1.__classPrivateFieldGet(this, _ZeroXSwapConnector_instances, "m", _ZeroXSwapConnector_fixEvmNativeAddress).call(this, response.buyTokenAddress),
            rawConnectorResponse: response,
        };
    }
    get connectorName() {
        return "0x";
    }
}
exports.ZeroXSwapConnector = ZeroXSwapConnector;
_ZeroXSwapConnector_URL_PER_CHAIN = new WeakMap(), _ZeroXSwapConnector_apiKey = new WeakMap(), _ZeroXSwapConnector_customSources = new WeakMap(), _ZeroXSwapConnector_maskCredentialFunction = new WeakMap(), _ZeroXSwapConnector_feeRecipientTradeSurplus = new WeakMap(), _ZeroXSwapConnector_timeoutInMs = new WeakMap(), _ZeroXSwapConnector_instances = new WeakSet(), _ZeroXSwapConnector_call0x = async function _ZeroXSwapConnector_call0x(chainId, path, query, logger) {
    try {
        return await this.call({
            basicUrl: tslib_1.__classPrivateFieldGet(this, _ZeroXSwapConnector_instances, "m", _ZeroXSwapConnector_getUrlByChain).call(this, chainId),
            path,
            query,
            headers: {
                "0x-api-key": tslib_1.__classPrivateFieldGet(this, _ZeroXSwapConnector_apiKey, "f"),
            },
            timeoutInMs: tslib_1.__classPrivateFieldGet(this, _ZeroXSwapConnector_timeoutInMs, "f"),
        }, {
            logger,
        });
    }
    catch (e) {
        const error = e;
        throw new swap_connector_error_1.SwapConnectorError(ZeroXSwapConnector.name, swap_connector_error_type_1.SwapConnectorErrorType.InternalError, error.message);
    }
}, _ZeroXSwapConnector_getUrlByChain = function _ZeroXSwapConnector_getUrlByChain(chainId) {
    if (!this.getSupportedChains().includes(chainId)) {
        const message = `Chain ${common_types_1.ChainId[chainId]} is not supported`;
        throw new swap_connector_error_1.SwapConnectorError(ZeroXSwapConnector.name, swap_connector_error_type_1.SwapConnectorErrorType.UnsupportedChain, message);
    }
    const mappedChain = tslib_1.__classPrivateFieldGet(this, _ZeroXSwapConnector_URL_PER_CHAIN, "f")[chainId];
    return `https://${mappedChain}api.0x.org`;
}, _ZeroXSwapConnector_nativeAddressToEvmFormat = function _ZeroXSwapConnector_nativeAddressToEvmFormat(address) {
    let stringified = solana_utils_1.helpers.bufferToHex(address);
    if (stringified === "0x0000000000000000000000000000000000000000") {
        stringified = "0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE";
    }
    return stringified;
}, _ZeroXSwapConnector_fixEvmNativeAddress = function _ZeroXSwapConnector_fixEvmNativeAddress(evmFormat) {
    const evmNative = solana_utils_1.helpers.hexToBuffer("0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE");
    const address = solana_utils_1.helpers.hexToBuffer(evmFormat);
    return address.equals(evmNative) ? Buffer.alloc(20) : address;
};
//# sourceMappingURL=0x.connector.js.map
"use strict";
var _JupiterRouteLimiter_allDexes, _JupiterBase_PRICE_API, _JupiterBase_jupiterAccessToken, _JupiterBase_timeoutInMs, _JupiterConnectorV6_jupiterAPI, _JupiterConnectorV6_maxAccounts, _JupiterConnectorV6_allowRestrictIntermediateTokensFunction, _JupiterConnectorV6_routeLimiter, _JupiterConnectorV4_jupiterAPI;
Object.defineProperty(exports, "__esModule", { value: true });
exports.JupiterConnectorV4 = exports.JupiterConnectorV6 = exports.JupiterRouteLimiter = void 0;
const tslib_1 = require("tslib");
// import { writeFileSync } from "fs";
// import markets from "./markets.json";
const solana_utils_1 = require("@debridge-finance/solana-utils");
const web3_js_1 = require("@solana/web3.js");
const solana_transaction_parser_1 = require("@debridge-finance/solana-transaction-parser");
const common_types_1 = require("../common.types");
const utils_1 = require("../solana/utils");
const ammAlt_json_1 = tslib_1.__importDefault(require("./ammAlt.json"));
const _1 = require(".");
const swap_connector_error_1 = require("./errors/swap-connector.error");
const swap_connector_error_type_1 = require("./errors/swap-connector-error.type");
const swap_connector_logger_1 = require("./swap-connector.logger");
class JupiterRouteLimiter {
    constructor() {
        _JupiterRouteLimiter_allDexes.set(this, [
            "Crema",
            "Saros",
            "Lifinity V2",
            "FluxBeam",
            "Mercurial",
            "Meteora",
            "Phoenix",
            "Saber (Decimals)",
            "Openbook",
            "Orca V1",
            "Oasis",
            "Perps",
            "Helium Network",
            "Cropper",
            "Raydium CLMM",
            "Aldrin",
            "Token Swap",
            "Raydium",
            "GooseFX",
            "Bonkswap",
            "StepN",
            "Invariant",
            "Meteora DLMM",
            "Orca V2",
            "Lifinity V1",
            "Balansol",
            "Saber",
            "Penguin",
            "Jupiter LO",
            "Whirlpool",
            "Marinade",
            "Sanctum",
            "Aldrin V2",
        ]);
    }
    /**
     * Fetches DEXes supported by Jupiter
     * @returns current list of all supported DEXes by jupiter
     */
    async getAllDexes() {
        //TODO: Should use baseURL!
        const result = (await fetch("https://quote-api.jup.ag/v6/program-id-to-label").then((r) => r.json()));
        tslib_1.__classPrivateFieldSet(this, _JupiterRouteLimiter_allDexes, Object.values(result), "f");
        return tslib_1.__classPrivateFieldGet(this, _JupiterRouteLimiter_allDexes, "f");
    }
    /**
     * Exclude list of DEXes from route
     * @param dexesToExclude
     * @returns excludeDexes list
     */
    blacklist(dexesToExclude) {
        return dexesToExclude;
    }
    /**
     * Exclude all except dexesToInclude from route
     * @param dexesToInclude
     * @returns excludeDexes list
     */
    whitelist(dexesToInclude) {
        const result = [];
        for (const dex of tslib_1.__classPrivateFieldGet(this, _JupiterRouteLimiter_allDexes, "f")) {
            if (!dexesToInclude.includes(dex)) {
                result.push(dex);
            }
        }
        return result;
    }
}
exports.JupiterRouteLimiter = JupiterRouteLimiter;
_JupiterRouteLimiter_allDexes = new WeakMap();
/**
 * @internal
 */
class JupiterBase extends _1.SwapConnector {
    constructor(connection, jupiterAccessToken, timeoutInMs) {
        super();
        this.connection = connection;
        this.NATIVE_MINT = "1".repeat(32);
        _JupiterBase_PRICE_API.set(this, "https://price.jup.ag/v3/price");
        _JupiterBase_jupiterAccessToken.set(this, void 0);
        _JupiterBase_timeoutInMs.set(this, void 0);
        tslib_1.__classPrivateFieldSet(this, _JupiterBase_jupiterAccessToken, jupiterAccessToken, "f");
        this.maskCredentialFunction = jupiterAccessToken
            ? (text) => text.replaceAll(jupiterAccessToken, "<API KEY>")
            : (text) => text;
        this.ALTMap = new Map(Object.entries(ammAlt_json_1.default));
        tslib_1.__classPrivateFieldSet(this, _JupiterBase_timeoutInMs, timeoutInMs, "f");
    }
    getSupportedChains() {
        return [common_types_1.ChainId.Solana];
    }
    /** wrapUnwrapSol default is true
     * We might want to set it to false when source/destination token is wrapped sol
     **/
    fixWSolAddress(fromTokenAddress, toTokenAddress) {
        let inputMint = new web3_js_1.PublicKey(fromTokenAddress).toBase58();
        let outputMint = new web3_js_1.PublicKey(toTokenAddress).toBase58();
        let wrapUnwrapSOL = true;
        const wsol = solana_utils_1.WRAPPED_SOL_MINT.toBase58();
        if (inputMint === wsol) {
            wrapUnwrapSOL = false;
        }
        else if (outputMint === wsol) {
            wrapUnwrapSOL = false;
        }
        if (inputMint === this.NATIVE_MINT)
            inputMint = wsol;
        if (outputMint === this.NATIVE_MINT)
            outputMint = wsol;
        return [inputMint, outputMint, wrapUnwrapSOL];
    }
    async filterExistingWallets(connection, wallets) {
        if (wallets.length === 0) {
            return [];
        }
        const accountsInfo = await connection.getMultipleAccountsInfo(wallets);
        const accountExists = (info) => info != null && info.lamports !== 0;
        return accountsInfo.reduce((result, info, idx) => {
            if (accountExists(info) && info?.owner.equals(solana_utils_1.TOKEN_PROGRAM_ID)) {
                result.push(wallets[idx]);
            }
            return result;
        }, []);
    }
    async getTokenPriceInSol(tokenAddress, context) {
        const logger = new swap_connector_logger_1.SwapConnectorLogger(context.logger, JupiterBase.name, this.maskCredentialFunction);
        let token = new web3_js_1.PublicKey(tokenAddress).toBase58();
        if (token === this.NATIVE_MINT)
            token = solana_utils_1.WRAPPED_SOL_MINT.toBase58();
        const queryParams = new URLSearchParams({
            ids: token,
            vsToken: "So11111111111111111111111111111111111111112",
        });
        const response = await this.callJupiter(tslib_1.__classPrivateFieldGet(this, _JupiterBase_PRICE_API, "f"), tslib_1.__classPrivateFieldGet(this, _JupiterBase_PRICE_API, "f"), queryParams, logger);
        if (response === null)
            throw new swap_connector_error_1.SwapConnectorError(JupiterBase.name, swap_connector_error_type_1.SwapConnectorErrorType.InternalError, `Failed to get price for token: ${token}`);
        logger.verbose("getTokenPriceInSol res:", JSON.stringify(response));
        return response.data[token]?.price;
    }
    async callJupiter(basicUrl, path, query, logger, body) {
        let method = "GET";
        const headers = {};
        if (body) {
            method = "POST";
            headers["Content-Type"] = "application/json";
        }
        if (tslib_1.__classPrivateFieldGet(this, _JupiterBase_jupiterAccessToken, "f")) {
            query.append("token", tslib_1.__classPrivateFieldGet(this, _JupiterBase_jupiterAccessToken, "f"));
        }
        try {
            return await this.call({
                basicUrl,
                path,
                query,
                headers,
                method,
                body,
                timeoutInMs: tslib_1.__classPrivateFieldGet(this, _JupiterBase_timeoutInMs, "f"),
            }, {
                logger,
            });
        }
        catch (e) {
            const error = e;
            throw new swap_connector_error_1.SwapConnectorError(JupiterBase.name, swap_connector_error_type_1.SwapConnectorErrorType.InternalError, error.message);
        }
    }
}
_JupiterBase_PRICE_API = new WeakMap(), _JupiterBase_jupiterAccessToken = new WeakMap(), _JupiterBase_timeoutInMs = new WeakMap();
class JupiterConnectorV6 extends JupiterBase {
    constructor(config) {
        super(config.connection, config.jupiterAccessToken, config.timeoutInMs);
        _JupiterConnectorV6_jupiterAPI.set(this, void 0);
        _JupiterConnectorV6_maxAccounts.set(this, void 0);
        _JupiterConnectorV6_allowRestrictIntermediateTokensFunction.set(this, void 0);
        _JupiterConnectorV6_routeLimiter.set(this, void 0);
        tslib_1.__classPrivateFieldSet(this, _JupiterConnectorV6_jupiterAPI, config.customApiURL || "https://quote-api.jup.ag/v6", "f");
        tslib_1.__classPrivateFieldSet(this, _JupiterConnectorV6_maxAccounts, config.maxAccounts, "f");
        tslib_1.__classPrivateFieldSet(this, _JupiterConnectorV6_routeLimiter, config.routeLimiter, "f");
        tslib_1.__classPrivateFieldSet(this, _JupiterConnectorV6_allowRestrictIntermediateTokensFunction, config.allowRestrictIntermediateTokensFunction, "f");
    }
    setMaxAccounts(count) {
        tslib_1.__classPrivateFieldSet(this, _JupiterConnectorV6_maxAccounts, count, "f");
    }
    /*
    calculateMaxAccounts(mode: "create" | "fulfill", tokenFrom: Address, tokenTo: Address, hasCalldata: boolean): number {
      const stringifiedAddress = new PublicKey(tokenTo).toBase58();
      const isSol = stringifiedAddress === this.NATIVE_MINT;
      const isWSol = stringifiedAddress === WRAPPED_SOL_MINT.toBase58();
      if (hasCalldata) {
        if (isSol) {
          return 16;
        } else if (isWSol) {
          return 16;
        } else {
          return 18;
        }
      } else {
        if (isSol) {
          return 16;
        } else if (isWSol) {
          return 16;
        } else {
          return 18;
        }
      }
    }
    */
    async getEstimate(request, context) {
        if (!this.getSupportedChains().includes(request.chainId)) {
            const message = `Chain ${common_types_1.ChainId[request.chainId]} is not supported`;
            throw new swap_connector_error_1.SwapConnectorError(JupiterConnectorV6.name, swap_connector_error_type_1.SwapConnectorErrorType.UnsupportedChain, message);
        }
        const [inputMint, outputMint, wrapUnwrapSOL] = this.fixWSolAddress(request.fromTokenAddress, request.toTokenAddress);
        const queryParams = new URLSearchParams({
            inputMint,
            outputMint,
            swapMode: "ExactIn",
            wrapAndUnwrapSol: wrapUnwrapSOL.toString(),
            slippageBps: request.slippageBps.toString(),
            amount: request.amountIn.toString(),
        });
        const excludedDexes = (await tslib_1.__classPrivateFieldGet(this, _JupiterConnectorV6_routeLimiter, "f")?.getExcludedDexes(request)) ?? [];
        if (excludedDexes.length > 0) {
            queryParams.set("excludeDexes", excludedDexes.join(","));
        }
        if (request.affiliateFeeBps !== undefined) {
            queryParams.set("platformFeeBps", request.affiliateFeeBps.toString());
        }
        if (tslib_1.__classPrivateFieldGet(this, _JupiterConnectorV6_maxAccounts, "f")) {
            queryParams.set("maxAccounts", tslib_1.__classPrivateFieldGet(this, _JupiterConnectorV6_maxAccounts, "f").toString());
        }
        if (tslib_1.__classPrivateFieldGet(this, _JupiterConnectorV6_allowRestrictIntermediateTokensFunction, "f") !== undefined) {
            queryParams.set("restrictIntermediateTokens", tslib_1.__classPrivateFieldGet(this, _JupiterConnectorV6_allowRestrictIntermediateTokensFunction, "f").call(this, request).toString());
        }
        const logger = new swap_connector_logger_1.SwapConnectorLogger(context.logger, JupiterConnectorV6.name, this.maskCredentialFunction);
        const response = await this.callJupiter(tslib_1.__classPrivateFieldGet(this, _JupiterConnectorV6_jupiterAPI, "f"), `/quote`, queryParams, logger);
        const result = {
            amountIn: request.amountIn,
            amountOut: BigInt(response.outAmount),
            chainId: common_types_1.ChainId.Solana,
            fromTokenAddress: request.fromTokenAddress,
            toTokenAddress: request.toTokenAddress,
            rawConnectorResponse: {
                ...response,
                wrapAndUnwrapSol: wrapUnwrapSOL,
            },
        };
        return result;
    }
    async getSwap(request, context) {
        if (!this.getSupportedChains().includes(request.chainId)) {
            const message = `Chain ${common_types_1.ChainId[request.chainId]} is not supported`;
            throw new swap_connector_error_1.SwapConnectorError(JupiterConnectorV6.name, swap_connector_error_type_1.SwapConnectorErrorType.UnsupportedChain, message);
        }
        const logger = new swap_connector_logger_1.SwapConnectorLogger(context.logger, JupiterConnectorV6.name, this.maskCredentialFunction);
        if (!request.fromAddress)
            throw new swap_connector_error_1.SwapConnectorError(JupiterConnectorV6.name, swap_connector_error_type_1.SwapConnectorErrorType.InputValidationError, "From address is required for solana swaps");
        if ((request.affiliateFeeBps === undefined && request.affiliateFeeRecipient !== undefined) ||
            (request.affiliateFeeBps !== undefined && request.affiliateFeeRecipient === undefined)) {
            throw new swap_connector_error_1.SwapConnectorError(JupiterConnectorV6.name, swap_connector_error_type_1.SwapConnectorErrorType.InputValidationError, "only one of affiliateFeeRecipient & affiliateFeeBps params is set, both required");
        }
        let feeAccount = null;
        const prefixInstructions = [];
        if (request.affiliateFeeRecipient) {
            const [, tokenOut] = this.fixWSolAddress(request.fromTokenAddress, request.toTokenAddress);
            const realSwapTokenOut = new web3_js_1.PublicKey(tokenOut);
            const refPubkey = new web3_js_1.PublicKey("REFER4ZgmyYx9c6He5XfaTMiGfdLwRnkV4RPp9t9iF3");
            const feeBeneficiar = new web3_js_1.PublicKey(request.affiliateFeeRecipient);
            // get the feeAccount.
            [feeAccount] = web3_js_1.PublicKey.findProgramAddressSync([
                Buffer.from("referral_ata"),
                request.affiliateFeeRecipient,
                realSwapTokenOut.toBuffer(), // the token mint, output mint for ExactIn, input mint for ExactOut.
            ], refPubkey);
            const [beneficiarInfo, feeAccountInfo] = await this.connection.getMultipleAccountsInfo([
                feeBeneficiar,
                feeAccount,
            ]);
            if (!beneficiarInfo || beneficiarInfo.lamports === 0) {
                throw new Error(`Fee beneficiar is not initialized, please check jupiter fee docs`);
            }
            if (!feeAccountInfo || feeAccountInfo?.lamports === 0) {
                prefixInstructions.push(new web3_js_1.TransactionInstruction({
                    programId: refPubkey,
                    keys: [
                        {
                            //name: "payer";
                            pubkey: new web3_js_1.PublicKey(request.fromAddress),
                            isWritable: true,
                            isSigner: true,
                        },
                        {
                            // name: "project",
                            pubkey: new web3_js_1.PublicKey("45ruCyfdRkWpRNGEqWzjCiXRHkZs8WXCLQ67Pnpye7Hp"),
                            isWritable: false,
                            isSigner: false,
                        },
                        {
                            //name: "referralAccount";
                            pubkey: feeBeneficiar,
                            isWritable: false,
                            isSigner: false,
                        },
                        {
                            //name: "referralTokenAccount";
                            pubkey: feeAccount,
                            isWritable: true,
                            isSigner: false,
                        },
                        {
                            //name: "mint",
                            pubkey: realSwapTokenOut,
                            isWritable: false,
                            isSigner: false,
                        },
                        {
                            //name: "systemProgram",
                            pubkey: web3_js_1.SystemProgram.programId,
                            isWritable: false,
                            isSigner: false,
                        },
                        {
                            pubkey: solana_utils_1.TOKEN_PROGRAM_ID,
                            isWritable: false,
                            isSigner: false,
                        },
                    ],
                    data: Buffer.from("7d12465f56b3ddbe", "hex"), // Referral: Initialize Referral Token Account
                }));
            }
        }
        const estimate = request.routeHint ?? (await this.getEstimate(request, context));
        const quoteResponse = estimate.rawConnectorResponse;
        // override quote's slippage with the new value
        quoteResponse.slippageBps = request.slippageBps;
        const swapRequest = {
            quoteResponse,
            wrapAndUnwrapSol: quoteResponse.wrapAndUnwrapSol,
            userPublicKey: new web3_js_1.PublicKey(request.fromAddress).toBase58(),
            feeAccount: feeAccount ? feeAccount.toBase58() : undefined,
        };
        const response = await this.callJupiter(tslib_1.__classPrivateFieldGet(this, _JupiterConnectorV6_jupiterAPI, "f"), `/swap`, new URLSearchParams(), logger, JSON.stringify(swapRequest));
        const vtx = web3_js_1.VersionedTransaction.deserialize(Buffer.from(response.swapTransaction, "base64"));
        const ALTs = vtx.message.addressTableLookups.map((alt) => alt.accountKey);
        const fetchedALTs = await this.connection.getMultipleAccountsInfo(ALTs);
        const parsedALTs = fetchedALTs
            .map((fetched, i) => fetched
            ? new web3_js_1.AddressLookupTableAccount({ state: web3_js_1.AddressLookupTableAccount.deserialize(fetched.data), key: ALTs[i] })
            : null)
            .filter((x) => x != null);
        const parsedAccountsForTx = (0, solana_transaction_parser_1.parseTransactionAccounts)(vtx.message, (0, utils_1.parseALT)(vtx.message, parsedALTs));
        const instructions = vtx.message.compiledInstructions.map((ci) => (0, solana_transaction_parser_1.compiledInstructionToInstruction)(ci, parsedAccountsForTx));
        const priorityFeeIxs = context.removePriorityFeeIxs ?? true
            ? []
            : instructions.filter((ix) => ix.programId.equals(web3_js_1.ComputeBudgetProgram.programId));
        const filtered = instructions.filter((ix) => !ix.programId.equals(web3_js_1.ComputeBudgetProgram.programId));
        const result = {
            amountIn: request.amountIn,
            amountOut: BigInt(quoteResponse.outAmount),
            fromToken: request.fromTokenAddress,
            toToken: request.toTokenAddress,
            engine: "solana",
            swapInstructions: [...priorityFeeIxs, ...prefixInstructions, ...filtered],
            ALTs: parsedALTs,
            rawConnectorResponse: response,
            prioritizationFeeLamports: response.prioritizationFeeLamports,
        };
        return result;
    }
    get connectorName() {
        return "jupiter-v6";
    }
}
exports.JupiterConnectorV6 = JupiterConnectorV6;
_JupiterConnectorV6_jupiterAPI = new WeakMap(), _JupiterConnectorV6_maxAccounts = new WeakMap(), _JupiterConnectorV6_allowRestrictIntermediateTokensFunction = new WeakMap(), _JupiterConnectorV6_routeLimiter = new WeakMap();
class JupiterConnectorV4 extends JupiterBase {
    constructor(connection, routeFilter = () => true, customApiURL, jupiterAccessToken, timeoutInMs) {
        super(connection, jupiterAccessToken, timeoutInMs);
        this.routeFilter = routeFilter;
        _JupiterConnectorV4_jupiterAPI.set(this, void 0);
        tslib_1.__classPrivateFieldSet(this, _JupiterConnectorV4_jupiterAPI, customApiURL || "https://quote-api.jup.ag/v4", "f");
    }
    async getEstimate(request, context) {
        if (!this.getSupportedChains().includes(request.chainId)) {
            const message = `Chain ${common_types_1.ChainId[request.chainId]} is not supported`;
            throw new swap_connector_error_1.SwapConnectorError(JupiterConnectorV4.name, swap_connector_error_type_1.SwapConnectorErrorType.UnsupportedChain, message);
        }
        const [inputMint, outputMint, wrapUnwrapSOL] = this.fixWSolAddress(request.fromTokenAddress, request.toTokenAddress);
        const queryParams = new URLSearchParams({
            inputMint,
            outputMint,
            swapMode: "ExactIn",
            wrapUnwrapSOL: wrapUnwrapSOL.toString(),
            slippageBps: (request?.slippageBps || 100).toString(),
            amount: request.amountIn.toString(),
        });
        const logger = new swap_connector_logger_1.SwapConnectorLogger(context.logger, JupiterConnectorV4.name, this.maskCredentialFunction);
        const quoteResponse = await this.callJupiter(tslib_1.__classPrivateFieldGet(this, _JupiterConnectorV4_jupiterAPI, "f"), `/quote`, queryParams, logger);
        const blacklist = ["serum"];
        const filtered = quoteResponse.data
            .filter(this.routeFilter)
            .filter((iroute) => iroute.marketInfos.find((market) => {
            // iterate over all route markets, try to find bad routes
            const label = market.label.toLowerCase();
            return blacklist.filter((item) => label.includes(item)).length !== 0; // check if market is in the blacklist
        }) === undefined)
            .map((okRoute) => ({ ...okRoute, wrapUnwrapSOL }));
        // allowed routes not found
        if (filtered.length === 0)
            throw new swap_connector_error_1.SwapConnectorError(JupiterConnectorV4.name, swap_connector_error_type_1.SwapConnectorErrorType.InternalError, `Failed to get swap routes for: ${inputMint} -> ${outputMint}`);
        return {
            amountIn: request.amountIn,
            amountOut: BigInt(filtered[0].outAmount),
            chainId: common_types_1.ChainId.Solana,
            fromTokenAddress: request.fromTokenAddress,
            toTokenAddress: request.toTokenAddress,
            rawConnectorResponse: filtered,
        };
    }
    async getSwap(request, context) {
        if (!this.getSupportedChains().includes(request.chainId)) {
            const message = `Chain ${common_types_1.ChainId[request.chainId]} is not supported`;
            throw new swap_connector_error_1.SwapConnectorError(JupiterConnectorV4.name, swap_connector_error_type_1.SwapConnectorErrorType.UnsupportedChain, message);
        }
        const quote = await this.getEstimate(request, context);
        const routes = quote.rawConnectorResponse;
        const route = routes[0];
        const requestData = {
            route,
            userPublicKey: new web3_js_1.PublicKey(request.fromAddress).toBase58(),
            wrapUnwrapSOL: route.wrapUnwrapSOL,
        };
        const logger = new swap_connector_logger_1.SwapConnectorLogger(context.logger, JupiterConnectorV4.name, this.maskCredentialFunction);
        const response = await this.callJupiter(tslib_1.__classPrivateFieldGet(this, _JupiterConnectorV4_jupiterAPI, "f"), "/swap", new URLSearchParams(), logger, JSON.stringify(requestData));
        const versionedTxs = [response?.setupTransaction, response.swapTransaction, response?.cleanupTransaction]
            .filter((serialized) => serialized !== undefined && serialized !== "")
            .map((serialized) => web3_js_1.VersionedTransaction.deserialize(Buffer.from(serialized, "base64")))
            .flatMap((tx) => tx);
        const computeBudgetProgramId = "ComputeBudget111111111111111111111111111111";
        const ALTs = versionedTxs.flatMap((vtx) => vtx.message.addressTableLookups.map((alt) => alt.accountKey));
        const fetchedALTs = await this.connection.getMultipleAccountsInfo(ALTs);
        const parsedALTs = fetchedALTs
            .map((fetched, i) => fetched
            ? new web3_js_1.AddressLookupTableAccount({ state: web3_js_1.AddressLookupTableAccount.deserialize(fetched.data), key: ALTs[i] })
            : null)
            .filter((x) => x != null);
        const loadedAddressesForTx = versionedTxs.map((vtx) => (0, utils_1.parseALT)(vtx.message, parsedALTs));
        const parsedAccountsForTx = versionedTxs.map((vtx, i) => (0, solana_transaction_parser_1.parseTransactionAccounts)(vtx.message, loadedAddressesForTx[i]));
        const instructions = versionedTxs.flatMap((vtx, txI) => vtx.message.compiledInstructions.map((ci) => (0, solana_transaction_parser_1.compiledInstructionToInstruction)(ci, parsedAccountsForTx[txI])));
        const filtered = instructions.filter((ix) => ix.programId.toBase58() !== computeBudgetProgramId);
        // Enrich ALTs by marketId alt map
        const ALTsFromTx = ALTs.map((pk) => pk.toBase58());
        const ALTsByIds = route.marketInfos
            .flatMap((info) => info.id.split("-"))
            .map((id) => this.ALTMap.get(id))
            .filter((addr) => addr !== undefined);
        const totlaALTs = Array.from(new Set([...ALTsByIds, ...ALTsFromTx]).values());
        const result = {
            ALTs: totlaALTs.map((alt) => new web3_js_1.PublicKey(alt)),
            amountIn: BigInt(route.amount),
            amountOut: BigInt(route.outAmount),
            fromToken: request.fromTokenAddress,
            toToken: request.toTokenAddress,
            swapInstructions: filtered,
            engine: "solana",
            rawConnectorResponse: response,
            prioritizationFeeLamports: 1000,
        };
        return result;
    }
    get connectorName() {
        return "jupiter-v4";
    }
}
exports.JupiterConnectorV4 = JupiterConnectorV4;
_JupiterConnectorV4_jupiterAPI = new WeakMap();
//# sourceMappingURL=jupiter.connector.js.map
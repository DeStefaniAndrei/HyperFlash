"use strict";
var _OneInchV4Connector_instances, _a, _OneInchV4Connector_inchAPI, _OneInchV4Connector_SUPPORTED_CHAINS, _OneInchV4Connector__protocols, _OneInchV4Connector_disablePMMProtocols, _OneInchV4Connector_disabledProtocols, _OneInchV4Connector_maskCredentialFunction, _OneInchV4Connector_get1inchProtocols, _OneInchV4Connector_unwindProtocols, _OneInchV4Connector_fix1inchNativeAddress, _OneInchV4Connector_callOneInch, _OneInchV4Connector_filterProtocols, _OneInchV4Connector_getProtocols;
Object.defineProperty(exports, "__esModule", { value: true });
exports.OneInchV4Connector = void 0;
const tslib_1 = require("tslib");
const solana_utils_1 = require("@debridge-finance/solana-utils");
const common_types_1 = require("../common.types");
const utils_1 = require("../utils");
const swap_connector_1 = require("./swap.connector");
const swap_connector_error_1 = require("./errors/swap-connector.error");
const swap_connector_logger_1 = require("./swap-connector.logger");
const swap_connector_error_type_1 = require("./errors/swap-connector-error.type");
var Verb;
(function (Verb) {
    Verb[Verb["quote"] = 0] = "quote";
    Verb[Verb["swap"] = 1] = "swap";
    Verb[Verb["liquidity-sources"] = 2] = "liquidity-sources";
})(Verb || (Verb = {}));
/**
 * @internal
 */
class OneInchV4Connector extends swap_connector_1.SwapConnector {
    constructor(customApiURL, disablePMMProtocols = true, disabledProtocols = []) {
        super();
        _OneInchV4Connector_instances.add(this);
        _OneInchV4Connector_inchAPI.set(this, void 0);
        _OneInchV4Connector_SUPPORTED_CHAINS.set(this, [
            common_types_1.ChainId.Arbitrum,
            common_types_1.ChainId.Avalanche,
            common_types_1.ChainId.BSC,
            common_types_1.ChainId.Polygon,
            common_types_1.ChainId.Ethereum,
            common_types_1.ChainId.Fantom,
            common_types_1.ChainId.Optimism,
        ]);
        _OneInchV4Connector_disablePMMProtocols.set(this, true);
        _OneInchV4Connector_disabledProtocols.set(this, []);
        _OneInchV4Connector_maskCredentialFunction.set(this, void 0);
        tslib_1.__classPrivateFieldSet(this, _OneInchV4Connector_disablePMMProtocols, disablePMMProtocols, "f");
        tslib_1.__classPrivateFieldSet(this, _OneInchV4Connector_disabledProtocols, disabledProtocols, "f");
        tslib_1.__classPrivateFieldSet(this, _OneInchV4Connector_inchAPI, customApiURL || "https://api.1inch.io", "f");
        tslib_1.__classPrivateFieldSet(this, _OneInchV4Connector_maskCredentialFunction, (text) => text, "f");
    }
    getSupportedChains() {
        return tslib_1.__classPrivateFieldGet(this, _OneInchV4Connector_SUPPORTED_CHAINS, "f");
    }
    async getLPs(chainId, context) {
        const logger = new swap_connector_logger_1.SwapConnectorLogger(context.logger, OneInchV4Connector.name, tslib_1.__classPrivateFieldGet(this, _OneInchV4Connector_maskCredentialFunction, "f"));
        const result = await tslib_1.__classPrivateFieldGet(this, _OneInchV4Connector_instances, "m", _OneInchV4Connector_callOneInch).call(this, chainId, Verb["liquidity-sources"], new URLSearchParams(), logger);
        return result;
    }
    async getEstimate(request, context) {
        const logger = new swap_connector_logger_1.SwapConnectorLogger(context.logger, OneInchV4Connector.name, tslib_1.__classPrivateFieldGet(this, _OneInchV4Connector_maskCredentialFunction, "f"));
        if (!this.getSupportedChains().includes(request.chainId)) {
            const message = `Chain ${common_types_1.ChainId[request.chainId]} is not supported`;
            throw new swap_connector_error_1.SwapConnectorError(OneInchV4Connector.name, swap_connector_error_type_1.SwapConnectorErrorType.UnsupportedChain, message);
        }
        const slippageBps = request.affiliateFeeBps ? (0, swap_connector_1.bpsToPercent)(request.affiliateFeeBps) : 0;
        let protocols = tslib_1.__classPrivateFieldGet(this, _OneInchV4Connector_instances, "m", _OneInchV4Connector_get1inchProtocols).call(this, request.routeHint) || [];
        if (protocols.length === 0) {
            const protocolsFrom1inch = await tslib_1.__classPrivateFieldGet(this, _OneInchV4Connector_instances, "m", _OneInchV4Connector_getProtocols).call(this, request.chainId, context);
            protocols = tslib_1.__classPrivateFieldGet(this, _OneInchV4Connector_instances, "m", _OneInchV4Connector_filterProtocols).call(this, protocolsFrom1inch);
        }
        const quoteRequest = {
            fromTokenAddress: tslib_1.__classPrivateFieldGet(this, _OneInchV4Connector_instances, "m", _OneInchV4Connector_fix1inchNativeAddress).call(this, request.chainId, request.fromTokenAddress),
            toTokenAddress: tslib_1.__classPrivateFieldGet(this, _OneInchV4Connector_instances, "m", _OneInchV4Connector_fix1inchNativeAddress).call(this, request.chainId, request.toTokenAddress),
            amount: request.amountIn,
            protocols,
            fee: slippageBps,
        };
        const query = new URLSearchParams({
            amount: quoteRequest.amount.toString(),
            fee: (quoteRequest.fee || 0).toString(),
            fromTokenAddress: quoteRequest.fromTokenAddress,
            toTokenAddress: quoteRequest.toTokenAddress,
            protocols: quoteRequest.protocols?.join(",") || "",
        });
        const response = await tslib_1.__classPrivateFieldGet(this, _OneInchV4Connector_instances, "m", _OneInchV4Connector_callOneInch).call(this, request.chainId, Verb.quote, query, logger);
        const result = {
            amountIn: BigInt(response.fromTokenAmount),
            chainId: request.chainId,
            fromTokenAddress: solana_utils_1.helpers.hexToBuffer(response.fromToken.address),
            toTokenAddress: solana_utils_1.helpers.hexToBuffer(response.toToken.address),
            slippageBps,
            amountOut: BigInt(response.toTokenAmount),
            rawConnectorResponse: response,
        };
        return result;
    }
    async getSwap(request, context) {
        const logger = new swap_connector_logger_1.SwapConnectorLogger(context.logger, OneInchV4Connector.name, tslib_1.__classPrivateFieldGet(this, _OneInchV4Connector_maskCredentialFunction, "f"));
        if (!request.destReceiver)
            throw new swap_connector_error_1.SwapConnectorError(OneInchV4Connector.name, swap_connector_error_type_1.SwapConnectorErrorType.InputValidationError, `1InchMissingDestReceiver`);
        if (!this.getSupportedChains().includes(request.chainId)) {
            const message = `Chain ${common_types_1.ChainId[request.chainId]} is not supported`;
            throw new swap_connector_error_1.SwapConnectorError(OneInchV4Connector.name, swap_connector_error_type_1.SwapConnectorErrorType.UnsupportedChain, message);
        }
        let protocols = tslib_1.__classPrivateFieldGet(this, _OneInchV4Connector_instances, "m", _OneInchV4Connector_get1inchProtocols).call(this, request.routeHint) || [];
        if (protocols.length === 0) {
            const protocolsFrom1inch = await tslib_1.__classPrivateFieldGet(this, _OneInchV4Connector_instances, "m", _OneInchV4Connector_getProtocols).call(this, request.chainId, context);
            protocols = tslib_1.__classPrivateFieldGet(this, _OneInchV4Connector_instances, "m", _OneInchV4Connector_filterProtocols).call(this, protocolsFrom1inch);
        }
        const swapRequest = {
            fromTokenAddress: tslib_1.__classPrivateFieldGet(this, _OneInchV4Connector_instances, "m", _OneInchV4Connector_fix1inchNativeAddress).call(this, request.chainId, request.fromTokenAddress),
            toTokenAddress: tslib_1.__classPrivateFieldGet(this, _OneInchV4Connector_instances, "m", _OneInchV4Connector_fix1inchNativeAddress).call(this, request.chainId, request.toTokenAddress),
            amount: request.amountIn,
            fromAddress: (0, utils_1.tokenAddressToString)(request.chainId, request.fromAddress),
            destReceiver: request.destReceiver ? (0, utils_1.tokenAddressToString)(request.chainId, request.destReceiver) : undefined,
            slippage: (0, swap_connector_1.bpsToPercent)(request.slippageBps) || 0,
            disableEstimate: true,
            protocols,
            referrerAddress: request.affiliateFeeRecipient
                ? (0, utils_1.tokenAddressToString)(request.chainId, request.affiliateFeeRecipient)
                : "",
            fee: request.affiliateFeeBps ? (0, swap_connector_1.bpsToPercent)(request.affiliateFeeBps) : 0,
        };
        const query = new URLSearchParams({
            fromTokenAddress: swapRequest.fromTokenAddress,
            toTokenAddress: swapRequest.toTokenAddress,
            amount: swapRequest.amount.toString(),
            destReceiver: swapRequest.destReceiver,
            disableEstimate: swapRequest.disableEstimate ? "true" : "false",
            fee: (swapRequest.fee || 0).toString(),
            protocols: swapRequest.protocols?.join(",") || "",
            fromAddress: swapRequest.fromAddress,
            referrerAddress: swapRequest.referrerAddress ?? "",
            slippage: swapRequest.slippage.toString(),
        });
        const response = await tslib_1.__classPrivateFieldGet(this, _OneInchV4Connector_instances, "m", _OneInchV4Connector_callOneInch).call(this, request.chainId, Verb.swap, query, logger);
        const result = {
            amountIn: request.amountIn,
            fromToken: request.fromTokenAddress,
            toToken: request.toTokenAddress,
            amountOut: BigInt(response.toTokenAmount),
            rawConnectorResponse: response,
            tx: response.tx,
            engine: "evm",
        };
        return result;
    }
    setDisabledProtocols(disabledProtocols) {
        tslib_1.__classPrivateFieldSet(this, _OneInchV4Connector_disabledProtocols, disabledProtocols, "f");
    }
    get connectorName() {
        return "oneinch-v4";
    }
}
exports.OneInchV4Connector = OneInchV4Connector;
_a = OneInchV4Connector, _OneInchV4Connector_inchAPI = new WeakMap(), _OneInchV4Connector_SUPPORTED_CHAINS = new WeakMap(), _OneInchV4Connector_disablePMMProtocols = new WeakMap(), _OneInchV4Connector_disabledProtocols = new WeakMap(), _OneInchV4Connector_maskCredentialFunction = new WeakMap(), _OneInchV4Connector_instances = new WeakSet(), _OneInchV4Connector_get1inchProtocols = function _OneInchV4Connector_get1inchProtocols(preference) {
    if (!preference?.rawConnectorResponse)
        return [];
    const payload = preference.rawConnectorResponse;
    return tslib_1.__classPrivateFieldGet(this, _OneInchV4Connector_instances, "m", _OneInchV4Connector_unwindProtocols).call(this, payload.protocols || []);
}, _OneInchV4Connector_unwindProtocols = function _OneInchV4Connector_unwindProtocols(protocols) {
    return protocols.map((p) => {
        if (Array.isArray(p))
            return tslib_1.__classPrivateFieldGet(this, _OneInchV4Connector_instances, "m", _OneInchV4Connector_unwindProtocols).call(this, p);
        else
            return p.name;
    });
}, _OneInchV4Connector_fix1inchNativeAddress = function _OneInchV4Connector_fix1inchNativeAddress(chainId, token) {
    let address = (0, utils_1.tokenAddressToString)(chainId, token);
    if (address === "0x0000000000000000000000000000000000000000") {
        address = "0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE";
    }
    return address;
}, _OneInchV4Connector_callOneInch = async function _OneInchV4Connector_callOneInch(chainId, verb, query, logger) {
    try {
        return await this.call({
            basicUrl: tslib_1.__classPrivateFieldGet(this, _OneInchV4Connector_inchAPI, "f"),
            path: `/v4.0/${chainId}/${Verb[verb]}`,
            query,
            headers: {},
        }, {
            logger,
        });
    }
    catch (e) {
        const error = e;
        let message = error.message;
        if (message.startsWith("cannot sync")) {
            const tokenAddress = message.replace("cannot sync", "").trim();
            const chainName = common_types_1.ChainId[chainId];
            message = `token ${tokenAddress} is not known on the ${chainName} chain`;
        }
        const errorMessage = `${this.connectorName}::${Verb[verb]} returned ${error.status}: ${message}`;
        throw new swap_connector_error_1.SwapConnectorError(OneInchV4Connector.name, swap_connector_error_type_1.SwapConnectorErrorType.InternalError, errorMessage);
    }
}, _OneInchV4Connector_filterProtocols = function _OneInchV4Connector_filterProtocols(protocols) {
    const filteredProtocols = protocols.filter((protocol) => !tslib_1.__classPrivateFieldGet(this, _OneInchV4Connector_disabledProtocols, "f").includes(protocol));
    if (tslib_1.__classPrivateFieldGet(this, _OneInchV4Connector_disablePMMProtocols, "f")) {
        return filteredProtocols.filter((p) => !p.includes("PMM")).filter((p) => !p.includes("ONE_INCH_LIMIT_ORDER"));
    }
    return filteredProtocols;
}, _OneInchV4Connector_getProtocols = async function _OneInchV4Connector_getProtocols(chainId, context) {
    if (!tslib_1.__classPrivateFieldGet(OneInchV4Connector, _a, "f", _OneInchV4Connector__protocols)[chainId]) {
        const lps = await this.getLPs(chainId, context);
        tslib_1.__classPrivateFieldGet(OneInchV4Connector, _a, "f", _OneInchV4Connector__protocols)[chainId] = lps.protocols.map((p) => p.id);
    }
    return tslib_1.__classPrivateFieldGet(OneInchV4Connector, _a, "f", _OneInchV4Connector__protocols)[chainId];
};
_OneInchV4Connector__protocols = { value: {} };
//# sourceMappingURL=one.inch.v4.connector.js.map
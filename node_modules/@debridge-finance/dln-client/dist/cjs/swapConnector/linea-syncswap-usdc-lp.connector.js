"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LineaSyncSwapUsdcLP = void 0;
const tslib_1 = require("tslib");
const viem = tslib_1.__importStar(require("viem"));
const common_types_1 = require("../common.types");
const utils_1 = require("../utils");
const swap_connector_1 = require("./swap.connector");
const SyncSwapClassicPool_abi_1 = require("./assets/SyncSwapClassicPool.abi");
const SyncSwapRouter_abi_1 = require("./assets/SyncSwapRouter.abi");
const SyncSwapRouterAddress = "0x80e38291e06339d10AAB483C65695D004dBD5C69";
const SyncSwapPoolFactory = "0x37BAc764494c8db4e54BDE72f6965beA9fa0AC2d";
const SyncSwapUSDCWETHPool = "0x5Ec5b1E9b1Bd5198343ABB6E55Fb695d2F7Bb308";
const quoteTTL = 600n; // 10min
const UsdcAddress = "0x176211869ca2b568f2a7d4ee941e073a821ee1ff";
const UsdcAddressBuf = (0, utils_1.tokenStringToBuffer)(common_types_1.ChainId.Linea, UsdcAddress);
const wEthAddress = "0xe5d7c2a44ffddf6b295a15c148167daaaf5cf34f";
const wEthAddressBuf = (0, utils_1.tokenStringToBuffer)(common_types_1.ChainId.Linea, wEthAddress);
const EthAddressBuf = Buffer.alloc(20, 0);
const supportedTokens = [UsdcAddressBuf, wEthAddressBuf];
function getPath(tokenIn, tokenOut) {
    tokenIn = (0, utils_1.buffersAreEqual)(tokenIn, EthAddressBuf) ? wEthAddressBuf : tokenIn;
    tokenOut = (0, utils_1.buffersAreEqual)(tokenIn, EthAddressBuf) ? wEthAddressBuf : tokenOut;
    const index1 = supportedTokens.findIndex((v) => (0, utils_1.buffersAreEqual)(v, tokenIn));
    const index2 = supportedTokens.findIndex((v) => (0, utils_1.buffersAreEqual)(v, tokenOut));
    if (index2 > index1) {
        return supportedTokens.slice(index1, index2 + 1);
    }
    return supportedTokens.slice(index2, index1 + 1).reverse();
}
function checkTokens(tokenIn, tokenOut) {
    const hasTokenIn = undefined !== supportedTokens.find((v) => (0, utils_1.buffersAreEqual)(v, tokenIn));
    const hasTokenOut = undefined !== supportedTokens.find((v) => (0, utils_1.buffersAreEqual)(v, tokenOut));
    const areEqual = (0, utils_1.buffersAreEqual)(tokenIn, tokenOut);
    if (areEqual)
        throw new Error(`In and out tokens are equal`);
    if (!hasTokenIn)
        throw new Error(`Unsupported input token (${(0, utils_1.tokenAddressToString)(common_types_1.ChainId.Linea, tokenIn)})`);
    if (!hasTokenOut)
        throw new Error(`Unsupported output token (${(0, utils_1.tokenAddressToString)(common_types_1.ChainId.Linea, tokenOut)})`);
}
function normalizeTokens(tokenIn, tokenOut) {
    const hasInputETH = (0, utils_1.buffersAreEqual)(tokenIn, EthAddressBuf);
    const hasOutputETH = (0, utils_1.buffersAreEqual)(tokenOut, EthAddressBuf);
    const normalizedTokens = {
        tokenInBuffer: hasInputETH ? wEthAddressBuf : tokenIn,
        tokenOutBuffer: hasOutputETH ? wEthAddressBuf : tokenOut,
        inputETH: hasInputETH,
        outputETH: hasOutputETH,
    };
    checkTokens(normalizedTokens.tokenInBuffer, normalizedTokens.tokenOutBuffer);
    return {
        ...normalizedTokens,
        tokenIn: (0, utils_1.tokenAddressToString)(common_types_1.ChainId.Linea, normalizedTokens.tokenInBuffer),
        tokenOut: (0, utils_1.tokenAddressToString)(common_types_1.ChainId.Linea, normalizedTokens.tokenOutBuffer),
        path: getPath(normalizedTokens.tokenInBuffer, normalizedTokens.tokenOutBuffer),
    };
}
function hexAddress(address) {
    return (0, utils_1.tokenAddressToString)(common_types_1.ChainId.Linea, address);
}
class LineaSyncSwapUsdcLP extends swap_connector_1.SwapConnector {
    constructor(connection) {
        super();
        this.connection = connection;
    }
    async getTx(normalizedTokens, amountIn, minAmountOut, swapOutcomeRecipient) {
        const { timestamp } = await this.connection.eth.getBlock("latest");
        const deadline = BigInt(timestamp) + quoteTTL;
        const swapData = viem.encodeAbiParameters([
            { name: "tokenIn", type: "address" },
            { name: "recipient", type: "address" },
            { name: "withdrawMode", type: "uint8" },
        ], [normalizedTokens.tokenIn, swapOutcomeRecipient, normalizedTokens.outputETH ? 1 : 2]);
        // 1 LP = 1 step
        const steps = [
            {
                pool: SyncSwapUSDCWETHPool,
                data: swapData,
                callback: viem.zeroAddress,
                callbackData: "0x",
            },
        ];
        // Only one path
        const paths = [
            {
                steps: steps,
                tokenIn: normalizedTokens.inputETH ? viem.zeroAddress : normalizedTokens.tokenIn,
                amountIn: amountIn,
            },
        ];
        const swapCall = viem.encodeFunctionData({
            abi: SyncSwapRouter_abi_1.SyncSwapRouterABI,
            functionName: "swap",
            args: [paths, minAmountOut, deadline],
        });
        return {
            to: SyncSwapRouterAddress,
            data: swapCall,
            value: normalizedTokens.inputETH ? amountIn.toString() : "0",
        };
    }
    async getSwap(request, context) {
        if (!request.destReceiver)
            throw new Error(`${LineaSyncSwapUsdcLP.name}: destReceiver must be explicitly set`);
        if (request.chainId !== common_types_1.ChainId.Linea)
            throw new Error(`Unsupported chain: ${request.chainId}, expected Linea`);
        const normalizedTokens = normalizeTokens(request.fromTokenAddress, request.toTokenAddress);
        const estimation = await this.getEstimate(request, context);
        const amountOutMin = (estimation.amountOut * (10000n - BigInt(request.slippageBps))) / 10000n;
        return {
            amountIn: request.amountIn,
            amountOut: estimation.amountOut,
            fromToken: request.fromTokenAddress,
            toToken: request.toTokenAddress,
            rawConnectorResponse: null,
            engine: "evm",
            tx: await this.getTx(normalizedTokens, request.amountIn, amountOutMin, hexAddress(request.destReceiver)),
        };
    }
    async getEstimate(request, context) {
        if (request.chainId !== common_types_1.ChainId.Linea)
            throw new Error(`Unsupported chain: ${request.chainId}, expected Linea`);
        const normalizedTokens = normalizeTokens(request.fromTokenAddress, request.toTokenAddress);
        const rawAmountsOut = await this.connection.eth.call({
            to: SyncSwapUSDCWETHPool,
            data: viem.encodeFunctionData({
                abi: SyncSwapClassicPool_abi_1.SyncSwapClassicPoolABI,
                functionName: "getAmountOut",
                args: [normalizedTokens.tokenIn, request.amountIn, viem.zeroAddress /* sender, not used; zero address works */],
            }),
        });
        const amountOut = viem.decodeFunctionResult({
            abi: SyncSwapClassicPool_abi_1.SyncSwapClassicPoolABI,
            functionName: "getAmountOut",
            data: rawAmountsOut,
        });
        return {
            chainId: request.chainId,
            fromTokenAddress: request.fromTokenAddress,
            toTokenAddress: request.toTokenAddress,
            amountIn: request.amountIn,
            amountOut,
        };
    }
    getSupportedChains() {
        return [common_types_1.ChainId.Linea];
    }
    get connectorName() {
        return LineaSyncSwapUsdcLP.name;
    }
}
exports.LineaSyncSwapUsdcLP = LineaSyncSwapUsdcLP;
//# sourceMappingURL=linea-syncswap-usdc-lp.connector.js.map
"use strict";
var _KyberSwapConnector_instances, _KyberSwapConnector_baseUrl, _KyberSwapConnector_SUPPORTED_CHAINS, _KyberSwapConnector_excludedSources, _KyberSwapConnector_maskCredentialFunction, _KyberSwapConnector_timeoutInMs, _KyberSwapConnector_chainIdToString, _KyberSwapConnector_apiCall;
Object.defineProperty(exports, "__esModule", { value: true });
exports.KyberSwapConnector = void 0;
const tslib_1 = require("tslib");
const solana_utils_1 = require("@debridge-finance/solana-utils");
const common_types_1 = require("../common.types");
const swap_connector_1 = require("./swap.connector");
const swap_connector_error_1 = require("./errors/swap-connector.error");
const swap_connector_logger_1 = require("./swap-connector.logger");
const swap_connector_error_type_1 = require("./errors/swap-connector-error.type");
var RequestMode;
(function (RequestMode) {
    RequestMode[RequestMode["GetRoutes"] = 0] = "GetRoutes";
    RequestMode[RequestMode["BuildTransaction"] = 1] = "BuildTransaction";
})(RequestMode || (RequestMode = {}));
class KyberSwapConnector extends swap_connector_1.SwapConnector {
    constructor(excludedSources, timeoutInMs) {
        super();
        _KyberSwapConnector_instances.add(this);
        _KyberSwapConnector_baseUrl.set(this, "https://aggregator-api.kyberswap.com");
        _KyberSwapConnector_SUPPORTED_CHAINS.set(this, [
            common_types_1.ChainId.Arbitrum,
            common_types_1.ChainId.Avalanche,
            common_types_1.ChainId.BSC,
            common_types_1.ChainId.Ethereum,
            common_types_1.ChainId.Fantom,
            common_types_1.ChainId.Polygon,
        ]);
        _KyberSwapConnector_excludedSources.set(this, void 0);
        _KyberSwapConnector_maskCredentialFunction.set(this, void 0);
        _KyberSwapConnector_timeoutInMs.set(this, void 0);
        tslib_1.__classPrivateFieldSet(this, _KyberSwapConnector_excludedSources, excludedSources, "f");
        tslib_1.__classPrivateFieldSet(this, _KyberSwapConnector_maskCredentialFunction, (text) => text, "f");
        tslib_1.__classPrivateFieldSet(this, _KyberSwapConnector_timeoutInMs, timeoutInMs, "f");
    }
    getSupportedChains() {
        return tslib_1.__classPrivateFieldGet(this, _KyberSwapConnector_SUPPORTED_CHAINS, "f");
    }
    async getEstimate(request, context) {
        if (!this.getSupportedChains().includes(request.chainId)) {
            const message = `Chain ${common_types_1.ChainId[request.chainId]} is not supported`;
            throw new swap_connector_error_1.SwapConnectorError(KyberSwapConnector.name, swap_connector_error_type_1.SwapConnectorErrorType.UnsupportedChain, message);
        }
        const logger = new swap_connector_logger_1.SwapConnectorLogger(context.logger, KyberSwapConnector.name, tslib_1.__classPrivateFieldGet(this, _KyberSwapConnector_maskCredentialFunction, "f"));
        const routes = await tslib_1.__classPrivateFieldGet(this, _KyberSwapConnector_instances, "m", _KyberSwapConnector_apiCall).call(this, RequestMode.GetRoutes, request.chainId, {
            amountIn: request.amountIn.toString(),
            tokenIn: solana_utils_1.helpers.bufferToHex(request.fromTokenAddress),
            tokenOut: solana_utils_1.helpers.bufferToHex(request.toTokenAddress),
            excludedSources: tslib_1.__classPrivateFieldGet(this, _KyberSwapConnector_excludedSources, "f"),
        }, logger);
        return {
            amountIn: request.amountIn,
            amountOut: BigInt(routes.data.routeSummary.amountOut),
            chainId: request.chainId,
            fromTokenAddress: request.fromTokenAddress,
            toTokenAddress: request.toTokenAddress,
            rawConnectorResponse: routes,
        };
    }
    async getSwap(request, context) {
        if (!this.getSupportedChains().includes(request.chainId)) {
            const message = `Chain ${common_types_1.ChainId[request.chainId]} is not supported`;
            throw new swap_connector_error_1.SwapConnectorError(KyberSwapConnector.name, swap_connector_error_type_1.SwapConnectorErrorType.UnsupportedChain, message);
        }
        const { rawConnectorResponse: payload } = await this.getEstimate(request, context);
        const routeSummary = payload.data.routeSummary;
        const logger = new swap_connector_logger_1.SwapConnectorLogger(context.logger, KyberSwapConnector.name, tslib_1.__classPrivateFieldGet(this, _KyberSwapConnector_maskCredentialFunction, "f"));
        const swapResponse = await tslib_1.__classPrivateFieldGet(this, _KyberSwapConnector_instances, "m", _KyberSwapConnector_apiCall).call(this, RequestMode.BuildTransaction, request.chainId, {
            routeSummary,
        }, logger);
        const result = {
            amountIn: request.amountIn,
            amountOut: BigInt(swapResponse.data.amountOut),
            fromToken: request.fromAddress,
            toToken: request.toTokenAddress,
            rawConnectorResponse: swapResponse,
            tx: {
                data: swapResponse.data.data,
                to: swapResponse.data.routerAddress,
                value: swapResponse.data.gas,
            },
            engine: "evm",
        };
        return result;
    }
    get connectorName() {
        return "kyber";
    }
}
exports.KyberSwapConnector = KyberSwapConnector;
_KyberSwapConnector_baseUrl = new WeakMap(), _KyberSwapConnector_SUPPORTED_CHAINS = new WeakMap(), _KyberSwapConnector_excludedSources = new WeakMap(), _KyberSwapConnector_maskCredentialFunction = new WeakMap(), _KyberSwapConnector_timeoutInMs = new WeakMap(), _KyberSwapConnector_instances = new WeakSet(), _KyberSwapConnector_chainIdToString = function _KyberSwapConnector_chainIdToString(chainId) {
    const chainMap = {
        [common_types_1.ChainId.Arbitrum]: "arbitrum",
        [common_types_1.ChainId.Avalanche]: "avalanche",
        [common_types_1.ChainId.BSC]: "bsc",
        [common_types_1.ChainId.Ethereum]: "ethereum",
        [common_types_1.ChainId.Fantom]: "fantom",
        [common_types_1.ChainId.Polygon]: "polygon",
    };
    if (chainId in chainMap)
        return chainMap[chainId];
    const message = `Chain ${common_types_1.ChainId[chainId]} is not supported`;
    throw new swap_connector_error_1.SwapConnectorError(KyberSwapConnector.name, swap_connector_error_type_1.SwapConnectorErrorType.UnsupportedChain, message);
}, _KyberSwapConnector_apiCall = async function _KyberSwapConnector_apiCall(mode, chain, params, logger) {
    switch (mode) {
        case RequestMode.GetRoutes: {
            try {
                const response = await this.call({
                    basicUrl: tslib_1.__classPrivateFieldGet(this, _KyberSwapConnector_baseUrl, "f"),
                    timeoutInMs: tslib_1.__classPrivateFieldGet(this, _KyberSwapConnector_timeoutInMs, "f"),
                    path: `/${tslib_1.__classPrivateFieldGet(this, _KyberSwapConnector_instances, "m", _KyberSwapConnector_chainIdToString).call(this, chain)}/api/v1/routes`,
                    query: new URLSearchParams(Object.entries(params).filter(([k, v]) => v !== undefined)),
                    headers: {},
                }, { logger });
                return response;
            }
            catch (e) {
                const error = e;
                throw new swap_connector_error_1.SwapConnectorError(KyberSwapConnector.name, swap_connector_error_type_1.SwapConnectorErrorType.InternalError, error.message);
            }
        }
        case RequestMode.BuildTransaction: {
            try {
                const response = await this.call({
                    basicUrl: tslib_1.__classPrivateFieldGet(this, _KyberSwapConnector_baseUrl, "f"),
                    path: `/${tslib_1.__classPrivateFieldGet(this, _KyberSwapConnector_instances, "m", _KyberSwapConnector_chainIdToString).call(this, chain)}/api/v1/route/build`,
                    query: new URLSearchParams(Object.entries(params).filter(([k, v]) => v !== undefined)),
                    body: JSON.stringify(params),
                    method: "POST",
                    timeoutInMs: tslib_1.__classPrivateFieldGet(this, _KyberSwapConnector_timeoutInMs, "f"),
                    headers: {
                        "Content-Type": "application/json",
                    },
                }, { logger });
                return response;
            }
            catch (e) {
                const error = e;
                throw new swap_connector_error_1.SwapConnectorError(KyberSwapConnector.name, swap_connector_error_type_1.SwapConnectorErrorType.InternalError, error.message);
            }
        }
        default: {
            throw new swap_connector_error_1.SwapConnectorError(KyberSwapConnector.name, swap_connector_error_type_1.SwapConnectorErrorType.InternalError, "ConnectorKyberUnknownMethod");
        }
    }
};
//# sourceMappingURL=kyber.connector.js.map
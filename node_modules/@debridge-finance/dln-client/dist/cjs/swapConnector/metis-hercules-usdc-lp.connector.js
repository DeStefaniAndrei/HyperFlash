"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MetisHerculesUsdcLP = void 0;
const tslib_1 = require("tslib");
const viem = tslib_1.__importStar(require("viem"));
const common_types_1 = require("../common.types");
const utils_1 = require("../utils");
const swap_connector_1 = require("./swap.connector");
const AlgebraQuoter_1 = require("./assets/AlgebraQuoter");
const AlgebraSwapRouter_1 = require("./assets/AlgebraSwapRouter");
const swap_connector_error_1 = require("./errors/swap-connector.error");
const swap_connector_error_type_1 = require("./errors/swap-connector-error.type");
class MetisHerculesError extends swap_connector_error_1.SwapConnectorError {
    constructor(type, message) {
        super("MetisHerculesUsdcLP", type, message);
    }
}
const HerculesRouterAddress = "0xBde5839EC36Db2aC492b79e9E3B75e15FA8A59ec";
const HerculesQuoterAddress = "0xdc2496c72911542a359B9c4d6Fc114c9a392e3D7";
const quoteTTL = 600n; // 10min
const UsdcAddress = "0xEA32A96608495e54156Ae48931A7c20f0dcc1a21";
const UsdcAddressBuf = (0, utils_1.tokenStringToBuffer)(common_types_1.ChainId.Metis, UsdcAddress);
const wMetisAddress = "0x75cb093E4D61d2A2e65D8e0BBb01DE8d89b53481";
const wMetisAddressBuf = (0, utils_1.tokenStringToBuffer)(common_types_1.ChainId.Metis, wMetisAddress);
const MetisAddressBuf = Buffer.alloc(20, 0);
const supportedTokens = [UsdcAddressBuf, wMetisAddressBuf];
function getPath(tokenIn, tokenOut) {
    tokenIn = (0, utils_1.buffersAreEqual)(tokenIn, MetisAddressBuf) ? wMetisAddressBuf : tokenIn;
    tokenOut = (0, utils_1.buffersAreEqual)(tokenIn, MetisAddressBuf) ? wMetisAddressBuf : tokenOut;
    const index1 = supportedTokens.findIndex((v) => (0, utils_1.buffersAreEqual)(v, tokenIn));
    const index2 = supportedTokens.findIndex((v) => (0, utils_1.buffersAreEqual)(v, tokenOut));
    if (index2 > index1) {
        return supportedTokens.slice(index1, index2 + 1);
    }
    return supportedTokens.slice(index2, index1 + 1).reverse();
}
function checkTokens(tokenIn, tokenOut) {
    const hasTokenIn = undefined !== supportedTokens.find((v) => (0, utils_1.buffersAreEqual)(v, tokenIn));
    const hasTokenOut = undefined !== supportedTokens.find((v) => (0, utils_1.buffersAreEqual)(v, tokenOut));
    const areEqual = (0, utils_1.buffersAreEqual)(tokenIn, tokenOut);
    if (areEqual)
        throw new MetisHerculesError(swap_connector_error_type_1.SwapConnectorErrorType.InputValidationError, `In and out tokens are equal`);
    if (!hasTokenIn)
        throw new MetisHerculesError(swap_connector_error_type_1.SwapConnectorErrorType.UnsupportedTokenAddress, `Unsupported input token (${(0, utils_1.tokenAddressToString)(common_types_1.ChainId.Metis, tokenIn)})`);
    if (!hasTokenOut)
        throw new MetisHerculesError(swap_connector_error_type_1.SwapConnectorErrorType.UnsupportedTokenAddress, `Unsupported output token (${(0, utils_1.tokenAddressToString)(common_types_1.ChainId.Metis, tokenOut)})`);
}
function getNormalizedPath(tokenIn, tokenOut) {
    const hasInputETH = (0, utils_1.buffersAreEqual)(tokenIn, MetisAddressBuf);
    const hasOutputETH = (0, utils_1.buffersAreEqual)(tokenOut, MetisAddressBuf);
    const normalizedTokens = {
        tokenInBuffer: hasInputETH ? wMetisAddressBuf : tokenIn,
        tokenOutBuffer: hasOutputETH ? wMetisAddressBuf : tokenOut,
        inputETH: hasInputETH,
        outputETH: hasOutputETH,
    };
    checkTokens(normalizedTokens.tokenInBuffer, normalizedTokens.tokenOutBuffer);
    return {
        ...normalizedTokens,
        tokenIn: (0, utils_1.tokenAddressToString)(common_types_1.ChainId.Metis, normalizedTokens.tokenInBuffer),
        tokenOut: (0, utils_1.tokenAddressToString)(common_types_1.ChainId.Metis, normalizedTokens.tokenOutBuffer),
        path: getPath(normalizedTokens.tokenInBuffer, normalizedTokens.tokenOutBuffer),
    };
}
function hexAddress(address) {
    return (0, utils_1.tokenAddressToString)(common_types_1.ChainId.Metis, address);
}
class MetisHerculesUsdcLP extends swap_connector_1.SwapConnector {
    constructor(connection) {
        super();
        this.connection = connection;
    }
    async getTx(normalizedTokens, amountIn, amountOutMinimum, recipient) {
        const { timestamp } = await this.connection.eth.getBlock("latest");
        const deadline = BigInt(timestamp) + quoteTTL;
        let swapCall;
        if (normalizedTokens.outputETH) {
            const swapAction = viem.encodeFunctionData({
                abi: AlgebraSwapRouter_1.AlgebraSwapRouterABI,
                functionName: "exactInputSingle",
                args: [
                    {
                        tokenIn: normalizedTokens.tokenIn,
                        tokenOut: normalizedTokens.tokenOut,
                        recipient: HerculesRouterAddress,
                        deadline,
                        amountIn,
                        amountOutMinimum,
                        limitSqrtPrice: 0n,
                    },
                ],
            });
            swapCall = viem.encodeFunctionData({
                abi: AlgebraSwapRouter_1.AlgebraSwapRouterABI,
                functionName: "multicall",
                args: [
                    [
                        swapAction,
                        viem.encodeFunctionData({
                            abi: AlgebraSwapRouter_1.AlgebraSwapRouterABI,
                            functionName: "unwrapWNativeToken",
                            args: [amountOutMinimum, recipient],
                        }),
                    ],
                ],
            });
        }
        else {
            swapCall = viem.encodeFunctionData({
                abi: AlgebraSwapRouter_1.AlgebraSwapRouterABI,
                functionName: "exactInputSingle",
                args: [
                    {
                        tokenIn: normalizedTokens.tokenIn,
                        tokenOut: normalizedTokens.tokenOut,
                        recipient,
                        deadline,
                        amountIn,
                        amountOutMinimum,
                        limitSqrtPrice: 0n,
                    },
                ],
            });
        }
        return {
            to: HerculesRouterAddress,
            data: swapCall,
            value: normalizedTokens.inputETH ? amountIn.toString() : "0",
        };
    }
    async getSwap(request, context) {
        if (!request.destReceiver)
            throw new MetisHerculesError(swap_connector_error_type_1.SwapConnectorErrorType.InputValidationError, `destReceiver must be explicitly set`);
        if (request.chainId !== common_types_1.ChainId.Metis)
            throw new MetisHerculesError(swap_connector_error_type_1.SwapConnectorErrorType.InputValidationError, `Unsupported chain: ${request.chainId}, expected Metis`);
        const normalizedTokens = getNormalizedPath(request.fromTokenAddress, request.toTokenAddress);
        const estimation = await this.getEstimate(request, context);
        const amountOutMin = (estimation.amountOut * (10000n - BigInt(request.slippageBps))) / 10000n;
        return {
            amountIn: request.amountIn,
            amountOut: estimation.amountOut,
            fromToken: request.fromTokenAddress,
            toToken: request.toTokenAddress,
            rawConnectorResponse: null,
            engine: "evm",
            tx: await this.getTx(normalizedTokens, request.amountIn, amountOutMin, hexAddress(request.destReceiver)),
        };
    }
    async getEstimate(request, context) {
        if (request.chainId !== common_types_1.ChainId.Metis)
            throw new MetisHerculesError(swap_connector_error_type_1.SwapConnectorErrorType.InputValidationError, `Unsupported chain: ${request.chainId}, expected Metis`);
        const normalizedTokens = getNormalizedPath(request.fromTokenAddress, request.toTokenAddress);
        const rawAmountsOut = await this.connection.eth.call({
            to: HerculesQuoterAddress,
            data: viem.encodeFunctionData({
                abi: AlgebraQuoter_1.AlgebraQuoterABI,
                functionName: "quoteExactInputSingle",
                args: [normalizedTokens.tokenIn, normalizedTokens.tokenOut, request.amountIn, 0n],
            }),
        });
        context.logger.verbose(`received response: ${JSON.stringify(rawAmountsOut)}`);
        const [amountOut] = viem.decodeFunctionResult({
            abi: AlgebraQuoter_1.AlgebraQuoterABI,
            functionName: "quoteExactInputSingle",
            data: rawAmountsOut,
        });
        return {
            chainId: request.chainId,
            fromTokenAddress: request.fromTokenAddress,
            toTokenAddress: request.toTokenAddress,
            amountIn: request.amountIn,
            amountOut,
        };
    }
    getSupportedChains() {
        return [common_types_1.ChainId.Metis];
    }
    get connectorName() {
        return MetisHerculesUsdcLP.name;
    }
}
exports.MetisHerculesUsdcLP = MetisHerculesUsdcLP;
//# sourceMappingURL=metis-hercules-usdc-lp.connector.js.map
"use strict";
var _OneInchV5Connector_instances, _a, _OneInchV5Connector_inchAPI, _OneInchV5Connector_protocols, _OneInchV5Connector_disablePMMProtocols, _OneInchV5Connector_disabledProtocols, _OneInchV5Connector_token, _OneInchV5Connector_maskCredentialFunction, _OneInchV5Connector_timeoutInMs, _OneInchV5Connector_isPMMAllowedFunction, _OneInchV5Connector_isPmmDisabled, _OneInchV5Connector_get1inchProtocols, _OneInchV5Connector_unwindProtocols, _OneInchV5Connector_fix1inchNativeAddress, _OneInchV5Connector_callOneInch, _OneInchV5Connector_getProtocols, _OneInchV5Connector_filterProtocols;
Object.defineProperty(exports, "__esModule", { value: true });
exports.OneInchV5Connector = void 0;
const tslib_1 = require("tslib");
const common_types_1 = require("../common.types");
const utils_1 = require("../utils");
const swap_connector_1 = require("./swap.connector");
const swap_connector_error_1 = require("./errors/swap-connector.error");
const swap_connector_error_type_1 = require("./errors/swap-connector-error.type");
const swap_connector_logger_1 = require("./swap-connector.logger");
var Verb;
(function (Verb) {
    Verb[Verb["quote"] = 0] = "quote";
    Verb[Verb["swap"] = 1] = "swap";
    Verb[Verb["liquidity-sources"] = 2] = "liquidity-sources";
})(Verb || (Verb = {}));
const chainIdToOverride = {
    [common_types_1.ChainId.Gnosis]: 100,
};
/**
 * @internal
 */
class OneInchV5Connector extends swap_connector_1.SwapConnector {
    constructor(config) {
        super();
        _OneInchV5Connector_instances.add(this);
        _OneInchV5Connector_inchAPI.set(this, void 0);
        this.SUPPORTED_CHAINS = [
            common_types_1.ChainId.Base,
            common_types_1.ChainId.Arbitrum,
            common_types_1.ChainId.Avalanche,
            common_types_1.ChainId.BSC,
            common_types_1.ChainId.Polygon,
            common_types_1.ChainId.Ethereum,
            common_types_1.ChainId.Gnosis,
            common_types_1.ChainId.Fantom,
            common_types_1.ChainId.Optimism,
        ];
        _OneInchV5Connector_disablePMMProtocols.set(this, void 0);
        _OneInchV5Connector_disabledProtocols.set(this, []);
        _OneInchV5Connector_token.set(this, void 0);
        _OneInchV5Connector_maskCredentialFunction.set(this, void 0);
        _OneInchV5Connector_timeoutInMs.set(this, void 0);
        _OneInchV5Connector_isPMMAllowedFunction.set(this, void 0);
        const token = config.token;
        tslib_1.__classPrivateFieldSet(this, _OneInchV5Connector_token, token, "f");
        tslib_1.__classPrivateFieldSet(this, _OneInchV5Connector_inchAPI, config.customApiURL || "https://api.1inch.io", "f");
        tslib_1.__classPrivateFieldSet(this, _OneInchV5Connector_disablePMMProtocols, config.disablePMMProtocols === undefined ? true : config.disablePMMProtocols, "f");
        tslib_1.__classPrivateFieldSet(this, _OneInchV5Connector_disabledProtocols, config.disabledProtocols || [], "f");
        tslib_1.__classPrivateFieldSet(this, _OneInchV5Connector_maskCredentialFunction, token ? (text) => text.replaceAll(token, "<API KEY>") : (text) => text, "f");
        tslib_1.__classPrivateFieldSet(this, _OneInchV5Connector_timeoutInMs, config.timeoutInMs, "f");
        const defaultIsPMMAllowedFunction = () => Promise.resolve(true);
        tslib_1.__classPrivateFieldSet(this, _OneInchV5Connector_isPMMAllowedFunction, config.isPMMAllowedFunction || defaultIsPMMAllowedFunction, "f");
    }
    getSupportedChains() {
        return this.SUPPORTED_CHAINS;
    }
    async getLPs(chainId, context) {
        const logger = new swap_connector_logger_1.SwapConnectorLogger(context.logger, OneInchV5Connector.name, tslib_1.__classPrivateFieldGet(this, _OneInchV5Connector_maskCredentialFunction, "f"));
        const result = await tslib_1.__classPrivateFieldGet(this, _OneInchV5Connector_instances, "m", _OneInchV5Connector_callOneInch).call(this, chainId, Verb["liquidity-sources"], new URLSearchParams(), logger);
        return result;
    }
    async getEstimate(request, context) {
        const logger = new swap_connector_logger_1.SwapConnectorLogger(context.logger, OneInchV5Connector.name, tslib_1.__classPrivateFieldGet(this, _OneInchV5Connector_maskCredentialFunction, "f"));
        if (!this.getSupportedChains().includes(request.chainId)) {
            const message = `Chain ${common_types_1.ChainId[request.chainId]} is not supported`;
            throw new swap_connector_error_1.SwapConnectorError(OneInchV5Connector.name, swap_connector_error_type_1.SwapConnectorErrorType.UnsupportedChain, message);
        }
        const slippageBps = request.affiliateFeeBps ? (0, swap_connector_1.bpsToPercent)(request.affiliateFeeBps) : 0;
        let protocols = tslib_1.__classPrivateFieldGet(this, _OneInchV5Connector_instances, "m", _OneInchV5Connector_get1inchProtocols).call(this, request.routeHint) || [];
        const disabledProtocols = tslib_1.__classPrivateFieldGet(this, _OneInchV5Connector_disabledProtocols, "f");
        const disablePMMProtocols = tslib_1.__classPrivateFieldGet(this, _OneInchV5Connector_disablePMMProtocols, "f");
        if (protocols.length === 0 &&
            (disabledProtocols.length > 0 || disablePMMProtocols) // we don't need to request protocols if disabledProtocols is empty and disablePMMProtocols is false
        ) {
            const protocolsFrom1inch = await tslib_1.__classPrivateFieldGet(this, _OneInchV5Connector_instances, "m", _OneInchV5Connector_getProtocols).call(this, request.chainId, context);
            protocols = tslib_1.__classPrivateFieldGet(this, _OneInchV5Connector_instances, "m", _OneInchV5Connector_filterProtocols).call(this, protocolsFrom1inch, disablePMMProtocols);
        }
        const quoteRequest = {
            src: tslib_1.__classPrivateFieldGet(this, _OneInchV5Connector_instances, "m", _OneInchV5Connector_fix1inchNativeAddress).call(this, request.chainId, request.fromTokenAddress),
            dst: tslib_1.__classPrivateFieldGet(this, _OneInchV5Connector_instances, "m", _OneInchV5Connector_fix1inchNativeAddress).call(this, request.chainId, request.toTokenAddress),
            amount: request.amountIn.toString(),
            protocols,
            fee: slippageBps,
        };
        const query = new URLSearchParams({
            amount: quoteRequest.amount.toString(),
            fee: (quoteRequest.fee || 0).toString(),
            src: quoteRequest.src,
            dst: quoteRequest.dst,
        });
        if (quoteRequest.protocols?.length) {
            query.append("protocols", quoteRequest.protocols.join(","));
        }
        const response = await tslib_1.__classPrivateFieldGet(this, _OneInchV5Connector_instances, "m", _OneInchV5Connector_callOneInch).call(this, request.chainId, Verb.quote, query, logger);
        const result = {
            amountIn: BigInt(quoteRequest.amount),
            chainId: request.chainId,
            fromTokenAddress: request.fromTokenAddress,
            toTokenAddress: request.toTokenAddress,
            slippageBps,
            amountOut: BigInt(response.toAmount),
            rawConnectorResponse: response,
        };
        return result;
    }
    async getSwap(request, context) {
        const logger = new swap_connector_logger_1.SwapConnectorLogger(context.logger, OneInchV5Connector.name, tslib_1.__classPrivateFieldGet(this, _OneInchV5Connector_maskCredentialFunction, "f"));
        if (!request.destReceiver)
            throw new swap_connector_error_1.SwapConnectorError(OneInchV5Connector.name, swap_connector_error_type_1.SwapConnectorErrorType.InputValidationError, `1InchMissingDestReceiver`);
        if (!this.getSupportedChains().includes(request.chainId)) {
            const message = `Chain ${common_types_1.ChainId[request.chainId]} is not supported`;
            throw new swap_connector_error_1.SwapConnectorError(OneInchV5Connector.name, swap_connector_error_type_1.SwapConnectorErrorType.UnsupportedChain, message);
        }
        let protocols = tslib_1.__classPrivateFieldGet(this, _OneInchV5Connector_instances, "m", _OneInchV5Connector_get1inchProtocols).call(this, request.routeHint) || [];
        const disabledProtocols = tslib_1.__classPrivateFieldGet(this, _OneInchV5Connector_disabledProtocols, "f");
        // we require extra pmm allowing validation for generation swap tx
        const disablePMMProtocols = await tslib_1.__classPrivateFieldGet(this, _OneInchV5Connector_instances, "m", _OneInchV5Connector_isPmmDisabled).call(this, request);
        if (protocols.length === 0 &&
            (disabledProtocols.length > 0 || disablePMMProtocols) // we don't need to request protocols if disabledProtocols is empty and disablePMMProtocols is false
        ) {
            const protocolsFrom1inch = await tslib_1.__classPrivateFieldGet(this, _OneInchV5Connector_instances, "m", _OneInchV5Connector_getProtocols).call(this, request.chainId, context);
            protocols = tslib_1.__classPrivateFieldGet(this, _OneInchV5Connector_instances, "m", _OneInchV5Connector_filterProtocols).call(this, protocolsFrom1inch, disablePMMProtocols);
        }
        if (!request.origin) {
            throw new swap_connector_error_1.SwapConnectorError(OneInchV5Connector.name, swap_connector_error_type_1.SwapConnectorErrorType.InputValidationError, "Origin is mandatory");
        }
        const swapRequest = {
            src: tslib_1.__classPrivateFieldGet(this, _OneInchV5Connector_instances, "m", _OneInchV5Connector_fix1inchNativeAddress).call(this, request.chainId, request.fromTokenAddress),
            dst: tslib_1.__classPrivateFieldGet(this, _OneInchV5Connector_instances, "m", _OneInchV5Connector_fix1inchNativeAddress).call(this, request.chainId, request.toTokenAddress),
            amount: request.amountIn.toString(),
            from: (0, utils_1.tokenAddressToString)(request.chainId, request.fromAddress),
            receiver: request.destReceiver ? (0, utils_1.tokenAddressToString)(request.chainId, request.destReceiver) : undefined,
            origin: (0, utils_1.tokenAddressToString)(request.chainId, request.origin),
            slippage: (0, swap_connector_1.bpsToPercent)(request.slippageBps) || 0,
            disableEstimate: true,
            protocols,
            referrer: request.affiliateFeeRecipient
                ? (0, utils_1.tokenAddressToString)(request.chainId, request.affiliateFeeRecipient)
                : "",
            fee: request.affiliateFeeBps ? (0, swap_connector_1.bpsToPercent)(request.affiliateFeeBps) : 0,
        };
        const query = new URLSearchParams({
            src: swapRequest.src,
            dst: swapRequest.dst,
            amount: swapRequest.amount,
            receiver: swapRequest.receiver,
            disableEstimate: swapRequest.disableEstimate ? "true" : "false",
            fee: (swapRequest.fee || 0).toString(),
            protocols: swapRequest.protocols?.join(",") || "",
            from: swapRequest.from,
            origin: swapRequest.origin,
            referrer: swapRequest.referrer ?? "",
            slippage: swapRequest.slippage.toString(),
        });
        const response = await tslib_1.__classPrivateFieldGet(this, _OneInchV5Connector_instances, "m", _OneInchV5Connector_callOneInch).call(this, request.chainId, Verb.swap, query, logger);
        const result = {
            amountIn: request.amountIn,
            fromToken: request.fromTokenAddress,
            toToken: request.toTokenAddress,
            amountOut: BigInt(response.toAmount),
            rawConnectorResponse: response,
            tx: response.tx,
            engine: "evm",
        };
        return result;
    }
    setDisabledProtocols(disabledProtocols) {
        tslib_1.__classPrivateFieldSet(this, _OneInchV5Connector_disabledProtocols, disabledProtocols, "f");
    }
    get connectorName() {
        return "oneinch-v5";
    }
}
exports.OneInchV5Connector = OneInchV5Connector;
_a = OneInchV5Connector, _OneInchV5Connector_inchAPI = new WeakMap(), _OneInchV5Connector_disablePMMProtocols = new WeakMap(), _OneInchV5Connector_disabledProtocols = new WeakMap(), _OneInchV5Connector_token = new WeakMap(), _OneInchV5Connector_maskCredentialFunction = new WeakMap(), _OneInchV5Connector_timeoutInMs = new WeakMap(), _OneInchV5Connector_isPMMAllowedFunction = new WeakMap(), _OneInchV5Connector_instances = new WeakSet(), _OneInchV5Connector_isPmmDisabled = async function _OneInchV5Connector_isPmmDisabled(swapRequest) {
    if (tslib_1.__classPrivateFieldGet(this, _OneInchV5Connector_disablePMMProtocols, "f"))
        return true;
    return !(await tslib_1.__classPrivateFieldGet(this, _OneInchV5Connector_isPMMAllowedFunction, "f").call(this, swapRequest));
}, _OneInchV5Connector_get1inchProtocols = function _OneInchV5Connector_get1inchProtocols(preference) {
    if (!preference?.rawConnectorResponse)
        return [];
    const payload = preference.rawConnectorResponse;
    return tslib_1.__classPrivateFieldGet(this, _OneInchV5Connector_instances, "m", _OneInchV5Connector_unwindProtocols).call(this, payload.protocols || []);
}, _OneInchV5Connector_unwindProtocols = function _OneInchV5Connector_unwindProtocols(protocols) {
    return protocols.map((p) => {
        if (Array.isArray(p))
            return tslib_1.__classPrivateFieldGet(this, _OneInchV5Connector_instances, "m", _OneInchV5Connector_unwindProtocols).call(this, p);
        else
            return p.name;
    });
}, _OneInchV5Connector_fix1inchNativeAddress = function _OneInchV5Connector_fix1inchNativeAddress(chainId, token) {
    let address = (0, utils_1.tokenAddressToString)(chainId, token);
    if (address === "0x0000000000000000000000000000000000000000") {
        address = "0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE";
    }
    return address;
}, _OneInchV5Connector_callOneInch = async function _OneInchV5Connector_callOneInch(dlnChainId, verb, query, logger) {
    try {
        const oneInchChainId = chainIdToOverride[dlnChainId] || dlnChainId;
        return await this.call({
            basicUrl: tslib_1.__classPrivateFieldGet(this, _OneInchV5Connector_inchAPI, "f"),
            path: `/v5.2/${oneInchChainId}/${Verb[verb]}`,
            query,
            timeoutInMs: tslib_1.__classPrivateFieldGet(this, _OneInchV5Connector_timeoutInMs, "f"),
            headers: tslib_1.__classPrivateFieldGet(this, _OneInchV5Connector_token, "f")
                ? {
                    Authorization: `Bearer ${tslib_1.__classPrivateFieldGet(this, _OneInchV5Connector_token, "f")}`,
                }
                : {},
        }, {
            logger,
        });
    }
    catch (e) {
        const error = e;
        const errOneInch = JSON.parse(error.responseBody);
        if (errOneInch.description.startsWith("cannot sync")) {
            const tokenAddress = errOneInch.description.replace("cannot sync", "").trim();
            const chainName = common_types_1.ChainId[dlnChainId];
            throw new swap_connector_error_1.SwapConnectorError(swap_connector_error_1.SwapConnectorError.name, swap_connector_error_type_1.SwapConnectorErrorType.UnsupportedTokenAddress, `token ${tokenAddress} is not known on the ${chainName} chain`);
        }
        if (errOneInch.description === "not valid token") {
            const tokenAddress = errOneInch.meta.find((_) => _.type === "address").value;
            const chainName = common_types_1.ChainId[dlnChainId];
            throw new swap_connector_error_1.SwapConnectorError(swap_connector_error_1.SwapConnectorError.name, swap_connector_error_type_1.SwapConnectorErrorType.UnsupportedTokenAddress, `token ${tokenAddress} is not known on the ${chainName} chain`);
        }
        const errorMessage = `${this.connectorName}::${Verb[verb]} returned ${errOneInch.description}: ${error.responseBody}`;
        throw new swap_connector_error_1.SwapConnectorError(swap_connector_error_1.SwapConnectorError.name, swap_connector_error_type_1.SwapConnectorErrorType.InternalError, errorMessage);
    }
}, _OneInchV5Connector_getProtocols = async function _OneInchV5Connector_getProtocols(chainId, context) {
    if (!tslib_1.__classPrivateFieldGet(OneInchV5Connector, _a, "f", _OneInchV5Connector_protocols)[chainId]) {
        const lps = await this.getLPs(chainId, context);
        tslib_1.__classPrivateFieldGet(OneInchV5Connector, _a, "f", _OneInchV5Connector_protocols)[chainId] = lps.protocols.map((p) => p.id);
    }
    return tslib_1.__classPrivateFieldGet(OneInchV5Connector, _a, "f", _OneInchV5Connector_protocols)[chainId];
}, _OneInchV5Connector_filterProtocols = function _OneInchV5Connector_filterProtocols(protocols, disablePMMProtocols) {
    const filteredProtocols = protocols.filter((protocol) => !tslib_1.__classPrivateFieldGet(this, _OneInchV5Connector_disabledProtocols, "f").includes(protocol));
    if (disablePMMProtocols) {
        return filteredProtocols.filter((p) => !p.includes("PMM")).filter((p) => !p.includes("ONE_INCH_LIMIT_ORDER"));
    }
    return filteredProtocols;
};
_OneInchV5Connector_protocols = { value: {} };
//# sourceMappingURL=one.inch.v5.connector.js.map
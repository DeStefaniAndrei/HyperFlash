"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getOrderFromEvmTransaction = exports.evmOrderToOrderData = void 0;
const tslib_1 = require("tslib");
const solana_utils_1 = require("@debridge-finance/solana-utils");
const web3_1 = tslib_1.__importDefault(require("web3"));
const DlnSource_json_1 = tslib_1.__importDefault(require("../../assets/abi/DlnSource.json"));
function getEventFromLogs(eventABI, logs, web3) {
    const address = null;
    const eventName = eventABI.name;
    if (!eventName)
        return null;
    if (!eventABI || !eventABI.inputs)
        return null;
    const eventSignature = `${eventName}(${eventABI.inputs
        .map((input) => {
        if (input.type === "tuple") {
            return `(${input.components.map((input) => input.type).join()})`;
        }
        return input.type;
    })
        .join(",")})`;
    const eventTopic = web3_1.default.utils.sha3(eventSignature);
    // Only decode events of type 'EventName'
    const created = logs
        .filter((log) => log.topics.length > 0 && log.topics[0] === eventTopic && (!address || log.address === address))
        .map((log) => web3.eth.abi.decodeLog(eventABI.inputs, log.data, log.topics.slice(1)))
        .map((decoded) => ({ event: eventName, args: decoded }));
    if (!created || created.length === 0)
        return null;
    return created[0].args;
}
function evmOrderToOrderData(order) {
    return {
        give: {
            chainId: Number(order.giveChainId),
            amount: BigInt(order.giveAmount),
            tokenAddress: solana_utils_1.helpers.hexToBuffer(order.giveTokenAddress),
        },
        take: {
            chainId: Number(order.takeChainId),
            amount: BigInt(order.takeAmount),
            tokenAddress: solana_utils_1.helpers.hexToBuffer(order.takeTokenAddress),
        },
        maker: solana_utils_1.helpers.hexToBuffer(order.makerSrc),
        nonce: BigInt(order.makerOrderNonce),
        receiver: solana_utils_1.helpers.hexToBuffer(order.receiverDst),
        givePatchAuthority: solana_utils_1.helpers.hexToBuffer(order.givePatchAuthoritySrc),
        orderAuthorityDstAddress: solana_utils_1.helpers.hexToBuffer(order.orderAuthorityAddressDst),
        allowedCancelBeneficiary: order.allowedCancelBeneficiarySrc != "0x" ? solana_utils_1.helpers.hexToBuffer(order.allowedCancelBeneficiarySrc) : undefined,
        allowedTaker: order.allowedTakerDst != "0x" ? solana_utils_1.helpers.hexToBuffer(order.allowedTakerDst) : undefined,
        externalCall: order.externalCall != "0x"
            ? {
                externalCallData: solana_utils_1.helpers.hexToBuffer(order.externalCall),
            }
            : undefined,
    };
}
exports.evmOrderToOrderData = evmOrderToOrderData;
async function getOrderFromEvmTransaction(txHash, web3) {
    const txReceipt = await web3.eth.getTransactionReceipt(txHash);
    if (!txReceipt)
        return null;
    const eventName = "CreatedOrder";
    const eventABI = DlnSource_json_1.default.abi.find((item) => item.type === "event" && item.name === eventName);
    if (!eventABI)
        return null;
    const patchedEventAbi = JSON.parse(JSON.stringify(eventABI));
    patchedEventAbi.inputs?.pop();
    const createdOrderInfo = getEventFromLogs(eventABI, txReceipt.logs, web3) ||
        getEventFromLogs(patchedEventAbi, txReceipt.logs, web3);
    if (!createdOrderInfo)
        return null;
    const order = evmOrderToOrderData(createdOrderInfo.order);
    let affiliateInfo = undefined;
    if (createdOrderInfo.affiliateFee !== "0x" && createdOrderInfo.affiliateFee !== null) {
        affiliateInfo = {
            amount: BigInt("0x" + createdOrderInfo.affiliateFee.slice(42)),
            beneficiary: solana_utils_1.helpers.hexToBuffer(createdOrderInfo.affiliateFee.slice(0, 42)), // 0x + 20 hex bytes
        };
    }
    const blockInfo = await web3.eth.getBlock(txReceipt.blockHash);
    const blockTimestamp = typeof blockInfo.timestamp === "string"
        ? blockInfo.timestamp === ""
            ? undefined
            : Number(blockInfo.timestamp)
        : blockInfo.timestamp;
    return {
        ...order,
        orderId: solana_utils_1.helpers.hexToBuffer(createdOrderInfo.orderId),
        referralCode: Number(createdOrderInfo.referralCode),
        transferFee: BigInt(createdOrderInfo.percentFee),
        fixFee: BigInt(createdOrderInfo.nativeFixFee),
        createTimestamp: blockTimestamp,
        affiliateInfo,
    };
}
exports.getOrderFromEvmTransaction = getOrderFromEvmTransaction;
//# sourceMappingURL=get.order.from.transaction.js.map
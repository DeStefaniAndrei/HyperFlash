"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getL1FeeNativeCost = exports.isOpStackBasedChain = void 0;
const tslib_1 = require("tslib");
const viem_1 = require("viem");
const node_cache_1 = tslib_1.__importDefault(require("node-cache"));
const common_types_1 = require("../../../common.types");
const L1Block_abi_1 = require("./assets/L1Block.abi");
const cache = new node_cache_1.default({ stdTTL: 12 /* block speed in Ethereum */ });
const L1BlockContractAddress = "0x4200000000000000000000000000000000000015";
const feeScalarDenominator = 1000000n;
const txGasDenominator = 16n;
async function getBaseFee(chainId, connection) {
    const cacheKey = `${chainId}-basefee`;
    const cachedValue = cache.get(cacheKey);
    if (cachedValue !== undefined) {
        return cachedValue;
    }
    const basefee = (0, viem_1.decodeFunctionResult)({
        abi: L1Block_abi_1.L1BlockABI,
        functionName: "basefee",
        data: (await connection.eth.call({
            to: L1BlockContractAddress,
            data: (0, viem_1.encodeFunctionData)({
                abi: L1Block_abi_1.L1BlockABI,
                functionName: "basefee",
            }),
        })),
    });
    cache.set(cacheKey, basefee);
    return basefee;
}
async function getBlobBaseFee(chainId, connection) {
    const cacheKey = `${chainId}-blobBaseFee`;
    const cachedValue = cache.get(cacheKey);
    if (cachedValue !== undefined) {
        return cachedValue;
    }
    const blobBaseFee = (0, viem_1.decodeFunctionResult)({
        abi: L1Block_abi_1.L1BlockABI,
        functionName: "blobBaseFee",
        data: (await connection.eth.call({
            to: L1BlockContractAddress,
            data: (0, viem_1.encodeFunctionData)({
                abi: L1Block_abi_1.L1BlockABI,
                functionName: "blobBaseFee",
            }),
        })),
    });
    cache.set(cacheKey, blobBaseFee);
    return blobBaseFee;
}
async function getBaseFeeScalar(chainId, connection) {
    const cacheKey = `${chainId}-baseFeeScalar`;
    const cachedValue = cache.get(cacheKey);
    if (cachedValue !== undefined) {
        return cachedValue;
    }
    const baseFeeScalar = (0, viem_1.decodeFunctionResult)({
        abi: L1Block_abi_1.L1BlockABI,
        functionName: "baseFeeScalar",
        data: (await connection.eth.call({
            to: L1BlockContractAddress,
            data: (0, viem_1.encodeFunctionData)({
                abi: L1Block_abi_1.L1BlockABI,
                functionName: "baseFeeScalar",
            }),
        })),
    });
    cache.set(cacheKey, baseFeeScalar);
    return baseFeeScalar;
}
async function getBlobBaseFeeScalar(chainId, connection) {
    const cacheKey = `${chainId}-blobBaseFeeScalar`;
    const cachedValue = cache.get(cacheKey);
    if (cachedValue !== undefined) {
        return cachedValue;
    }
    const blobBaseFeeScalar = (0, viem_1.decodeFunctionResult)({
        abi: L1Block_abi_1.L1BlockABI,
        functionName: "blobBaseFeeScalar",
        data: (await connection.eth.call({
            to: L1BlockContractAddress,
            data: (0, viem_1.encodeFunctionData)({
                abi: L1Block_abi_1.L1BlockABI,
                functionName: "blobBaseFeeScalar",
            }),
        })),
    });
    cache.set(cacheKey, blobBaseFeeScalar);
    return blobBaseFeeScalar;
}
function isOpStackBasedChain(chainId) {
    return common_types_1.OpStackBasedEVMChains.includes(chainId);
}
exports.isOpStackBasedChain = isOpStackBasedChain;
async function getL1FeeNativeCost(chainId, connection, txDataGas, context) {
    const [baseFee, baseFeeScalar, blobBaseFee, blobBaseFeeScalar] = await Promise.all([
        getBaseFee(chainId, connection),
        getBaseFeeScalar(chainId, connection),
        getBlobBaseFee(chainId, connection),
        getBlobBaseFeeScalar(chainId, connection),
    ]);
    // formula for l1 fee calculation: https://docs.optimism.io/stack/transactions/fees
    // weighted_gas_price = 16*base_fee_scalar*base_fee + blob_base_fee_scalar*blob_base_fee
    const weightedGasPrice = (16n * BigInt(baseFeeScalar) * baseFee) / feeScalarDenominator +
        (BigInt(blobBaseFeeScalar) * blobBaseFee) / feeScalarDenominator;
    // l1_data_fee = tx_compressed_size * weighted_gas_price
    const l1DataFee = (txDataGas * weightedGasPrice) / txGasDenominator;
    context?.loggerInstance?.verbose(`getL1FeeNativeCost for ${common_types_1.ChainId[chainId]}: baseFee=${baseFee} baseFeeScalar=${baseFeeScalar} blobBaseFee${blobBaseFee} blobBaseFeeScalar=${blobBaseFeeScalar} txDataGas=${txDataGas} l1DataFee=${l1DataFee}`);
    return l1DataFee;
}
exports.getL1FeeNativeCost = getL1FeeNativeCost;
//# sourceMappingURL=opstack.service.js.map
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DlnSourceService = void 0;
const tslib_1 = require("tslib");
const bignumber_js_1 = tslib_1.__importDefault(require("bignumber.js"));
const common_type_1 = require("../types/common.type");
const DlnSource_json_1 = tslib_1.__importDefault(require("../../assets/abi/DlnSource.json"));
const LimaDlnSource_json_1 = tslib_1.__importDefault(require("../../assets/abi/LimaDlnSource.json"));
const contract_cache_class_1 = require("../utils/contract-cache.class");
const common_types_1 = require("../../../common.types");
const client_error_type_enum_1 = require("../../../errors/client-error-type.enum");
const client_error_error_1 = require("../../../errors/client-error.error");
const env_1 = require("../../../common/env");
const gasprice_service_1 = require("./gasprice.service");
const opstack_service_1 = require("./opstack.service");
//https://optimistic.etherscan.io/tx/0xb053e406c6f836bb3ea3885a6b0f706a0d573c2cf5039108f77af10c4829431a
const OP_TXDATA_GAS_CLAIM_BATCH_UNLOCK = 25000n;
//https://optimistic.etherscan.io/tx/0x03cff04008617bce29545d837ad946db75e4cabe1ca168a657b24cf60395782b
const OP_TXDATA_GAS_CLAIM_CANCEL = 35000n;
const EVM_GASLIMIT_CLAIM_BASE = {
    [common_types_1.ChainId.Arbitrum]: 400000,
    [common_types_1.ChainId.Avalanche]: 400000,
    [common_types_1.ChainId.Base]: 400000,
    [common_types_1.ChainId.Bitrock]: 400000,
    [common_types_1.ChainId.BSC]: 400000,
    [common_types_1.ChainId.Ethereum]: 400000,
    [common_types_1.ChainId.Fantom]: 400000 * 2,
    [common_types_1.ChainId.Gnosis]: 400000,
    [common_types_1.ChainId.LightLink]: 400000,
    [common_types_1.ChainId.Linea]: 400000,
    [common_types_1.ChainId.Metis]: 400000,
    [common_types_1.ChainId.Neon]: 0,
    [common_types_1.ChainId.Optimism]: 400000,
    [common_types_1.ChainId.Polygon]: 400000,
};
const EVM_GASLIMIT_CLAIM_UNLOCK_PER_ORDER = {
    [common_types_1.ChainId.Arbitrum]: 50000,
    [common_types_1.ChainId.Avalanche]: 50000,
    [common_types_1.ChainId.Base]: 50000,
    [common_types_1.ChainId.Bitrock]: 50000,
    [common_types_1.ChainId.BSC]: 50000,
    [common_types_1.ChainId.Ethereum]: 50000,
    [common_types_1.ChainId.Fantom]: 50000 * 2,
    [common_types_1.ChainId.Gnosis]: 50000,
    [common_types_1.ChainId.LightLink]: 50000,
    [common_types_1.ChainId.Linea]: 50000,
    [common_types_1.ChainId.Metis]: 50000,
    // reserve gas for: exFee transfer, unlock transfer, affiliate fee transfer
    // tx: 0xaa9b5c2b2e506884e5afcb5538ae3a41ee1fabaca62ff0462a74ef578eb876f2
    // assume that batch_size is 1
    [common_types_1.ChainId.Neon]: 4000000,
    [common_types_1.ChainId.Optimism]: 50000,
    [common_types_1.ChainId.Polygon]: 50000,
};
const EVM_GASLIMIT_CLAIM_CANCEL_PER_ORDER = {
    [common_types_1.ChainId.Arbitrum]: 50000,
    [common_types_1.ChainId.Avalanche]: 50000,
    [common_types_1.ChainId.Base]: 50000,
    [common_types_1.ChainId.Bitrock]: 50000,
    [common_types_1.ChainId.BSC]: 50000,
    [common_types_1.ChainId.Ethereum]: 50000,
    [common_types_1.ChainId.Fantom]: 50000 * 2,
    [common_types_1.ChainId.Gnosis]: 50000,
    [common_types_1.ChainId.LightLink]: 50000,
    [common_types_1.ChainId.Linea]: 50000,
    [common_types_1.ChainId.Metis]: 50000,
    // tx: 0xcf5cecae9a4c1b3644625f1126e4f57cd754fb516d34765d5dac3ba61814abc8
    [common_types_1.ChainId.Neon]: 2000000,
    [common_types_1.ChainId.Optimism]: 50000,
    [common_types_1.ChainId.Polygon]: 50000,
};
class DlnSourceService extends contract_cache_class_1.ContractCache {
    constructor(enableContractsCache = true, version = env_1.Env.Prod) {
        super(enableContractsCache);
        this.version = version;
    }
    getCreateOrderMethod(provider, contractAddress, orderCreation, affiliateFee, referralCode, permit) {
        const contract = this.getContract(provider, contractAddress);
        return contract.methods.createOrder(orderCreation, affiliateFee, referralCode, permit);
    }
    getCreateSaltedOrderMethod(provider, contractAddress, orderCreation, salt, affiliateFee, referralCode, permit, metadata) {
        const contract = this.getContract(provider, contractAddress);
        return contract.methods.createSaltedOrder(orderCreation, salt, affiliateFee, referralCode, permit, metadata);
    }
    getPatchOrderGiveMethod(provider, contractAddress, order, amount, permit) {
        const contract = this.getContract(provider, contractAddress);
        return contract.methods.patchOrderGive(order, amount, permit);
    }
    async getClaimBatchUnlockNativeCostForSingleOrder(batchUnlockCoverage, chain, provider, orderEstimationStage, payload) {
        const logger = (...params) => payload?.loggerInstance?.verbose("[getClaimBatchUnlockNativeCostForSingleOrder]", ...params);
        if (batchUnlockCoverage < 0.1 || batchUnlockCoverage > 1)
            throw new client_error_error_1.ClientError(client_error_type_enum_1.ClientErrorType.WrongBatchSize, `batchUnlockCoverage must be within [0.1, 1]`);
        const supportedChain = chain;
        if (!Object.values(common_type_1.SupportedEVMChains).includes(supportedChain))
            throw new client_error_error_1.ClientError(client_error_type_enum_1.ClientErrorType.UnsupportedChain);
        // (claim_base / batch_size) + claim_unlock_per_order
        const projectedGasLimit = EVM_GASLIMIT_CLAIM_BASE[supportedChain] * batchUnlockCoverage +
            EVM_GASLIMIT_CLAIM_UNLOCK_PER_ORDER[supportedChain];
        logger(`projected gasLimit: ${projectedGasLimit.toString()}`);
        const gasLimit = await (0, gasprice_service_1.getCorrectedGasLimit)(chain, provider, projectedGasLimit);
        logger(`corrected gasLimit: ${gasLimit.toString()}`);
        // gas price
        const gasPrice = await (0, gasprice_service_1.predictGasPrice)(chain, provider, orderEstimationStage);
        logger(`predicted gasPrice: ${gasPrice.toString()}`);
        // cost
        let fee = gasPrice.multipliedBy(gasLimit);
        logger(`calculated tx fee: ${fee.toString()}`);
        // op stack
        if ((0, opstack_service_1.isOpStackBasedChain)(chain)) {
            const l1Fee = await (0, opstack_service_1.getL1FeeNativeCost)(chain, provider, OP_TXDATA_GAS_CLAIM_BATCH_UNLOCK, payload);
            const l1FeePerOrder = (l1Fee * BigInt(Math.round(batchUnlockCoverage * Number(common_types_1.BPS_DENOMINATOR)))) / common_types_1.BPS_DENOMINATOR;
            fee = fee.plus(l1FeePerOrder.toString());
            logger(`calculated l1 fee: ${l1Fee}, per order: ${l1FeePerOrder}, total fee: ${fee.toString()}`);
        }
        return {
            totalCost: BigInt(fee.integerValue().toString()),
            gasPrice: BigInt(gasPrice.integerValue().toString()),
            gasLimit: BigInt(gasLimit.integerValue().toString()),
            chainId: chain,
        };
    }
    async getClaimBatchUnlockExecutionFee(batchSize, chain, provider, orderEstimationStage, payload) {
        const logger = (...params) => payload?.loggerInstance?.verbose("[getClaimBatchUnlockExecutionFee]", ...params);
        if (batchSize < 1 || batchSize > 10)
            throw new client_error_error_1.ClientError(client_error_type_enum_1.ClientErrorType.WrongBatchSize, `batchSize must be within [1, 10]`);
        const supportedChain = chain;
        if (!Object.values(common_type_1.SupportedEVMChains).includes(supportedChain))
            throw new client_error_error_1.ClientError(client_error_type_enum_1.ClientErrorType.UnsupportedChain);
        // claim_base + (claim_unlock_per_order * batchSize)
        const gasLimit = await (0, gasprice_service_1.getCorrectedGasLimit)(chain, provider, EVM_GASLIMIT_CLAIM_BASE[supportedChain] + EVM_GASLIMIT_CLAIM_UNLOCK_PER_ORDER[supportedChain] * batchSize);
        logger(`target gasLimit: ${gasLimit.toString()}`);
        // gas price
        const gasPrice = await (0, gasprice_service_1.predictGasPrice)(chain, provider, orderEstimationStage);
        logger(`predicted gasPrice: ${gasPrice.toString()}`);
        // cost
        let fee = gasPrice.multipliedBy(gasLimit);
        logger(`calculated tx fee: ${fee.toString()}`);
        // op stack
        if ((0, opstack_service_1.isOpStackBasedChain)(chain)) {
            const l1Fee = await (0, opstack_service_1.getL1FeeNativeCost)(chain, provider, OP_TXDATA_GAS_CLAIM_BATCH_UNLOCK, payload);
            fee = fee.plus(l1Fee.toString());
            logger(`calculated l1 fee: ${l1Fee}, total fee: ${fee.toString()}`);
        }
        return {
            totalCost: BigInt(fee.integerValue().toString()),
            gasPrice: BigInt(gasPrice.integerValue().toString()),
            gasLimit: BigInt(gasLimit.integerValue().toString()),
            chainId: chain,
        };
    }
    async getClaimUnlockExecutionFee(chain, provider, orderEstimationStage, payload) {
        const logger = (...params) => payload?.loggerInstance?.verbose("[getClaimUnlockExecutionFee]", ...params);
        const supportedChain = chain;
        if (!Object.values(common_type_1.SupportedEVMChains).includes(supportedChain))
            throw new client_error_error_1.ClientError(client_error_type_enum_1.ClientErrorType.UnsupportedChain);
        // claim_base + (claim_unlock_per_order)
        const gasLimit = await (0, gasprice_service_1.getCorrectedGasLimit)(chain, provider, EVM_GASLIMIT_CLAIM_BASE[supportedChain] + EVM_GASLIMIT_CLAIM_UNLOCK_PER_ORDER[supportedChain]);
        logger(`target gasLimit: ${gasLimit.toString()}`);
        // gas price
        const gasPrice = await (0, gasprice_service_1.predictGasPrice)(chain, provider, orderEstimationStage);
        logger(`predicted gasPrice: ${gasPrice.toString()}`);
        // cost
        let fee = gasPrice.multipliedBy(gasLimit);
        logger(`calculated tx fee: ${fee.toString()}`);
        // op stack
        if ((0, opstack_service_1.isOpStackBasedChain)(chain)) {
            const l1Fee = await (0, opstack_service_1.getL1FeeNativeCost)(chain, provider, OP_TXDATA_GAS_CLAIM_BATCH_UNLOCK, payload);
            fee = fee.plus(l1Fee.toString());
            logger(`calculated l1 fee: ${l1Fee}, total fee: ${fee.toString()}`);
        }
        return {
            totalCost: BigInt(fee.integerValue().toString()),
            gasPrice: BigInt(gasPrice.integerValue().toString()),
            gasLimit: BigInt(gasLimit.integerValue().toString()),
            chainId: chain,
        };
    }
    async getClaimCancelExecutionFee(chain, provider, orderEstimationStage, payload) {
        const logger = (...params) => payload?.loggerInstance?.verbose("[getClaimCancelExecutionFee]", ...params);
        const supportedChain = chain;
        if (!Object.values(common_type_1.SupportedEVMChains).includes(supportedChain))
            throw new client_error_error_1.ClientError(client_error_type_enum_1.ClientErrorType.UnsupportedChain);
        // claim_base + (claim_cancel_per_order)
        const gasLimit = await (0, gasprice_service_1.getCorrectedGasLimit)(chain, provider, EVM_GASLIMIT_CLAIM_BASE[supportedChain] + EVM_GASLIMIT_CLAIM_CANCEL_PER_ORDER[supportedChain]);
        logger(`target gasLimit: ${gasLimit.toString()}`);
        // gas price
        let gasPrice = await (0, gasprice_service_1.predictGasPrice)(chain, provider, orderEstimationStage);
        if (chain === common_types_1.ChainId.BSC) {
            gasPrice = bignumber_js_1.default.max(gasPrice, (0, bignumber_js_1.default)("5000000000")); // 5 gwei
        }
        logger(`predicted gasPrice: ${gasPrice.toString()}`);
        // cost
        let fee = gasPrice.multipliedBy(gasLimit);
        logger(`calculated tx fee: ${fee.toString()}`);
        // op stack
        if ((0, opstack_service_1.isOpStackBasedChain)(chain)) {
            const l1Fee = await (0, opstack_service_1.getL1FeeNativeCost)(chain, provider, OP_TXDATA_GAS_CLAIM_CANCEL, payload);
            fee = fee.plus(l1Fee.toString());
            logger(`calculated l1 fee: ${l1Fee}, total fee: ${fee.toString()}`);
        }
        return {
            totalCost: BigInt(fee.integerValue().toString()),
            gasPrice: BigInt(gasPrice.integerValue().toString()),
            gasLimit: BigInt(gasLimit.integerValue().toString()),
            chainId: chain,
        };
    }
    async getGlobalFixedNativeFee(provider, contractAddress) {
        const contract = this.getContract(provider, contractAddress);
        const result = await contract.methods.globalFixedNativeFee().call({});
        return result?.toString() || "0";
    }
    async getGlobalTransferFeeBps(provider, contractAddress) {
        const contract = this.getContract(provider, contractAddress);
        const result = await contract.methods.globalTransferFeeBps().call({});
        return result?.toString() || "0";
    }
    async giveOrder(provider, contractAddress, orderId) {
        const contract = this.getContract(provider, contractAddress);
        const result = (await contract.methods.giveOrders(orderId).call({}));
        if (result) {
            result.status = parseInt(result.status.toString(), 10);
        }
        return result || null;
    }
    async givePatches(provider, contractAddress, orderId) {
        const contract = this.getContract(provider, contractAddress);
        const patches = await contract.methods.givePatches(orderId).call({});
        if (!patches)
            return BigInt(0);
        return BigInt(patches);
    }
    createContract(provider, contractAddress) {
        return new provider.eth.Contract((this.version === env_1.Env.Prod ? DlnSource_json_1.default.abi : LimaDlnSource_json_1.default.abi), contractAddress);
    }
}
exports.DlnSourceService = DlnSourceService;
//# sourceMappingURL=dln-source.service.js.map
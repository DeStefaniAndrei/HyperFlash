"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DlnClient = void 0;
const tslib_1 = require("tslib");
const web3_1 = tslib_1.__importDefault(require("web3"));
const solana_utils_1 = require("@debridge-finance/solana-utils");
const common_type_1 = require("../types/common.type");
const dln_source_service_1 = require("../services/dln-source.service");
const dln_destination_service_1 = require("../services/dln-destination.service");
const client_error_error_1 = require("../../../errors/client-error.error");
const client_error_type_enum_1 = require("../../../errors/client-error-type.enum");
const debridge_gate_service_1 = require("../services/debridge-gate.service");
const common_types_1 = require("../../../common.types");
const service_type_enum_1 = require("../enums/service-type.enum");
const get_evm_info_1 = require("../utils/get.evm.info");
const crosschain_forwarder_service_1 = require("../services/crosschain-forwarder.service");
const logger_1 = require("../../../common/logger");
const order_data_to_evm_1 = require("../utils/order.data.to.evm");
const utils_1 = require("../../../utils");
const get_order_from_transaction_1 = require("../utils/get.order.from.transaction");
const give_orders_model_1 = require("../models/give-orders.model");
const env_1 = require("../../../common/env");
class DlnClient {
    getEngine() {
        return common_types_1.ChainEngine.EVM;
    }
    packCalldata(params, payload) {
        const envelopeVersion = 1;
        const web3 = new web3_1.default();
        const encodedTuple = web3.eth.abi.encodeParameters([
            {
                type: "tuple",
                name: "ExternalCallEnvelopV1",
                components: [
                    { name: "fallbackAddress", type: "address" },
                    { name: "executorAddress", type: "address" },
                    { name: "executionFee", type: "uint160" },
                    { name: "allowDelayedExecution", type: "bool" },
                    { name: "requireSuccessfullExecution", type: "bool" },
                    { name: "payload", type: "bytes" },
                ],
            },
        ], [
            {
                fallbackAddress: this.fromAddress(params.fallbackAddress),
                executorAddress: this.fromAddress(payload.executorAddress),
                executionFee: params.executionFee.toString(),
                allowDelayedExecution: params.allowDelayedExecution,
                requireSuccessfullExecution: params.requireSuccessfullExecution,
                payload: solana_utils_1.helpers.bufferToHex(params.payload),
            },
        ]);
        // chainEngine uint8, envelope version uint8, bytes envelope
        const data = web3.utils.encodePacked({ value: envelopeVersion.toString(), type: "uint8" }, { value: encodedTuple, type: "bytes" });
        if (data === null)
            throw new Error("Failed to encode!");
        return data;
    }
    unpackCalldata(calldata) {
        const web3 = new web3_1.default();
        const version = calldata[0];
        const decoded = web3.eth.abi.decodeParameters([
            {
                type: "tuple",
                name: "ExternalCallEnvelopV1",
                components: [
                    { name: "fallbackAddress", type: "address" },
                    { name: "executorAddress", type: "address" },
                    { name: "executionFee", type: "uint160" },
                    { name: "allowDelayedExecution", type: "bool" },
                    { name: "requireSuccessfullExecution", type: "bool" },
                    { name: "payload", type: "bytes" },
                ],
            },
        ], calldata.subarray(1).toString("hex"))[0];
        return {
            version,
            data: {
                allowDelayedExecution: decoded.allowDelayedExecution,
                requireSuccessfullExecution: decoded.requireSuccessfullExecution,
                payload: solana_utils_1.helpers.hexToBuffer(decoded.payload),
                executionFee: BigInt(decoded.executionFee),
                fallbackAddress: this.parseAddress(decoded.fallbackAddress),
                executorAddress: this.parseAddress(decoded.executorAddress),
            },
        };
    }
    constructor(config, version = env_1.Env.Prod) {
        this.config = config;
        this.version = version;
        /**
         * @internal
         */
        this.SOLANA_DENOMINATOR_DELTA = 8;
        this.nativeCurrencyDecimals = 18;
        this.addressLength = 20;
        this.cache = new Map();
        this.connectionManager = new Map();
        for (const [chain, chainConfig] of Object.entries(config.chainConfig)) {
            if (chainConfig.connection !== undefined)
                this.connectionManager.set(parseInt(chain), chainConfig.connection);
        }
        this.dlnSourceService = new dln_source_service_1.DlnSourceService(this.config.enableContractsCache, version);
        this.dlnDestinationService = new dln_destination_service_1.DlnDestinationService(this.config.enableContractsCache, version);
        this.debridgeGateService = new debridge_gate_service_1.DebridgeGateService(this.config.enableContractsCache);
        this.crosschainForwarderService = new crosschain_forwarder_service_1.CrossChainForwarderService();
        this.defaultLogger = new logger_1.Logger();
    }
    getConnection(chain) {
        const web3 = this.connectionManager.get(chain);
        if (!web3)
            throw new client_error_error_1.ClientError(client_error_type_enum_1.ClientErrorType.ConnectionMissing, `Failed to get connection for chain ${chain}`);
        return web3;
    }
    setConnection(chain, connection) {
        this.connectionManager.set(chain, connection);
    }
    get nativeAddress() {
        return Uint8Array.from(Array.from({ length: this.addressLength }).fill(0));
    }
    fromAddress(address) {
        return solana_utils_1.helpers.bufferToHex(address);
    }
    toAddress(nativeAddress) {
        return solana_utils_1.helpers.hexToBuffer(nativeAddress);
    }
    parseAddress(address) {
        return this.toAddress(address);
    }
    getForwarderAddress(chain) {
        return this.toAddress(this.getContractAddress(chain, service_type_enum_1.ServiceType.CrosschainForwarder));
    }
    async getWrappedNativeTokenAddress(chain) {
        const cacheKey = `getWrappedNativeTokenAddress_${chain}`;
        if (this.cache.has(cacheKey)) {
            return this.toAddress(this.cache.get(cacheKey));
        }
        const address = this.getContractAddress(chain, service_type_enum_1.ServiceType.DebridgeGate);
        const weth = await this.debridgeGateService.weth(this.getConnection(chain), address);
        this.cache.set(cacheKey, weth);
        return this.toAddress(weth);
    }
    buildCacheKey(prefix, chain, address) {
        return `${prefix}_${chain}_${this.fromAddress(address)}`;
    }
    async getDecimals(chain, tokenAddress) {
        const cacheKey = this.buildCacheKey("decimals", chain, tokenAddress);
        const cacheHit = this.cache.get(cacheKey);
        if (cacheHit) {
            return cacheHit;
        }
        else {
            const decimals = await (0, get_evm_info_1.getEvmDecimals)(this.fromAddress(tokenAddress), this.getConnection(chain));
            this.cache.set(cacheKey, decimals);
            return decimals;
        }
    }
    async getTokenInfo(chain, tokenAddress) {
        const cacheKey = this.buildCacheKey("tokenInfo", chain, tokenAddress);
        const cacheHit = this.cache.get(cacheKey);
        if (cacheHit) {
            return cacheHit;
        }
        else {
            const provider = this.getConnection(chain);
            const stringifiedAddress = this.fromAddress(tokenAddress);
            const [decimals, name, symbol] = await Promise.all([
                this.getDecimals(chain, tokenAddress),
                (0, get_evm_info_1.getEvmTokenName)(stringifiedAddress, chain, provider),
                (0, get_evm_info_1.getEvmTokenSymbol)(stringifiedAddress, chain, provider),
            ]);
            const result = {
                address: stringifiedAddress,
                chainId: chain,
                decimals,
                name,
                symbol,
            };
            this.cache.set(cacheKey, result);
            return result;
        }
    }
    patchOrderGive(params, payload) {
        const address = this.getContractAddress(params.order.give.chainId, service_type_enum_1.ServiceType.Source);
        const evmOrder = (0, order_data_to_evm_1.orderToEvm)(params.order);
        const method = this.dlnSourceService.getPatchOrderGiveMethod(this.getConnection(params.order.give.chainId), address, evmOrder, params.amountToAdd.toString(), payload?.permit || "0x");
        let value = BigInt(0);
        if ((0, utils_1.buffersAreEqual)(params.order.give.tokenAddress, this.nativeAddress)) {
            value = params.amountToAdd;
        }
        const tx = {
            data: method.encodeABI(),
            to: address,
            value: value.toString(),
        };
        return Promise.resolve(tx);
    }
    patchOrderTake(params, payload) {
        const address = this.getContractAddress(params.order.take.chainId, service_type_enum_1.ServiceType.Destination);
        const method = this.dlnDestinationService.getPatchOrderTakeMethod(this.getConnection(params.order.take.chainId), address, (0, order_data_to_evm_1.orderToEvm)(params.order), params.amountToSub.toString());
        const tx = {
            data: method.encodeABI(),
            to: address,
            value: 0,
        };
        return Promise.resolve(tx);
    }
    async getFinalGiveAmount(params, payload) {
        const address = this.getContractAddress(params.order.give.chainId, service_type_enum_1.ServiceType.Source);
        const patches = await this.dlnSourceService.givePatches(this.getConnection(params.order.give.chainId), address, params.order.orderId);
        return params.order.give.amount + patches;
    }
    async getFinalTakeAmount(params, payload) {
        const address = this.getContractAddress(params.order.take.chainId, service_type_enum_1.ServiceType.Destination);
        const patches = await this.dlnDestinationService.takePatches(this.getConnection(params.order.take.chainId), address, params.order.orderId);
        return params.order.take.amount - patches;
    }
    /**
     * @internal
     */
    async preswapAndCreateOrder(params, payload) {
        const currentChain = params.order.give.chainId;
        const { order, swapResult } = params;
        if ("evm" !== swapResult.engine) {
            throw new client_error_error_1.ClientError(client_error_type_enum_1.ClientErrorType.PropertyMissing, "Wrong swap response provided, missing 'solana' engine in swapResponse");
        }
        const provider = this.getConnection(currentChain);
        const { tx: { data: srcSwapCalldata, to: srcSwapRouter }, fromToken, toToken: pickedGiveToken, amountIn: giveTokenAmount, } = swapResult;
        const receiverCalldata = (await this.createOrder({ ...params, order }, { permit: "0x" })).data;
        const [sourceGlobalFixedNativeFee] = await Promise.all([
            this.getSourceGlobalFixedNativeFee(currentChain, provider),
        ]);
        let value = BigInt(sourceGlobalFixedNativeFee);
        if ((0, utils_1.buffersAreEqual)(fromToken, this.nativeAddress)) {
            value += giveTokenAmount;
        }
        const method = this.crosschainForwarderService.strictlySwapAndCall(provider, this.fromAddress(payload.sender), {
            _srcTokenIn: this.fromAddress(fromToken),
            _srcAmountIn: giveTokenAmount,
            _srcTokenInPermitEnvelope: payload.srcTokenInPermitEnvelope,
            _srcSwapRouter: srcSwapRouter,
            _srcSwapCalldata: srcSwapCalldata,
            _srcTokenOut: this.fromAddress(pickedGiveToken),
            _srcTokenExpectedAmountOut: order.give.amount,
            _srcTokenRefundRecipient: this.fromAddress(payload.srcTokenRefundRecipient),
            _receiver: this.getContractAddress(currentChain, service_type_enum_1.ServiceType.Source),
            _receiverCalldata: receiverCalldata,
        });
        return {
            value: value.toString(),
            data: method,
            to: this.getContractAddress(currentChain, service_type_enum_1.ServiceType.CrosschainForwarder),
        };
    }
    /**
     * @internal
     */
    async preswapAndFulfillOrder(params, payload) {
        const currentChain = params.order.take.chainId;
        const { data: receiverCalldata } = await this.fulfillOrder(params, {
            unlockAuthority: payload.unlockAuthority,
            permit: "0x",
            externalCallRewardBeneficiary: payload.externalCallRewardBeneficiary,
        });
        const { order } = params;
        if ("evm" !== params.swapResult.engine) {
            throw new client_error_error_1.ClientError(client_error_type_enum_1.ClientErrorType.PropertyMissing, "Wrong swap response provided, missing 'solana' engine in swapResponse");
        }
        const { tx: { data: swapCalldata, to: srcSwapRouter }, fromToken, amountIn, } = params.swapResult;
        let value = BigInt(0);
        if ((0, utils_1.buffersAreEqual)(fromToken, this.nativeAddress)) {
            value += amountIn;
        }
        const method = this.crosschainForwarderService.strictlySwapAndCallDln({
            _srcTokenIn: this.fromAddress(fromToken),
            _srcAmountIn: amountIn,
            _srcTokenInPermitEnvelope: payload.srcTokenInPermitEnvelope || "0x",
            _srcSwapRouter: srcSwapRouter,
            _srcSwapCalldata: swapCalldata,
            _srcTokenOut: this.fromAddress(order.take.tokenAddress),
            _srcTokenExpectedAmountOut: order.take.amount,
            // refund from fulfill's preswap is sent to the user (the maker) to limit taker's income
            _srcTokenRefundRecipient: this.fromAddress(payload.preswapChangeRecipient || order.receiver),
            _receiver: this.getContractAddress(currentChain, service_type_enum_1.ServiceType.Destination),
            _receiverCalldata: receiverCalldata,
            _orderId: solana_utils_1.helpers.bufferToHex(order.orderId),
        });
        return {
            value: value.toString(),
            data: method,
            to: this.getContractAddress(currentChain, service_type_enum_1.ServiceType.CrosschainForwarder),
        };
    }
    getBalance(chain, tokenAddress, wallet) {
        return (0, get_evm_info_1.getEvmAccountBalance)(this.fromAddress(tokenAddress), this.fromAddress(wallet), this.getConnection(chain));
    }
    async getFees(chain, amount) {
        const web3 = this.getConnection(chain);
        const fixFee = await this.getSourceGlobalFixedNativeFee(chain, web3);
        const transferFee = await this.getSourceGlobalTransferFeeBps(chain, web3);
        return {
            fixFee: BigInt(fixFee),
            transferFee: amount ? (amount * BigInt(transferFee)) / common_types_1.BPS_DENOMINATOR : BigInt(0),
            transferFeeBps: Number(transferFee),
        };
    }
    async getSourceGlobalFixedNativeFee(chainId, web3) {
        const key = `getSourceGlobalFixedNativeFee_${chainId}`;
        if (this.cache.has(key)) {
            return this.cache.get(key);
        }
        const address = this.getContractAddress(chainId, service_type_enum_1.ServiceType.Source);
        const result = await this.dlnSourceService.getGlobalFixedNativeFee(web3, address);
        this.cache.set(key, result);
        return result;
    }
    async getSourceGlobalTransferFeeBps(chainId, web3) {
        const key = `getSourceGlobalTransferFeeBps_${chainId}`;
        if (this.cache.has(key)) {
            return this.cache.get(key);
        }
        const address = this.getContractAddress(chainId, service_type_enum_1.ServiceType.Source);
        const result = this.dlnSourceService.getGlobalTransferFeeBps(web3, address);
        this.cache.set(key, result);
        return result;
    }
    async getGlobalTransferFeeBps(chainId, web3) {
        const key = `getGlobalTransferFeeBps_${chainId}`;
        if (this.cache.has(key)) {
            return Number(this.cache.get(key));
        }
        const data = await this.debridgeGateService.getGlobalTransferFeeBps(web3, this.getContractAddress(chainId, service_type_enum_1.ServiceType.DebridgeGate));
        this.cache.set(key, data);
        return Number(data);
    }
    async getGlobalFixedNativeFee(chainId, web3) {
        const key = `getGlobalFixedNativeFee_${chainId}`;
        if (this.cache.has(key)) {
            return BigInt(this.cache.get(key));
        }
        const res = await this.debridgeGateService.getGlobalFixedNativeFee(web3, this.getContractAddress(chainId, service_type_enum_1.ServiceType.DebridgeGate));
        this.cache.set(key, res);
        return BigInt(res);
    }
    async getAmountWithAccountedGateTransferFee(sendFromChainId, neededAmount, web3) {
        const transferFee = await this.getGlobalTransferFeeBps(sendFromChainId, web3);
        return (neededAmount * common_types_1.BPS_DENOMINATOR) / (common_types_1.BPS_DENOMINATOR - BigInt(transferFee));
    }
    async getValueWithIncludedFee(executionFee, chainId, web3) {
        executionFee = BigInt(executionFee.toString());
        const globalFixedNativeFee = await this.getGlobalFixedNativeFee(chainId, web3);
        const accountedExecutionFee = await this.getAmountWithAccountedGateTransferFee(chainId, executionFee, web3);
        const resultingValue = globalFixedNativeFee + accountedExecutionFee;
        return resultingValue;
    }
    async getValueWithIncludedFeeAndRewards(rewards, executionFee, chainId, web3) {
        executionFee = BigInt(executionFee.toString());
        const rewardSum = rewards.reduce((acc, reward) => acc + BigInt(reward.toString()), BigInt(0)) *
            BigInt(10) ** BigInt(this.nativeCurrencyDecimals - this.SOLANA_DENOMINATOR_DELTA);
        const rewardAndExecutionFee = executionFee + rewardSum;
        return this.getValueWithIncludedFee(rewardAndExecutionFee, chainId, web3);
    }
    async getCreateCost(params, payload) {
        return Promise.reject("Not implemented");
    }
    async getGiveOrderState(params, payload) {
        const contract = this.getContractAddress(params.giveChain, service_type_enum_1.ServiceType.Source);
        const web3 = this.getConnection(params.giveChain);
        const result = await this.dlnSourceService.giveOrder(web3, contract, params.orderId);
        if (result.status === give_orders_model_1.OrderGiveStatus.NotSet)
            return null;
        const statusMap = {
            [give_orders_model_1.OrderGiveStatus.Created]: 1 /* OrderState.Created */,
            [give_orders_model_1.OrderGiveStatus.ClaimedCancel]: 7 /* OrderState.ClaimedCancel */,
            [give_orders_model_1.OrderGiveStatus.ClaimedUnlock]: 6 /* OrderState.ClaimedUnlock */,
        };
        if (!Object.keys(statusMap).includes(result.status.toString()))
            throw new client_error_error_1.ClientError(client_error_type_enum_1.ClientErrorType.UnknownStatus, `unknown status ${result.status}`);
        return {
            status: statusMap[result.status],
        };
    }
    async getTakeOrderState(params, payload) {
        const contract = this.getContractAddress(params.takeChain, service_type_enum_1.ServiceType.Destination);
        const web3 = this.getConnection(params.takeChain);
        const result = await this.dlnDestinationService.takeOrders(web3, contract, params.orderId);
        if (result.status === "0")
            return null;
        const statusMap = {
            1: 2 /* OrderState.Fulfilled */,
            2: 3 /* OrderState.SentUnlock */,
            3: 5 /* OrderState.SentCancel */,
        };
        if (!Object.keys(statusMap).includes(result.status.toString()))
            throw new client_error_error_1.ClientError(client_error_type_enum_1.ClientErrorType.UnknownStatus, `unknown take status ${result.status}`); // unknown status
        return {
            giveChainId: Number(result.giveChainId),
            status: statusMap[result.status],
            takerAddress: this.toAddress(result.takerAddress),
        };
    }
    async createOrder(params, payload) {
        const { order, referralCode, affiliateFee } = params;
        const web3 = this.getConnection(order.give.chainId);
        let affiliateFeeStruct = "0x";
        if (affiliateFee !== undefined) {
            affiliateFeeStruct = web3.utils.encodePacked({ value: this.fromAddress(affiliateFee.beneficiary), type: "address" }, { value: affiliateFee.amount.toString(), type: "uint256" });
        }
        const address = this.getContractAddress(order.give.chainId, service_type_enum_1.ServiceType.Source);
        let value = BigInt(await this.getSourceGlobalFixedNativeFee(order.give.chainId, web3));
        if ((0, utils_1.buffersAreEqual)(order.give.tokenAddress, this.nativeAddress)) {
            value += order.give.amount;
        }
        let method;
        const evmOrder = (0, order_data_to_evm_1.orderToEvm)({
            ...order,
            nonce: undefined,
        });
        if (Object.prototype.hasOwnProperty.call(order, "nonce") && order.nonce !== undefined) {
            method = this.dlnSourceService.getCreateSaltedOrderMethod(web3, address, evmOrder, params.order.nonce, affiliateFeeStruct, referralCode || 0, payload.permit, params.metadata || "0x");
        }
        else {
            method = this.dlnSourceService.getCreateOrderMethod(web3, address, evmOrder, affiliateFeeStruct, referralCode || 0, payload.permit);
        }
        return {
            data: method.encodeABI(),
            to: address,
            value: value.toString(),
        };
    }
    async fulfillOrder(params, payload) {
        const { order } = params;
        const web3 = this.getConnection(order.take.chainId);
        const address = this.getContractAddress(order.take.chainId, service_type_enum_1.ServiceType.Destination);
        const method = this.dlnDestinationService.getFulfillOrderMethod(web3, address, order, (payload.fulFillAmount || (await this.getFinalTakeAmount(params, {}))).toString(), order.orderId, payload.permit, this.fromAddress(payload.unlockAuthority), payload.externalCallRewardBeneficiary);
        let value = BigInt(0);
        if ((0, utils_1.buffersAreEqual)(order.take.tokenAddress, this.nativeAddress)) {
            value += order.take.amount;
        }
        return Promise.resolve({
            data: method.encodeABI(),
            to: address,
            value: value.toString(),
        });
    }
    async sendCancelOrder(params, payload) {
        const { order, executionFee, cancelBeneficiary } = params;
        const web3 = this.getConnection(order.take.chainId);
        const address = this.getContractAddress(order.take.chainId, service_type_enum_1.ServiceType.Destination);
        switch ((0, common_types_1.getEngineByChainId)(order.give.chainId)) {
            case common_types_1.ChainEngine.EVM: {
                const method = this.dlnDestinationService.getSendEvmOrderCancelMethod(web3, address, (0, order_data_to_evm_1.orderToEvm)(order), this.fromAddress(cancelBeneficiary), executionFee.toString());
                const value = await this.getValueWithIncludedFee(executionFee, order.take.chainId, web3);
                return {
                    data: method.encodeABI(),
                    to: address,
                    value: value.toString(),
                };
            }
            case common_types_1.ChainEngine.Solana: {
                if (cancelBeneficiary.length != 32)
                    throw new client_error_error_1.ClientError(client_error_type_enum_1.ClientErrorType.WrongSolanaAddressLength);
                if (payload?.rewards === undefined)
                    throw new Error("No rewards provided");
                const method = this.dlnDestinationService.getSendSolanaOrderCancelMethod(web3, address, (0, order_data_to_evm_1.orderToEvm)(order), this.fromAddress(cancelBeneficiary), executionFee.toString(), payload.rewards[0].toString(), payload.rewards[1].toString());
                const value = await this.getValueWithIncludedFeeAndRewards(payload.rewards, executionFee, order.take.chainId, web3);
                const result = {
                    data: method.encodeABI(),
                    to: address,
                    value: value.toString(),
                };
                return result;
            }
        }
    }
    async sendUnlockOrder(params, payload) {
        const { order, beneficiary, executionFee } = params;
        const address = this.getContractAddress(order.take.chainId, service_type_enum_1.ServiceType.Destination);
        const web3 = this.getConnection(order.take.chainId);
        const encodedBeneficiary = solana_utils_1.helpers.bufferToHex(beneficiary);
        switch ((0, common_types_1.getEngineByChainId)(order.give.chainId)) {
            case common_types_1.ChainEngine.EVM: {
                const method = this.dlnDestinationService.getSendEvmUnlockMethod(web3, address, order.orderId, encodedBeneficiary, executionFee.toString());
                const value = await this.getValueWithIncludedFee(executionFee.toString(), order.take.chainId, web3);
                return {
                    data: method.encodeABI(),
                    value: value.toString(),
                    to: address,
                };
            }
            case common_types_1.ChainEngine.Solana: {
                if (beneficiary.length != 32)
                    throw new client_error_error_1.ClientError(client_error_type_enum_1.ClientErrorType.WrongSolanaAddressLength);
                const method = this.dlnDestinationService.getSendSolanaUnlockMethod(web3, address, (0, order_data_to_evm_1.orderToEvm)(order), encodedBeneficiary, executionFee.toString(), payload.rewards[0].toString(), payload.rewards[1].toString());
                const value = await this.getValueWithIncludedFeeAndRewards(payload.rewards, executionFee, order.take.chainId, web3);
                return {
                    data: method.encodeABI(),
                    value: value.toString(),
                    to: address,
                };
            }
        }
    }
    async sendBatchUnlock(params, payload) {
        const { orders, beneficiary, executionFee } = params;
        const takeChain = orders[0].take.chainId;
        const { tokenAddress: giveToken, chainId: giveChain } = orders[0].give;
        switch ((0, common_types_1.getEngineByChainId)(giveChain)) {
            case common_types_1.ChainEngine.Solana: {
                if (orders.find((o) => o.take.chainId !== takeChain ||
                    o.give.chainId !== giveChain ||
                    !(0, utils_1.buffersAreEqual)(o.give.tokenAddress, giveToken)) !== undefined) {
                    throw new client_error_error_1.ClientError(client_error_type_enum_1.ClientErrorType.WrongBatchOrders, `Orders with same giveChain, takeChain and giveToken are required for batch unlock`);
                }
                break;
            }
            case common_types_1.ChainEngine.EVM: {
                if (orders.find((o) => o.take.chainId !== takeChain || o.give.chainId !== giveChain) !== undefined) {
                    throw new client_error_error_1.ClientError(client_error_type_enum_1.ClientErrorType.WrongBatchOrders, `Orders with same giveChain and takeChain are required for batch unlock`);
                }
                break;
            }
        }
        const address = this.getContractAddress(takeChain, service_type_enum_1.ServiceType.Destination);
        const web3 = this.getConnection(takeChain);
        switch ((0, common_types_1.getEngineByChainId)(giveChain)) {
            case common_types_1.ChainEngine.Solana: {
                if (payload.solanaInitWalletReward === undefined || payload.solanaClaimUnlockReward === undefined)
                    throw new client_error_error_1.ClientError(client_error_type_enum_1.ClientErrorType.RewardsRequired, `Rewards for send batch unlock to solana are required`);
                const method = this.dlnDestinationService.sendBatchSolanaUnlock(web3, address, orders, beneficiary, executionFee, payload.solanaInitWalletReward, payload.solanaClaimUnlockReward);
                const value = await this.getValueWithIncludedFeeAndRewards([payload.solanaInitWalletReward, payload.solanaClaimUnlockReward * BigInt(orders.length)], executionFee, takeChain, web3);
                return {
                    data: method.encodeABI(),
                    value: value.toString(),
                    to: address,
                };
            }
            case common_types_1.ChainEngine.EVM: {
                const method = this.dlnDestinationService.sendBatchEvmUnlock(web3, address, orders.map((o) => o.orderId), solana_utils_1.helpers.bufferToHex(beneficiary), executionFee.toString());
                const value = await this.getValueWithIncludedFee(executionFee, takeChain, web3);
                return {
                    data: method.encodeABI(),
                    value: value.toString(),
                    to: address,
                };
            }
        }
    }
    getOrderFromTransaction(params, payload) {
        return (0, get_order_from_transaction_1.getOrderFromEvmTransaction)(params.txHash, this.getConnection(params.giveChain));
    }
    async getFulfillCost(params, payload) {
        const { takeChain } = params;
        if (!Object.values(common_type_1.SupportedEVMChains).includes(takeChain))
            throw new client_error_error_1.ClientError(client_error_type_enum_1.ClientErrorType.UnsupportedChain);
        const takeProvider = this.getConnection(takeChain);
        const result = await this.dlnDestinationService.getRawFulfillNativeCost(takeChain, takeProvider, payload.orderEstimationStage, payload.fulfillGasLimit, payload.fulfillCappedGasPrice, !(0, utils_1.buffersAreEqual)(params.equivalentToken, params.orderTakeToken), { loggerInstance: params.loggerInstance || this.defaultLogger });
        return result;
    }
    async getClaimExecutionFee(params, payload) {
        const { action, giveChain, giveNativePrice, takeNativePrice, takeDecimals, batchSize } = params;
        const giveConnection = this.getConnection(giveChain);
        let originNativeCost;
        switch (action) {
            case "ClaimCancel": {
                originNativeCost = await this.dlnSourceService.getClaimCancelExecutionFee(giveChain, giveConnection, payload.orderEstimationStage, { ...payload, loggerInstance: params.loggerInstance });
                break;
            }
            case "ClaimUnlock": {
                originNativeCost = await this.dlnSourceService.getClaimUnlockExecutionFee(giveChain, giveConnection, payload.orderEstimationStage, { ...payload, loggerInstance: params.loggerInstance });
                break;
            }
            case "ClaimBatchUnlock": {
                if (!batchSize)
                    throw new client_error_error_1.ClientError(client_error_type_enum_1.ClientErrorType.WrongBatchSize, "batch size required for batch unlock!");
                originNativeCost = await this.dlnSourceService.getClaimBatchUnlockExecutionFee(batchSize, giveChain, giveConnection, payload.orderEstimationStage, { ...payload, loggerInstance: params.loggerInstance });
                break;
            }
        }
        if (params.loggerInstance)
            params.loggerInstance.verbose(`originNativeCost: ${originNativeCost.totalCost}, give native price: ${giveNativePrice}, take native price: ${takeNativePrice}, take decimals: ${takeDecimals}`);
        const takeNativeCost = (0, utils_1.calcBigIntAmountViaCrossRate)(originNativeCost.totalCost, giveNativePrice, this.nativeCurrencyDecimals, takeNativePrice, takeDecimals);
        return {
            claimCost: takeNativeCost,
            rewards: [],
            total: takeNativeCost,
        };
    }
    async getClaimBatchUnlockCostForSingleOrder(params, payload) {
        const originNativeCost = await this.dlnSourceService.getClaimBatchUnlockNativeCostForSingleOrder(params.batchUnlockCoverage, params.giveChain, this.getConnection(params.giveChain), payload.orderEstimationStage, { ...payload, loggerInstance: params.loggerInstance });
        const takeNativeCost = (0, utils_1.calcBigIntAmountViaCrossRate)(originNativeCost.totalCost, params.giveNativePrice, this.nativeCurrencyDecimals, params.takeNativePrice, params.takeDecimals);
        return takeNativeCost;
    }
    async getSendUnlockCostForSingleOrder(params, payload) {
        const logger = (...args) => params.loggerInstance?.verbose("[getSendUnlockCostForSingleOrder]", ...args);
        const { giveChain, takeChain } = params;
        const takeConnection = this.getConnection(takeChain);
        const { totalCost: sendUnlockCostForSingleOrder } = await this.dlnDestinationService.getSendBatchUnlockNativeCostForSingleOrder(params.batchUnlockCoverage, giveChain, takeChain, takeConnection, payload.orderEstimationStage, { ...payload, loggerInstance: params.loggerInstance });
        logger("raw send_unlock cost for single order: ", sendUnlockCostForSingleOrder);
        const accountedExecutionFeeForSingleOrder = await this.getAmountWithAccountedGateTransferFee(takeChain, params.executionFeeForSingleOrder, takeConnection);
        logger("accounted execution fee for single order: ", accountedExecutionFeeForSingleOrder);
        const fixFee = await this.getGlobalFixedNativeFee(takeChain, takeConnection);
        const fixFeeForSingleOrder = (fixFee * BigInt(Math.round(params.batchUnlockCoverage * 100))) / 100n;
        logger("fix fee for single order", fixFeeForSingleOrder);
        if (!(0 <= params.discountPercents.batchUnlockFixFee && params.discountPercents.batchUnlockFixFee <= 100)) {
            throw new Error(`discountPercents.batchUnlockFixFee should be between 0 and 100`);
        }
        const fixFeeForSingleOrderWithDiscount = ((100n - params.discountPercents.batchUnlockFixFee) * fixFeeForSingleOrder) / 100n;
        logger("fix fee for single order with discount", fixFeeForSingleOrderWithDiscount);
        const totalCost = sendUnlockCostForSingleOrder + accountedExecutionFeeForSingleOrder + fixFeeForSingleOrderWithDiscount;
        logger("total cost", totalCost);
        return totalCost;
    }
    async getSendUnlockCost(params, payload) {
        let logger = (...args) => { };
        if (params?.loggerInstance) {
            logger = (...args) => params.loggerInstance.verbose("[getSendUnlockCost]", ...args);
        }
        const { giveChain, takeChain } = params;
        const takeConnection = this.getConnection(takeChain);
        const nativeCost = await this.dlnDestinationService.getSendBatchUnlockNativeCost(params.batchSize, giveChain, takeChain, takeConnection, payload.orderEstimationStage, { ...payload, loggerInstance: params.loggerInstance });
        logger("native cost for send unlock", nativeCost);
        const accountedExecutionFee = await this.getAmountWithAccountedGateTransferFee(takeChain, params.executionFee, takeConnection);
        logger("accounted execution fee", accountedExecutionFee);
        const fixFee = await this.getGlobalFixedNativeFee(takeChain, takeConnection);
        logger("fix fee", fixFee);
        const result = nativeCost.totalCost + accountedExecutionFee + fixFee;
        logger("final cost", result);
        return {
            transactionCost: nativeCost,
            accountedExecutionFee,
            fixFee,
            totalCost: result,
        };
    }
    async getSendCancelCost(params, payload) {
        let logger = (...args) => { };
        if (params?.loggerInstance) {
            logger = (...args) => params.loggerInstance.verbose("[getSendCancelCost]", ...args);
        }
        const { giveChain, takeChain } = params;
        const takeConnection = this.getConnection(takeChain);
        const nativeCost = await this.dlnDestinationService.getSendCancelCost(takeChain, giveChain, takeConnection, payload.orderEstimationStage, { loggerInstance: params.loggerInstance });
        logger("native cost for send cancel", nativeCost);
        const accountedExecutionFee = await this.getAmountWithAccountedGateTransferFee(takeChain, params.executionFee, takeConnection);
        logger("accounted execution fee", accountedExecutionFee);
        const fixFee = await this.getGlobalFixedNativeFee(takeChain, takeConnection);
        logger("fix fee", fixFee);
        const result = nativeCost.totalCost + accountedExecutionFee + fixFee;
        logger("final cost", result);
        return {
            transactionCost: nativeCost,
            accountedExecutionFee,
            fixFee,
            totalCost: result,
        };
    }
    getContractAddress(chainId, type) {
        const chainConfig = this.config.chainConfig[chainId];
        if (chainConfig === undefined)
            throw new client_error_error_1.ClientError(client_error_type_enum_1.ClientErrorType.UnsupportedChain, `Config for chain ${common_types_1.ChainId[chainId]} is missing`);
        const typeMap = {
            [service_type_enum_1.ServiceType.Source]: "dlnSourceAddress",
            [service_type_enum_1.ServiceType.Destination]: "dlnDestinationAddress",
            [service_type_enum_1.ServiceType.DebridgeGate]: "deBridgeGateAddress",
            [service_type_enum_1.ServiceType.CrosschainForwarder]: "crossChainForwarderAddress",
        };
        const address = chainConfig[typeMap[type]]; // can't set address to undefined in config
        return address;
    }
}
exports.DlnClient = DlnClient;
//# sourceMappingURL=dln-evm.client.js.map
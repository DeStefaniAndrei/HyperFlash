/// <reference types="node" />
import Web3 from "web3";
import { EvmCalldataEnvelope, EvmInstruction } from "../types/common.type";
import { DlnSourceService } from "../services/dln-source.service";
import { DlnDestinationService, FulfillNativeCostCalculationDetailsType } from "../services/dln-destination.service";
import { DlnConfig as DlnConfig } from "../models/config.model";
import { AbsoluteAffiliateFee, Address, ChainEngine, ChainId, DebridgeTransactionCost, DiscountPercents, GiveOrderStatus, OrderEstimationStage, OrderMeta, TakeOrderStatus, TokenMetadata, TransactionCostInNative } from "../../../common.types";
import { ServiceType } from "../enums/service-type.enum";
import { ClientImplementation } from "../../../common/client";
import { Logger } from "../../../common/logger";
import { OrderData, OrderDataWithId, OrderWithoutNonce } from "../../../order";
import { SwapConnectorResult } from "../../../swapConnector";
import { Env } from "../../../common/env";
export declare class DlnClient implements ClientImplementation<ChainEngine.EVM> {
    private config;
    private readonly version;
    /**
     * @internal
     */
    SOLANA_DENOMINATOR_DELTA: number;
    nativeCurrencyDecimals: number;
    addressLength: number;
    defaultLogger: Logger;
    readonly dlnSourceService: DlnSourceService;
    readonly dlnDestinationService: DlnDestinationService;
    private debridgeGateService;
    private crosschainForwarderService;
    private connectionManager;
    cache: Map<string, unknown>;
    getEngine(): ChainEngine.EVM;
    packCalldata(params: {
        executionFee: bigint;
        fallbackAddress: Address;
        allowDelayedExecution: boolean;
        requireSuccessfullExecution: boolean;
        payload: Uint8Array;
    }, payload: {
        executorAddress: Address;
    }): string;
    unpackCalldata(calldata: Buffer): EvmCalldataEnvelope;
    constructor(config: DlnConfig, version?: Env);
    getConnection(chain: ChainId): Web3;
    setConnection(chain: ChainId, connection: Web3): void;
    get nativeAddress(): Address;
    fromAddress(address: Uint8Array): string;
    toAddress(nativeAddress: string): Uint8Array;
    parseAddress(address: string): Uint8Array;
    getForwarderAddress(chain: ChainId): Address;
    getWrappedNativeTokenAddress(chain: ChainId): Promise<Address>;
    buildCacheKey(prefix: string, chain: ChainId, address: Address): string;
    getDecimals(chain: ChainId, tokenAddress: Address): Promise<number>;
    getTokenInfo(chain: ChainId, tokenAddress: Address): Promise<TokenMetadata>;
    patchOrderGive(params: {
        order: OrderDataWithId;
        amountToAdd: bigint;
        loggerInstance?: Logger;
    }, payload: {
        permit?: string;
    }): Promise<EvmInstruction>;
    patchOrderTake(params: {
        order: OrderDataWithId;
        amountToSub: bigint;
        loggerInstance?: Logger;
    }, payload: object): Promise<EvmInstruction>;
    getFinalGiveAmount(params: {
        order: OrderDataWithId;
        loggerInstance?: Logger;
    }, payload: object): Promise<bigint>;
    getFinalTakeAmount(params: {
        order: OrderDataWithId;
        loggerInstance?: Logger;
    }, payload: object): Promise<bigint>;
    /**
     * @internal
     */
    preswapAndCreateOrder(params: {
        order: OrderWithoutNonce | OrderData;
        referralCode?: number | undefined;
        affiliateFee?: AbsoluteAffiliateFee;
        swapResult: SwapConnectorResult;
        loggerInstance?: Logger;
        metadata?: Buffer;
    }, payload: {
        sender: Address;
        srcTokenRefundRecipient: Address;
        srcTokenInPermitEnvelope: string;
    }): Promise<EvmInstruction>;
    /**
     * @internal
     */
    preswapAndFulfillOrder(params: {
        order: OrderDataWithId;
        swapResult: SwapConnectorResult;
        taker: Address;
        loggerInstance?: Logger;
    }, payload: {
        unlockAuthority: Address;
        externalCallRewardBeneficiary?: Address;
        srcTokenInPermitEnvelope?: string;
        preswapChangeRecipient?: Address;
    }): Promise<EvmInstruction>;
    getBalance(chain: ChainId, tokenAddress: Address, wallet: Address): Promise<bigint>;
    getFees(chain: ChainId, amount?: bigint | undefined): Promise<{
        fixFee: bigint;
        transferFee: bigint;
        transferFeeBps: number;
    }>;
    getSourceGlobalFixedNativeFee(chainId: ChainId, web3: Web3): Promise<string>;
    getSourceGlobalTransferFeeBps(chainId: ChainId, web3: Web3): Promise<string>;
    getGlobalTransferFeeBps(chainId: ChainId, web3: Web3): Promise<number>;
    getGlobalFixedNativeFee(chainId: ChainId, web3: Web3): Promise<bigint>;
    getAmountWithAccountedGateTransferFee(sendFromChainId: ChainId, neededAmount: bigint, web3: Web3): Promise<bigint>;
    private getValueWithIncludedFee;
    private getValueWithIncludedFeeAndRewards;
    getCreateCost(params: {
        giveChain: ChainId;
        inToken: Uint8Array;
        outToken: Uint8Array;
        loggerInstance?: Logger;
    }, payload: object): Promise<TransactionCostInNative>;
    getGiveOrderState(params: {
        orderId: string | Uint8Array;
        giveChain: ChainId;
        loggerInstance?: Logger;
    }, payload: object): Promise<GiveOrderStatus | null>;
    getTakeOrderState(params: {
        orderId: string | Uint8Array;
        takeChain: ChainId;
        loggerInstance?: Logger;
    }, payload: object): Promise<TakeOrderStatus | null>;
    createOrder(params: {
        order: OrderWithoutNonce | OrderData;
        referralCode?: number;
        affiliateFee?: AbsoluteAffiliateFee;
        loggerInstance?: Logger;
        metadata?: Buffer;
    }, payload: {
        permit: string;
    }): Promise<EvmInstruction>;
    fulfillOrder(params: {
        order: OrderDataWithId;
        loggerInstance?: Logger;
    }, payload: {
        permit: string;
        unlockAuthority: Address;
        fulFillAmount?: bigint;
        externalCallRewardBeneficiary?: Address;
    }): Promise<EvmInstruction>;
    sendCancelOrder(params: {
        order: OrderDataWithId;
        executionFee: bigint;
        cancelBeneficiary: Address;
        loggerInstance?: Logger;
    }, payload: {
        rewards: bigint[];
    }): Promise<EvmInstruction>;
    sendUnlockOrder(params: {
        order: OrderDataWithId;
        beneficiary: Address;
        executionFee: bigint;
        loggerInstance?: Logger;
    }, payload: {
        rewards: bigint[];
    }): Promise<EvmInstruction>;
    sendBatchUnlock(params: {
        orders: OrderDataWithId[];
        beneficiary: Address;
        executionFee: bigint;
        loggerInstance?: Logger;
    }, payload: {
        solanaInitWalletReward?: bigint;
        solanaClaimUnlockReward?: bigint;
    }): Promise<EvmInstruction>;
    getOrderFromTransaction(params: {
        giveChain: ChainId;
        txHash: string;
        loggerInstance?: Logger;
    }, payload: object): Promise<(OrderDataWithId & OrderMeta & {
        affiliateInfo: AbsoluteAffiliateFee | undefined;
    }) | null>;
    getFulfillCost(params: {
        equivalentToken: Address;
        orderTakeToken: Address;
        takeChain: ChainId;
        loggerInstance?: Logger;
    }, payload: FulfillNativeCostCalculationDetailsType): Promise<TransactionCostInNative>;
    getClaimExecutionFee(params: {
        giveChain: ChainId;
        takeChain: ChainId;
        giveNativePrice: number;
        takeNativePrice: number;
        takeDecimals: number;
        batchSize?: number | undefined;
        action: "ClaimUnlock" | "ClaimCancel" | "ClaimBatchUnlock";
        loggerInstance?: Logger;
    }, payload: {
        orderEstimationStage: OrderEstimationStage;
    }): Promise<{
        claimCost: bigint;
        rewards: bigint[];
        total: bigint;
    }>;
    getClaimBatchUnlockCostForSingleOrder(params: {
        giveChain: ChainId;
        takeChain: ChainId;
        giveNativePrice: number;
        takeToken: Uint8Array;
        takeNativePrice: number;
        takeDecimals: number;
        batchUnlockCoverage: number;
        loggerInstance?: Logger | undefined;
    }, payload: {
        orderEstimationStage: OrderEstimationStage;
    }): Promise<bigint>;
    getSendUnlockCostForSingleOrder(params: {
        giveChain: ChainId;
        takeChain: ChainId;
        executionFeeForSingleOrder: bigint;
        batchUnlockCoverage: number;
        loggerInstance?: Logger;
        discountPercents: DiscountPercents;
    }, payload: {
        orderEstimationStage: OrderEstimationStage;
    }): Promise<bigint>;
    getSendUnlockCost(params: {
        giveChain: ChainId;
        takeChain: ChainId;
        executionFee: bigint;
        batchSize: number;
        loggerInstance?: Logger;
    }, payload: {
        orderEstimationStage: OrderEstimationStage;
    }): Promise<DebridgeTransactionCost>;
    getSendCancelCost(params: {
        giveChain: ChainId;
        takeChain: ChainId;
        executionFee: bigint;
        loggerInstance?: Logger;
    }, payload: {
        orderEstimationStage: OrderEstimationStage;
    }): Promise<DebridgeTransactionCost>;
    getContractAddress(chainId: ChainId, type: ServiceType): string;
}
//# sourceMappingURL=dln-evm.client.d.ts.map
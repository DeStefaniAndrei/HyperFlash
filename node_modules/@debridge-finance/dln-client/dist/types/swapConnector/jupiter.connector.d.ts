/// <reference types="node" />
import { Connection, PublicKey } from "@solana/web3.js";
import { Logger } from "../common/logger";
import { Address, ChainId } from "../common.types";
import { SwapConnector } from ".";
import { SwapConnectorQuoteRequest, SwapConnectorQuoteResult, SwapConnectorRequest, SwapConnectorResult } from "./swap.connector";
import { MaskCredentialFunction, SwapConnectorLogger } from "./swap-connector.logger";
/**
 * @internal
 */
type RouteFees = {
    signatureFee: number;
    openOrdersDeposits: number[];
    ataDeposits: number[];
    totalFeeAndDeposits: number;
    minimumSOLForTransaction: number;
};
/**
 * @internal
 */
type MarketInfo = {
    id: string;
    label: string;
    inputMint: string;
    outputMint: string;
    notEnoughLiquidity: boolean;
    inAmount: string;
    outAmount: string;
    minInAmount: string;
    minOutAmount: string;
    priceImpactPct: number;
    lpFee: {
        amount: string;
        mint: string;
        pct: number;
    };
    platformFee: {
        amount: string;
        mint: string;
        pct: number;
    };
};
/**
 * @internal
 */
type Route = {
    inAmount: string;
    outAmount: string;
    priceImpactPct: number;
    marketInfos: MarketInfo[];
    amount: string;
    slippageBps: number;
    otherAmountThreshold: string;
    swapMode: "ExactIn" | "ExactOut";
    fees: RouteFees | null;
    wrapUnwrapSOL: boolean;
};
/**
 * @internal
 */
export type JupiterV4QuoteResponse = {
    data: Route[];
    timeTaken: number;
    contextSlot: number;
};
type SwapInfo = {
    swapInfo: {
        ammKey: string;
        label?: string;
        inputMint: string;
        outputMint: string;
        outAmount: string;
        inAmount: string;
        feeAmount: string;
        feeMint: string;
    };
};
/**
 * @internal
 */
export type JupiterV6QuoteResponse = {
    wrapAndUnwrapSol: boolean;
    inputMint: string;
    inAmount: string;
    outputMint: string;
    outAmount: string;
    otherAmountThreshold: string;
    slippageBps: number;
    routePlan: ({
        percent: number;
    } & SwapInfo)[];
};
/**
 * @internal
 */
export type JupiterV6SwapResponse = {
    swapTransaction: string;
    lastValidBlockHeight: number;
    prioritizationFeeLamports: number;
};
/**
 * @internal
 */
export type JupiterSwapResponse = {
    setupTransaction?: string;
    swapTransaction: string;
    cleanupTransaction?: string;
};
type RouteFilter = (route: Route) => boolean;
type AllowRestrictIntermediateTokensFunction = (request: SwapConnectorQuoteRequest) => boolean;
type JupiterV6Config = {
    connection: Connection;
    customApiURL?: string;
    jupiterAccessToken?: string;
    maxAccounts?: number;
    routeLimiter?: JupiterRouteLimiter;
    timeoutInMs?: number;
    allowRestrictIntermediateTokensFunction?: AllowRestrictIntermediateTokensFunction;
};
export declare abstract class JupiterRouteLimiter {
    #private;
    /**
     * Fetches DEXes supported by Jupiter
     * @returns current list of all supported DEXes by jupiter
     */
    getAllDexes(): Promise<string[]>;
    /**
     * Exclude list of DEXes from route
     * @param dexesToExclude
     * @returns excludeDexes list
     */
    blacklist(dexesToExclude: string[]): string[];
    /**
     * Exclude all except dexesToInclude from route
     * @param dexesToInclude
     * @returns excludeDexes list
     */
    whitelist(dexesToInclude: string[]): string[];
    abstract getExcludedDexes(swapInfo: SwapConnectorQuoteRequest): Promise<string[]>;
}
/**
 * @internal
 */
declare abstract class JupiterBase extends SwapConnector {
    #private;
    protected connection: Connection;
    protected NATIVE_MINT: string;
    protected ALTMap: Map<string, string>;
    protected readonly maskCredentialFunction: MaskCredentialFunction;
    constructor(connection: Connection, jupiterAccessToken?: string, timeoutInMs?: number);
    abstract getEstimate(request: SwapConnectorQuoteRequest, context: {
        logger: Logger;
    }): Promise<SwapConnectorQuoteResult>;
    abstract getSwap(request: SwapConnectorRequest, context: {
        logger: Logger;
    }): Promise<SwapConnectorResult>;
    getSupportedChains(): ChainId[];
    /** wrapUnwrapSol default is true
     * We might want to set it to false when source/destination token is wrapped sol
     **/
    protected fixWSolAddress(fromTokenAddress: Address, toTokenAddress: Address): [string, string, boolean];
    protected filterExistingWallets(connection: Connection, wallets: PublicKey[]): Promise<PublicKey[]>;
    getTokenPriceInSol(tokenAddress: Uint8Array, context: {
        logger: Logger;
    }): Promise<number>;
    protected callJupiter<T>(basicUrl: string, path: string, query: URLSearchParams, logger: SwapConnectorLogger, body?: string): Promise<T>;
}
export declare class JupiterConnectorV6 extends JupiterBase implements SwapConnector {
    #private;
    constructor(config: JupiterV6Config);
    setMaxAccounts(count: number): void;
    getEstimate(request: SwapConnectorQuoteRequest, context: {
        logger: Logger;
    }): Promise<SwapConnectorQuoteResult>;
    getSwap(request: SwapConnectorRequest, context: {
        logger: Logger;
        removePriorityFeeIxs?: boolean;
    }): Promise<SwapConnectorResult>;
    get connectorName(): string;
}
export declare class JupiterConnectorV4 extends JupiterBase implements SwapConnector {
    #private;
    private routeFilter;
    constructor(connection: Connection, routeFilter?: RouteFilter, customApiURL?: string, jupiterAccessToken?: string, timeoutInMs?: number);
    getEstimate(request: SwapConnectorQuoteRequest, context: {
        logger: Logger;
    }): Promise<SwapConnectorQuoteResult>;
    getSwap(request: SwapConnectorRequest, context: {
        logger: Logger;
    }): Promise<SwapConnectorResult>;
    get connectorName(): string;
}
export {};
//# sourceMappingURL=jupiter.connector.d.ts.map
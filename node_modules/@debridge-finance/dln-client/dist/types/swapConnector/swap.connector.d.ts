/// <reference types="node" />
import { AddressLookupTableAccount, PublicKey, TransactionInstruction } from "@solana/web3.js";
import { Address, ChainId } from "../common.types";
import { Logger } from "../common/logger";
import { SwapConnectorLogger } from "./swap-connector.logger";
export declare function bpsToPercent(bps: number): number;
export type SwapConnectorQuoteResult = {
    chainId: ChainId;
    fromTokenAddress: Address;
    toTokenAddress: Address;
    amountIn: bigint;
    amountOut: bigint;
    /**
     * Raw response from connector, can be casted to correct type like `oneInch.IQuoteResponse`
     */
    rawConnectorResponse?: unknown;
};
export type SwapConnectorQuoteRequest = {
    chainId: ChainId;
    slippageBps: number;
    fromTokenAddress: Address;
    toTokenAddress: Address;
    amountIn: bigint;
    routeHint?: SwapConnectorQuoteResult | SwapConnectorResult;
    affiliateFeeBps?: number;
};
export type SwapConnectorResult = {
    amountOut: bigint;
    amountIn: bigint;
    rawConnectorResponse: unknown;
    fromToken: Address;
    toToken: Address;
} & ({
    engine: "solana";
    swapInstructions: TransactionInstruction[];
    ALTs: (AddressLookupTableAccount | PublicKey)[];
    prioritizationFeeLamports: number;
} | {
    engine: "evm";
    tx: {
        data: string;
        to: string;
        value: string;
    };
});
export type SwapConnectorRequest = {
    /**
     * An EOA address that initiate the transaction
     */
    origin?: Address;
    chainId: ChainId;
    fromTokenAddress: Address;
    toTokenAddress: Address;
    amountIn: bigint;
    fromAddress: Address;
    destReceiver?: Address;
    slippageBps: number;
    affiliateFeeBps?: number;
    affiliateFeeRecipient?: Address;
    /**
     * raw connector response will be used to extract routes used by the swap/quote.
     * Applicable for 1Inch
     */
    routeHint?: SwapConnectorQuoteResult | SwapConnectorResult;
};
type CallParams = {
    basicUrl: string;
    path: string;
    query: URLSearchParams;
    headers: Record<string, string>;
    method?: string;
    body?: string;
    timeoutInMs?: number;
};
type CallContext = {
    logger: SwapConnectorLogger;
};
export declare abstract class SwapConnector {
    #private;
    abstract getSwap(request: SwapConnectorRequest, context: {
        logger: Logger;
    }): Promise<SwapConnectorResult>;
    abstract getEstimate(request: SwapConnectorQuoteRequest, context: {
        logger: Logger;
    }): Promise<SwapConnectorQuoteResult>;
    abstract getSupportedChains(): ChainId[];
    abstract get connectorName(): string;
    protected call<T>(params: CallParams, context: CallContext): Promise<T>;
}
export {};
//# sourceMappingURL=swap.connector.d.ts.map
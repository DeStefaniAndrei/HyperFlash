/// <reference types="node" />
import { Buffer } from "buffer";
import { Address, ChainId } from "./common.types";
export interface ExternalCallParams {
    externalCallHash?: Uint8Array;
    externalCallData: Uint8Array;
}
export interface Offer {
    tokenAddress: Address;
    chainId: ChainId;
    amount: bigint;
}
export interface OrderData {
    nonce: bigint;
    maker: Address;
    give: Offer;
    take: Offer;
    receiver: Address;
    givePatchAuthority: Address;
    orderAuthorityDstAddress: Address;
    allowedTaker?: Address;
    allowedCancelBeneficiary?: Address;
    externalCall?: ExternalCallParams;
}
export interface OrderDataWithId extends OrderData {
    orderId: Uint8Array;
}
export declare class Order {
    private static initLayout;
    private static orderDataToOrderLayout;
    static serialize(data: OrderData): Uint8Array;
    static deserialize(data: Uint8Array, omitCalldata?: boolean): OrderData;
    static getExternalCallHash(data: ExternalCallParams): Uint8Array | Buffer;
    static calculateId(order: OrderData): string;
    static verify(order: OrderDataWithId): boolean;
    static buildOrderDataWithId(order: OrderData): OrderDataWithId;
    /**
     * Verifies order if order id is present else builds OrderDataWithId.
     * If order id is present but verification fails throws `ClientErrorType.WrongOrderId`
     * @param order order data with or without orderId
     * @returns
     */
    static getVerified(order: OrderData | OrderDataWithId): OrderDataWithId;
}
export type OrderWithoutNonce = Omit<OrderData, "nonce">;
export interface PartialOrder extends Omit<OrderWithoutNonce, "take"> {
    take: {
        chainId: ChainId;
        tokenAddress: Address;
    };
}
export declare class PartialOrder {
    static decimals: number;
}
//# sourceMappingURL=order.d.ts.map
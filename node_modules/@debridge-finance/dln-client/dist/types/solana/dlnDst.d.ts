/// <reference types="node" />
import { Buffer } from "buffer";
import { Program } from "@coral-xyz/anchor";
import { PublicKey, Connection, Transaction, TransactionInstruction, AddressLookupTableAccount, Commitment } from "@solana/web3.js";
import { DeBridgeSolanaClient } from "@debridge-finance/solana-contracts-client";
import { dlnDstResolver } from "@debridge-finance/solana-utils";
import { OrderDataWithId } from "../order";
import { Address, ChainId, DebridgeTransactionCost, TakeOrderStatus } from "../common.types";
import { Env } from "../common/env";
import { DlnDst } from "./idl/dst";
import { DlnDst as LimaDlnDst } from "./idl/lima_dst";
import { DlnDst as HanoiDlnDst } from "./idl/hanoi_dst";
import { NonCompiledTransaction } from ".";
type SolanaPubkey = string | PublicKey;
type ExecutionFeeWithRewards = {
    rewards: bigint[];
    claimCost: bigint;
    total: bigint;
    executionCost: bigint;
};
export declare class DLNDst {
    private readonly version;
    program: Program<DlnDst> | Program<LimaDlnDst> | Program<HanoiDlnDst>;
    private cachedSendALT;
    accountsResolver: ReturnType<typeof dlnDstResolver>["methods"];
    debridge: DeBridgeSolanaClient;
    constructor(programId: SolanaPubkey, debridgeId: SolanaPubkey, debridgeSettingsId: SolanaPubkey, connection: Connection, version?: Env);
    setConnection(connection: Connection): void;
    getExecutorAddress(atomic?: boolean): PublicKey;
    getDLNFulfillALTAccounts(chains: ChainId[]): PublicKey[];
    getDLNSendALTAccounts(chains: ChainId[]): Promise<PublicKey[]>;
    private getALTAccountsForDebridgeSend;
    getSendALT(): Promise<AddressLookupTableAccount>;
    buildSendingContext(targetChainId: Buffer, beneficiary: Buffer, extCallData?: Buffer): Promise<{
        debridgeProgram: PublicKey;
        bridge: PublicKey;
        tokenMint: PublicKey;
        stakingWallet: PublicKey;
        mintAuthority: PublicKey;
        chainSupportInfo: PublicKey;
        splTokenProgram: PublicKey;
        settingsProgram: PublicKey;
        state: PublicKey;
        feeBeneficiary: PublicKey;
        nonceStorage: PublicKey;
        sendFromWallet: PublicKey;
        sendFrom: PublicKey;
        bridgeFee: PublicKey;
        discount: PublicKey;
        systemProgram: PublicKey;
        externalCallStorage: PublicKey;
        externalCallMeta: PublicKey;
    }>;
    getFulfillCost(params: {
        priorityFee?: bigint;
        isOrderWithCalldata?: boolean;
        isNative?: boolean;
    }): Promise<bigint>;
    getAmountWithAccountedGateTransferFee(sendToChainId: ChainId, neededAmount: bigint): Promise<bigint>;
    getSendCost(giveChainId: ChainId, targetExecutionFeeInLamports: bigint, mode: "unlock" | "batchUnlock" | "cancel", batchSize?: number, priorityFee?: bigint): Promise<DebridgeTransactionCost>;
    getClaimExecutionFees(takeChainAddressLength: number, takeChainId: ChainId, takeChainToken: string | Buffer, solPrice: number, tokenPrice: number, tokenDecimals: number, mode: "cancel" | "unlock" | "batchUnlock", batchSize?: number): Promise<ExecutionFeeWithRewards>;
    private alignBeneficiary;
    private buildCancelCalldata;
    private buildUnlockCalldata;
    private buildBatchUnlockCalldata;
    sendBatchUnlock(unlocker: SolanaPubkey, orderIds: (string | Uint8Array)[], giveChain: ChainId, beneficiary: Buffer, executionFee: bigint, unlockerWallet?: PublicKey): Promise<NonCompiledTransaction>;
    cancelOrder(canceler: PublicKey | string, order: OrderDataWithId): Promise<TransactionInstruction>;
    sendOrderCancel(canceler: PublicKey | string, orderId: string | Buffer, giveChain: ChainId, cancelBeneficiary: Address, executionFee: bigint, cancelerWallet?: PublicKey): Promise<NonCompiledTransaction>;
    buildFullCancelTransaction(canceler: SolanaPubkey, orderId: string | Buffer, giveChain: ChainId, orderWithId: OrderDataWithId, cancelBeneficiary: Buffer, executionFee: bigint, cancelerWallet?: PublicKey): Promise<NonCompiledTransaction>;
    sendUnlock(unlocker: SolanaPubkey, orderId: string | Buffer, giveChain: ChainId, beneficiary: Buffer, executionFee: bigint, unlockerWallet?: PublicKey): Promise<NonCompiledTransaction>;
    fulfillOrder(order: OrderDataWithId, taker: PublicKey, unlockAuthority?: PublicKey, takerWallet?: PublicKey, initMissingRecieverWallet?: boolean): Promise<Transaction>;
    getPatchedTakeAmount(orderId: string | Uint8Array): Promise<bigint | null>;
    patchTake(patcher: SolanaPubkey, order: OrderDataWithId, subtrahend: bigint): Promise<Transaction>;
    getTakeOrderState(orderId: string | Uint8Array, commitment?: Commitment): Promise<null | TakeOrderStatus>;
    getMultipleTakeOrderState(orderId: (string | Uint8Array | PublicKey)[], commitment?: Commitment): Promise<(null | TakeOrderStatus)[]>;
}
export {};
//# sourceMappingURL=dlnDst.d.ts.map
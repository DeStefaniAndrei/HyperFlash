/// <reference types="node" />
import { AddressLookupTableAccount, Commitment, Connection, PublicKey, Transaction, TransactionInstruction } from "@solana/web3.js";
import { AbsoluteAffiliateFee, Address, ChainEngine, ChainId, DiscountPercents, GiveOrderStatus, OrderMeta, TakeOrderStatus, TokenMetadata, TransactionCostInNative } from "../common.types";
import { ClientImplementation } from "../common/client";
import { Logger } from "../common/logger";
import { OrderData, OrderDataWithId, OrderWithoutNonce } from "../order";
import { SwapConnectorResult } from "../swapConnector/swap.connector";
import { Env } from "../common/env";
import { DLNDst } from "./dlnDst";
import { DLNSrc } from "./dlnSrc";
type SolanaPubkey = string | PublicKey;
export type NonCompiledTransaction = {
    instructions: TransactionInstruction[];
    ALTs?: AddressLookupTableAccount[];
    payer: PublicKey;
};
export declare class DlnClient implements ClientImplementation {
    connection: Connection;
    source: DLNSrc;
    destination: DLNDst;
    cache: Map<string, unknown>;
    defaultLogger: Logger;
    /**
     * @internal
     */
    fulfillPreswapALT: PublicKey | null;
    /**
     * @internal
     */
    createPreswapALT: PublicKey | null;
    constructor(connection: Connection, srcId: SolanaPubkey, dstId: SolanaPubkey, debridgeId: SolanaPubkey, debridgeSettingsId: SolanaPubkey, ALTs?: {
        createPreswap?: PublicKey;
        fulfillPreswap?: PublicKey;
    }, logger?: Logger, version?: Env);
    getBalance(chain: ChainId, tokenAddress: Address, wallet: Address): Promise<bigint>;
    get nativeAddress(): Address;
    nativeCurrencyDecimals: number;
    addressLength: number;
    getConnection(chain: ChainId): Connection;
    setConnection(chain: ChainId, connection: Connection): void;
    fromAddress(address: Address): PublicKey;
    private fromAddressMaybe;
    toAddress(nativeAddress: PublicKey): Uint8Array;
    parseAddress(address: string): Uint8Array;
    getWrappedNativeTokenAddress(chain: ChainId): Promise<Address>;
    getEngine(): ChainEngine.Solana;
    getFees(chain: ChainId, amount?: bigint | undefined): Promise<{
        fixFee: bigint;
        transferFee: bigint;
        transferFeeBps: number;
    }>;
    getClaimBatchUnlockCostForSingleOrder(params: {
        giveChain: ChainId;
        takeChain: ChainId;
        giveNativePrice: number;
        takeToken: Address;
        takeNativePrice: number;
        takeDecimals: number;
        batchUnlockCoverage: number;
        loggerInstance?: Logger | undefined;
    }, payload: object): Promise<bigint>;
    getClaimExecutionFee<Action extends "ClaimUnlock" | "ClaimCancel" | "ClaimBatchUnlock">(params: {
        giveChain: ChainId;
        takeChain: ChainId;
        giveNativePrice: number;
        takeToken: Address;
        takeNativePrice: number;
        takeDecimals: number;
        batchSize: Action extends "ClaimBatchUnlock" ? number : 1;
        action: Action;
    }, payload: object): Promise<{
        claimCost: bigint;
        total: bigint;
        rewards: bigint[];
    }>;
    getFulfillCost(params: {
        takeChain: ChainId;
        equivalentToken: Address;
        orderTakeToken: Address;
    }, payload: {
        priorityFee?: bigint;
        isOrderWithCalldata?: boolean;
    }): Promise<TransactionCostInNative>;
    getSendCancelCost(params: {
        giveChain: ChainId;
        takeChain: ChainId;
        executionFee: bigint;
    }, payload: {
        priorityFee?: bigint;
    }): Promise<import("../common.types").DebridgeTransactionCost>;
    getSendUnlockCost(params: {
        giveChain: ChainId;
        takeChain: ChainId;
        executionFee: bigint;
        batchSize: number;
    }, payload: {
        priorityFee?: bigint;
    }): Promise<import("../common.types").DebridgeTransactionCost>;
    getSendUnlockCostForSingleOrder(params: {
        giveChain: ChainId;
        takeChain: ChainId;
        executionFeeForSingleOrder: bigint;
        batchUnlockCoverage: number;
        discountPercents: DiscountPercents;
        loggerInstance: Logger;
    }, payload: {
        priorityFee?: bigint;
    }): Promise<bigint>;
    getGiveOrderState(params: {
        orderId: Uint8Array | string;
        giveChain: ChainId;
    }, payload: {
        confirmationsCount?: number;
    }): Promise<GiveOrderStatus | null>;
    getTakeOrderState(params: {
        orderId: string | Uint8Array;
        takeChain: ChainId;
    }, payload: {
        confirmationsCount?: number;
    }): Promise<TakeOrderStatus | null>;
    patchOrderGive(params: {
        order: OrderDataWithId;
        amountToAdd: bigint;
    }, payload: object): Promise<NonCompiledTransaction>;
    patchOrderTake(params: {
        order: OrderDataWithId;
        amountToSub: bigint;
    }, payload: {
        patcher: Address;
    }): Promise<NonCompiledTransaction>;
    getFinalGiveAmount(params: {
        order: OrderDataWithId;
    }, payload: object): Promise<bigint>;
    getFinalTakeAmount(params: {
        order: OrderDataWithId;
    }, payload: object): Promise<bigint>;
    /**
     *
     * @param params
     * @param payload chain-specific params
     * @param payload.makerWallet optional maker wallet, if not set default ATA(maker, giveToken) will be used
     * @returns
     */
    createOrder(params: {
        order: OrderWithoutNonce | OrderData;
        referralCode?: number;
        affiliateFee?: AbsoluteAffiliateFee;
        metadata?: Buffer;
    }, payload: {
        makerWallet?: Address;
    }): Promise<NonCompiledTransaction>;
    /**
     * @internal
     */
    preswapAndFulfillOrder(params: {
        order: OrderDataWithId;
        taker: Address;
        swapResult: SwapConnectorResult;
        loggerInstance?: Logger;
    }, payload: {
        takerWallet?: Address;
        unlockAuthority?: Address;
        computeUnitsLimit?: number;
    }): Promise<NonCompiledTransaction>;
    /**
     * @internal
     */
    preswapAndCreateOrder(params: {
        order: OrderWithoutNonce | OrderData;
        referralCode?: number;
        affiliateFee?: AbsoluteAffiliateFee;
        swapResult: SwapConnectorResult;
        metadata?: Buffer;
    }, payload: {
        makerWallet?: Address;
        computeUnitsLimit?: number;
    }): Promise<NonCompiledTransaction>;
    /**
     *
     * @param params
     * @param payload chain-specific payload
     * @param payload.taker address of fulfiller
     * @param payload.unlockAuthority optional address of allowed unlock authority
     * @returns
     */
    fulfillOrder(params: {
        order: OrderDataWithId;
    }, payload: {
        taker: Address;
        takerWallet?: Address;
        unlockAuthority?: Address;
    }): Promise<NonCompiledTransaction>;
    sendCancelOrder(params: {
        order: OrderDataWithId;
        executionFee: bigint;
        cancelBeneficiary: Uint8Array;
    }, payload: {
        canceler: Address;
        cancelerWallet?: Address;
    }): Promise<NonCompiledTransaction>;
    sendUnlockOrder(params: {
        order: OrderDataWithId;
        beneficiary: Uint8Array;
        executionFee: bigint;
    }, payload: {
        unlocker: Address;
        unlockerWallet?: Address;
    }): Promise<NonCompiledTransaction>;
    sendBatchUnlock(params: {
        orders: OrderDataWithId[];
        beneficiary: Uint8Array;
        executionFee: bigint;
    }, payload: {
        unlocker: Address;
        unlockerWallet?: Address;
    }): Promise<NonCompiledTransaction>;
    getOrderFromTransaction(params: {
        giveChain: ChainId;
        txHash: string;
    }, payload: object): Promise<(OrderDataWithId & OrderMeta & {
        affiliateInfo: AbsoluteAffiliateFee | undefined;
    }) | null>;
    getCreateCost(params: {
        inToken: Address;
        outToken: Address;
        giveChain: ChainId;
    }, payload: {
        maker: Address;
        priorityFee?: bigint;
    }): Promise<TransactionCostInNative>;
    private getATARent;
    private prepareCreatePreswapALT;
    /**
     * @internal
     */
    initForCreatePreswap(owner: PublicKey, supportedChains?: ChainId[]): Promise<Transaction[] | void>;
    /**
     * @internal
     */
    initForTaker(payer: PublicKey, taker: PublicKey, supportedChains: ChainId[], ALT?: PublicKey): Promise<Transaction[] | void>;
    getDecimals(chain: ChainId, tokenAddress: Address): Promise<number>;
    getTokenInfo(chain: ChainId, tokenAddress: Address): Promise<TokenMetadata>;
    /**
     * @internal
     */
    findALT(expectedAccounts: PublicKey[]): Promise<PublicKey | null>;
    /**
     * @internal
     */
    createCorrectALT(payerAndOwner: PublicKey, expectedAccounts: PublicKey[]): Promise<[PublicKey, Transaction[]]>;
    confirmationsToCommitment(confirmations: number): Commitment;
}
export { Executor } from "./executor";
export { solanaOrderToOrderData } from "./utils";
//# sourceMappingURL=index.d.ts.map
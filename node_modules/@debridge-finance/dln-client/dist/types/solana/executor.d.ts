/// <reference types="node" />
/// <reference types="bn.js" />
import { Program, BN } from "@coral-xyz/anchor";
import { Connection, PublicKey, TransactionInstruction } from "@solana/web3.js";
import { Address } from "../common.types";
import { ExtcallProgram } from "./idl/executor";
import { NonCompiledTransaction } from ".";
export declare const findExtcallStateAddress: (extcallProgram: PublicKey) => PublicKey;
export declare const findExtcallMetaAddress: (extcallProgram: PublicKey, id: Uint8Array) => PublicKey;
export declare const findExtcallStorageAddress: (extcallProgram: PublicKey, id: Uint8Array, owner: PublicKey) => PublicKey;
export declare const findExtcallAuthAddress: (extcallProgram: PublicKey, id: Uint8Array) => PublicKey;
export declare const findExtcallWalletAddress: (extcallProgram: PublicKey, id: Uint8Array, isNative: boolean) => PublicKey;
export declare enum ExecutionState {
    Executed = "Executed",
    Execution = "Execution",
    Failed = "Failed",
    Fallbacked = "Fallbacked",
    Initializing = "Initializing"
}
export type ExternalCallMeta = {
    amount: bigint;
    authority: PublicKey;
    flow: "spl" | "native";
} & ExtCallStateWithContext;
type ExtCallStateWithContext = {
    state: ExecutionState.Initializing;
} | {
    state: ExecutionState.Fallbacked;
} | {
    state: ExecutionState.Executed;
    buffer: PublicKey;
} | {
    state: ExecutionState.Execution;
    executedInstructionsCount: number;
    offset: number;
} | {
    state: ExecutionState.Failed;
    buffer: PublicKey;
};
/**
 * Substitutes amount at offset with `walletBalance(accounts[account_index]) - subtraction`
 */
type AmountSubstitution = {
    /**
     * big or little endian
     */
    is_big_endian: boolean;
    /**
     * At what offset substitution should be done
     */
    offset: number;
    /**
     * index of account in TransactionInstruction.keys to get balance for
     */
    account_index: number;
    /**
     * Amount to deduct from wallet balance
     */
    subtraction: number;
};
/**
 * Since we don't know submissionAuth at the moment of calldata preparation we can prepare substitution to replace
 * account at `index` with actual ATA(submissionAuth, tokenMint) during execution
 */
type WalletSubstitution = {
    /**
     * Token mint to calculate ATA for
     */
    token_mint: string;
    /**
     * Account at this index will be replaced with ATA(submissionAuth, tokenMint) during execution
     */
    index: number;
};
export declare class Executor {
    program: Program<ExtcallProgram>;
    static nativeAddress: string;
    constructor(programId: PublicKey, connection: Connection);
    /**
     * @deprecated use `extCallDataToInstructions` from solana-contracts-client
     * @param calldata
     * @param offset
     * @returns
     */
    static deserializeCalldata(calldata: Buffer | Uint8Array, offset?: number): import("@debridge-finance/solana-contracts-client/dist/types/interfaces").CastedFromWasmInstruction[];
    private isNative;
    /**
     *
     * @param takeTokenAddress
     * @param solPrice in usd
     * @param takeTokenPrice in usd
     * @param takeTokenDecimals
     * @param calldata
     * @param profitabilityMultiplier value in range 0..1, rewards will be equal (multiplier+1)*expensesInTakeToken
     * @returns
     */
    static setExecutionFeeRewards(takeTokenAddress: Address, solPrice: number, takeTokenPrice: number, takeTokenDecimals: number, calldata: Uint8Array, profitabilityMultiplier?: number): Uint8Array;
    getStorageData(orderId: Uint8Array, executor: PublicKey): Promise<Buffer | null>;
    initExtCallStorage(extcallId: Uint8Array, calldata: Uint8Array, owner: PublicKey, chunkSize?: number): Promise<NonCompiledTransaction[]>;
    /**
     * Transforms solana's TransactionInstruction into serialized format executable by debridge calldata executor
     * @param instruction
     * @param substitutions object that allows to substitute amount at offset/wallet at index
     * @param expense cost of ix execution, before execution this amount (of native SOL) will be transferred to submissionAuthority wallet and will be used to pay for actions in solana (usually rent)
     * @param reward this amount will be deducted from balance of submissionWallet, meant to cover expense
     * @param isInMandatoryBlock is this instruction should be executed in the same transaction as other sequental instructions with this flag?
     * @returns serialized calldata
     */
    static serializeExternalInstruction(instruction: TransactionInstruction, substitutions?: {
        amountSubstitutions?: AmountSubstitution[];
        walletSubstitutions?: WalletSubstitution[];
    }, expense?: bigint, reward?: bigint, zeroRentAlreadyIncluded?: boolean, isInMandatoryBlock?: boolean): Uint8Array;
    private convertExtcallState;
    normalizeExtcallMeta(data: Awaited<ReturnType<typeof this.program.account.extcallMeta.fetch>>): ExternalCallMeta;
    buildFallbackIx(extcallId: Uint8Array, fallbackAuthority: PublicKey, tokenMint: PublicKey): Promise<NonCompiledTransaction>;
    private buildExecuteExternalCallIx;
    getExternalCallMeta(extcallId: Uint8Array): Promise<{
        extcallId: number[];
        state: ({
            execution?: undefined;
            executed?: undefined;
            failed?: undefined;
            fallbacked?: undefined;
        } & {
            initializing: Record<string, never>;
        }) | ({
            initializing?: undefined;
            executed?: undefined;
            failed?: undefined;
            fallbacked?: undefined;
        } & {
            execution: {
                offset: BN;
                buffer: PublicKey;
                executedInstructionsCount: BN;
            };
        }) | ({
            initializing?: undefined;
            execution?: undefined;
            failed?: undefined;
            fallbacked?: undefined;
        } & {
            executed: {
                buffer: PublicKey;
            };
        }) | ({
            initializing?: undefined;
            execution?: undefined;
            executed?: undefined;
            fallbacked?: undefined;
        } & {
            failed: {
                buffer: PublicKey;
            };
        }) | ({
            initializing?: undefined;
            execution?: undefined;
            executed?: undefined;
            failed?: undefined;
        } & {
            fallbacked: Record<string, never>;
        });
        hash: number[];
        providedAmount: BN;
        providedToken: ({
            splToken?: undefined;
        } & {
            nativeSol: Record<string, never>;
        }) | ({
            nativeSol?: undefined;
        } & {
            splToken: Record<string, never>;
        });
        providedAuthority: PublicKey;
        bump: number;
        executeWalletBump: number;
        executeAuthBump: number;
    } | null>;
    buildOptimalExecuteExternalCallTransaction(extcallId: Uint8Array, executor: PublicKey, tokenMint: PublicKey): Promise<[NonCompiledTransaction, number]>;
}
export {};
//# sourceMappingURL=executor.d.ts.map
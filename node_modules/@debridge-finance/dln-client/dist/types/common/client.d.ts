/// <reference types="node" />
import { Address, AbsoluteAffiliateFee, ChainEngine, ChainId, EvmChains, GiveOrderStatus, TakeOrderStatus, TransactionCostInNative, ExecutionFeeInfo, DebridgeTransactionCost, TokenMetadata, OrderMeta, DiscountPercents } from "../common.types";
import { OrderData, OrderDataWithId, OrderWithoutNonce } from "../order";
import { SwapConnectorResult } from "../swapConnector";
import { Logger } from "./logger";
type FeeInfo = {
    fixFee: bigint;
    transferFee: bigint;
    transferFeeBps: number;
};
type OrderWithMetaAndAffiliateInfo = OrderDataWithId & OrderMeta & {
    affiliateInfo: AbsoluteAffiliateFee | undefined;
};
export interface ClientImplementation<Engine extends ChainEngine = ChainEngine> {
    getEngine(): Engine;
    getConnection(chain: ChainId): unknown;
    setConnection(chain: ChainId, connection: unknown): void;
    /**
     * Build transaction for order creation in `order.give.chainId` chain
     * @param params arguments shared between all clients
     * @param params.order order data without nonce
     * @param params.referralCode ref code
     * @param params.affiliateFee affiliate fee
     * @param payload chain-specific payload
     */
    createOrder(params: {
        order: OrderWithoutNonce | OrderData;
        referralCode: number;
        affiliateFee?: AbsoluteAffiliateFee;
        loggerInstance?: Logger;
        metadata?: Buffer;
    }, payload: object): Promise<unknown>;
    /**
     * Build transaction for order fulfillment
     * @param params arguments shared between all clients
     * @param params.order order to fulfill
     * @param payload chain-specific payload
     */
    fulfillOrder(params: {
        order: OrderDataWithId;
        loggerInstance?: Logger;
    }, payload: object): Promise<unknown>;
    /**
     * Build sendCancel transaction to send cancel message for single order via deBridge protocol
     * @param params arguments shared between all clients
     * @param params.order order to cancel
     * @param params.executionFee execution fee amount in take chain native token
     * @param params.cancelBeneficiary beneficiary of cancel in give chain
     * @param payload chain-specific payload
     */
    sendCancelOrder(params: {
        order: OrderDataWithId;
        executionFee: bigint;
        cancelBeneficiary: Address;
        loggerInstance?: Logger;
    }, payload: object): Promise<unknown>;
    /**
     * Build sendUnlock transaction to send unlock message for single order via deBridge protocol
     * @param params arguments shared between all clients
     * @param params.order order to unlock
     * @param params.beneficiary receiver of give part in give chain
     * @param params.executionFee execution fee amount in take chain native token
     * @param payload chain-specific payload
     */
    sendUnlockOrder(params: {
        order: OrderDataWithId;
        beneficiary: Address;
        executionFee: bigint;
        loggerInstance?: Logger;
    }, payload: object): Promise<unknown>;
    /**
     * Build sendBatchUnlock transaction to send unlock message for multiple orders via deBridge protocol
     * @param params arguments shared between all clients
     * @param params.orders list of orders to batch unlock. Give & take chains must be equal
     * @param params.beneficiary receiver of give part in give chain
     * @param params.executionFee execution fee amount in take chain native token
     * @param payload chain-specific payload
     */
    sendBatchUnlock(params: {
        orders: OrderDataWithId[];
        beneficiary: Address;
        executionFee: bigint;
        loggerInstance?: Logger;
    }, payload: object): Promise<unknown>;
    /**
     * @internal
     * Build atomic transaction to perform swap using SwapResult and create order
     * @param params arguments shared between all clients
     * @param params.order order to create. Order give offer should be in swap result tokenOut token
     * @param params.affiliateFee affiliate fee to take after swap/before order creation from swapped amount
     * @param params.swapResult information about swap: token in/out with amount, routes, chain-specific swap info
     * @param payload chain-specific payload
     */
    preswapAndCreateOrder(params: {
        order: OrderWithoutNonce | OrderData;
        referralCode?: number;
        affiliateFee?: AbsoluteAffiliateFee;
        swapResult: SwapConnectorResult;
        loggerInstance?: Logger;
        metadata?: Buffer;
    }, payload: object): Promise<unknown>;
    /**
     * @internal
     * Build atomic transaction to perform swap using swapResult and fulfill order
     * @param params arguments shared between all clients
     * @param params.order order to fulfill
     * @param params.taker fulfiller/taker address
     * @param params.swapResult information about swap: token in/out with amount, routes, chain-specific swap info
     * @param payload chain-specific payload
     */
    preswapAndFulfillOrder(params: {
        order: OrderDataWithId;
        taker: Address;
        swapResult: SwapConnectorResult;
        loggerInstance?: Logger;
    }, payload: object): Promise<unknown>;
    /**
     * @internal
     */
    getForwarderAddress?(chain: ChainId): Address;
    /**
     * Get wallet balance
     * @param chain
     * @param tokenAddress
     * @param wallet
     */
    getBalance(chain: ChainId, tokenAddress: Address, wallet: Address): Promise<bigint>;
    /**
     * Get DLN fees from chain
     * @param chain chain to get DLN fees for
     * @param amount amount to calculate transfer fee amount
     */
    getFees(chain: ChainId, amount?: bigint): Promise<FeeInfo>;
    /**
     * Get execution fee info for requested action
     * @param params arguments shared between all clients
     * @param params.action action to estimate
     * @param params.takeNativePrice price of take native token in intermediary token
     * @param params.giveNativePrice price of give native token in intermediary token
     * @param params.takeDecimals decimals of native take token
     * @param params.takeToken token that will be used to send deBridge message. At the moment - wrapped native take token
     * @param params.batchSize count of orders in batch. Will fail if action is "ClaimBatchUnlock" and batchSize is undefined
     * @param payload chain-specific payload
     */
    getClaimExecutionFee(params: {
        giveChain: ChainId;
        takeChain: ChainId;
        giveNativePrice: number;
        takeToken: Address;
        takeNativePrice: number;
        takeDecimals: number;
        batchSize?: number;
        action: "ClaimUnlock" | "ClaimCancel" | "ClaimBatchUnlock";
        loggerInstance?: Logger;
    }, payload: object): Promise<ExecutionFeeInfo>;
    /**
     * Calculates a cost of claim_unlock for a single order in a shared batch in the native currency of the take chain
     * Use params.batchUnlockCoverage to specify the share of batch to be covered by this particular order, e.g.:
     *  - batchUnlockCoverage=0.1 indicates that an order's operating expenses must cover 10% of sendBatchUnlock+claimBatchUnlock
     *  - batchUnlockCoverage=1 indicates that an order's operating expenses must cover 100% of sendBatchUnlock+claimBatchUnlock
     *    (i.e., unlock of a single order must be profitable)
     * Attention: for exact executionFee for claim_unlock use getClaimExecutionFee()
     */
    getClaimBatchUnlockCostForSingleOrder(params: {
        giveChain: ChainId;
        takeChain: ChainId;
        giveNativePrice: number;
        takeToken: Address;
        takeNativePrice: number;
        takeDecimals: number;
        batchUnlockCoverage: number;
        loggerInstance?: Logger;
    }, payload: object): Promise<bigint>;
    /**
     * Get cost of createOrder action in give chain
     * @param params arguments shared between all clients
     * @param payload chain-specific payload
     */
    getCreateCost(params: {
        giveChain: ChainId;
        inToken: Address;
        outToken: Address;
        loggerInstance?: Logger;
    }, payload: object): Promise<TransactionCostInNative>;
    /**
     * Get cost of fulfill action in take chain
     * @param params arguments shared between all clients
     * @param payload chain-specific payload
     */
    getFulfillCost(params: {
        takeChain: ChainId;
        equivalentToken: Address;
        orderTakeToken?: Address;
        loggerInstance?: Logger;
    }, payload: object): Promise<TransactionCostInNative>;
    /**
     * Get cost of send[batch]Unlock action in take chain (including execution fee)
     * @param params arguments shared between all clients
     * @param params.batchSize count of orders in batch. If batchSize == 1 estimate sendUnlock cost else estimate sendBatchUnlock
     * @param params.executionFee execution fee amount in take chain native token
     * @param payload chain-specific payload
     */
    getSendUnlockCost(params: {
        giveChain: ChainId;
        takeChain: ChainId;
        executionFee: bigint;
        batchSize: number;
        loggerInstance?: Logger;
    }, payload: object): Promise<DebridgeTransactionCost>;
    /**
     * Calculates a cost of send_unlock for a single order in a shared batch in the native currency of the take chain
     * Use params.batchUnlockCoverage to specify the share of batch to be covered by this particular order, e.g.:
     *  - batchUnlockCoverage=0.1 indicates that an order's operating expenses must cover 10% of sendBatchUnlock+claimBatchUnlock
     *  - batchUnlockCoverage=1 indicates that an order's operating expenses must cover 100% of sendBatchUnlock+claimBatchUnlock
     *    (i.e., unlock of a single order must be profitable)
     * Attention: to get the total cost of send_unlock operation with entire batch, use getSendUnlockCost()
     * Attention-2: use getClaimBatchUnlockCostForSingleOrder() for params.executionFeeForSingleOrder
     */
    getSendUnlockCostForSingleOrder(params: {
        giveChain: ChainId;
        takeChain: ChainId;
        executionFeeForSingleOrder: bigint;
        batchUnlockCoverage: number;
        discountPercents: DiscountPercents;
        loggerInstance?: Logger;
    }, payload: object): Promise<bigint>;
    getSendCancelCost(params: {
        giveChain: ChainId;
        takeChain: ChainId;
        executionFee: bigint;
        loggerInstance?: Logger;
    }, payload: object): Promise<DebridgeTransactionCost>;
    /**
     * Get final order.give amount including give patches
     * @param params arguments shared between all clients
     * @param params.order order to retrieve final give amount for
     * @param payload chain-specific payload
     */
    getFinalGiveAmount(params: {
        order: OrderDataWithId;
        loggerInstance?: Logger;
    }, payload: object): Promise<bigint>;
    /**
     * Get final order.take amount including take patches
     * @param params arguments shared between all clients
     * @param params.order order to retrieve final take amount for
     * @param payload chain-specific payload
     */
    getFinalTakeAmount(params: {
        order: OrderDataWithId;
        loggerInstance?: Logger;
    }, payload: object): Promise<bigint>;
    /**
     * Build transaction to increase order give amount in give chain
     * @param params arguments shared between all clients
     * @param params.order order to patch
     * @param params.amountToAdd amount to increase give offer by
     * @param payload chain-specific payload
     */
    patchOrderGive(params: {
        order: OrderDataWithId;
        amountToAdd: bigint;
        loggerInstance?: Logger;
    }, payload: object): Promise<unknown>;
    /**
     * Build transaction to decrease order take amount in take chain
     * @param params arguments shared between all clients
     * @param params.order order to patch
     * @param params.amountToSub amount to decrease take offer by
     * @param payload chain-specific payload
     */
    patchOrderTake(params: {
        order: OrderDataWithId;
        amountToSub: bigint;
        loggerInstance?: Logger;
    }, payload: object): Promise<unknown>;
    /**
     * Extract order from create order transaction in give chain
     * @param params arguments shared between all clients
     * @param params.giveChain order creation chain
     * @param params.txHash order creation transaction
     * @param payload chain-specific payload
     */
    getOrderFromTransaction(params: {
        giveChain: ChainId;
        txHash: string;
        loggerInstance?: Logger;
    }, payload: object): Promise<OrderWithMetaAndAffiliateInfo | null>;
    /**
     * Get on-chain order status in give chain
     * @param params arguments shared between all clients
     * @param payload chain-specific payload
     */
    getGiveOrderState(params: {
        orderId: Uint8Array | string;
        giveChain: ChainId;
        loggerInstance?: Logger;
    }, payload: object): Promise<GiveOrderStatus | null>;
    /**
     * Get on-chain order status in take chain
     * @param params arguments shared between all clients
     * @param payload chain-specific payload
     */
    getTakeOrderState(params: {
        orderId: Uint8Array | string;
        takeChain: ChainId;
        loggerInstance?: Logger;
    }, payload: object): Promise<TakeOrderStatus | null>;
    fromAddress(address: Address): unknown;
    toAddress(nativeAddress: unknown): Address;
    parseAddress(address: string): Address;
    getDecimals(chain: ChainId, address: Address): Promise<number>;
    getTokenInfo(chain: ChainId, address: Address): Promise<TokenMetadata>;
    readonly nativeCurrencyDecimals: number;
    readonly addressLength: number;
    readonly nativeAddress: Address;
    readonly defaultLogger: Logger;
    /**
     * Get wrapped native token address, e.g. weth for eth and wsol for solana
     * @param chain chain to get wrapped token address
     */
    getWrappedNativeTokenAddress(chain: ChainId): Promise<Address>;
}
type Fn = (...args: any) => any;
type ClassMethods<C> = {
    [Key in keyof C as C[Key] extends Fn ? Key : never]: C[Key];
};
type ChainIdMap = {
    [Chain in ChainId]: Chain extends ChainId.Solana ? ChainEngine.Solana : Chain extends EvmChains ? ChainEngine.EVM : never;
};
type EngineFromClient<Client> = Client extends ClientImplementation<infer ChainEngine> ? ChainEngine : never;
type ClientsPayloads<Clients extends ClientImplementation, FnName extends keyof ClassMethods<ClientImplementation>, Engines extends ChainEngine = ChainEngine> = {
    [Client in Clients as EngineFromClient<Client> extends Engines ? EngineFromClient<Client> : never]: Parameters<Client[FnName]>[1];
};
type Intersect<T> = (T extends unknown ? (x: T) => 0 : never) extends (x: infer R) => 0 ? R : never;
type Wrap<T> = {
    [K in keyof T]: {
        __wrapper__: T[K];
    };
};
type Values<T> = T[keyof T];
type Unwrap<T> = T extends {
    __wrapper__: any;
} ? T["__wrapper__"] : never;
type UnionToIntersection<T> = Unwrap<Intersect<Values<Wrap<T>>>>;
type ClientsResults<Clients extends ClientImplementation, FnName extends keyof ClassMethods<ClientImplementation>> = {
    [Client in Clients as EngineFromClient<Client>]: ReturnType<Client[FnName]>;
};
type ChainSpecific<Data, Chain extends ChainId, ChainMap extends Record<ChainId, ChainEngine> = ChainIdMap, Engine extends ChainEngine = ChainMap[Chain]> = EngineSpecific<Data, Engine>;
type EngineSpecific<Data, Engine extends ChainEngine> = Engine extends keyof Data ? Data[Engine] : never;
type ExcludedMethods = "getEngine" | "fromAddress" | "toAddress" | "parseAddress" | "getDecimals" | "getAddressLength" | "getWrappedNativeTokenAddress" | "getFees" | "getFulfillCost" | "getCreateCost" | "getSendUnlockCost" | "getSendUnlockCostForSingleOrder" | "getClaimExecutionFee" | "getClaimBatchUnlockCostForSingleOrder" | "getConnection" | "setConnection" | "getFinalGiveAmount" | "getBalance" | "getTokenInfo" | "getOrderFromTransaction" | "getSendCancelCost" | "getFinalTakeAmount";
/**
 * @internal
 */
type ICommonDlnClient<Impls extends ClientImplementation = ClientImplementation> = {
    [MethodName in keyof Omit<ClassMethods<ClientImplementation>, ExcludedMethods>]: <ActionEngine extends ChainEngine>(params: Parameters<ClassMethods<ClientImplementation>[MethodName]>[0], payload: UnionToIntersection<ClientsPayloads<Impls, MethodName, ActionEngine>>) => EngineSpecific<ClientsResults<Impls, MethodName>, ActionEngine>;
} & {
    getClient(chain: ChainId): ClientImplementation;
    getDecimals(chain: ChainId, tokenAddress: Address): Promise<number>;
    getNativeCurrencyDecimals(chain: ChainId): number;
    getConnection<ActionChain extends ChainId>(chain: ChainId): ChainSpecific<ClientsResults<Impls, "getConnection">, ActionChain>;
    getAddressLength(chain: ChainId): number;
    getFees(chain: ChainId, amount?: bigint): Promise<FeeInfo>;
    getClaimExecutionFee<ActionEngine extends ChainEngine>(params: Parameters<ClientImplementation["getClaimExecutionFee"]>[0], payload: UnionToIntersection<ClientsPayloads<Impls, "getClaimExecutionFee", ActionEngine>>): Promise<ExecutionFeeInfo>;
    getFinalGiveAmount<GiveEngine extends ChainEngine>(params: Parameters<ClientImplementation["getFinalGiveAmount"]>[0], payload: UnionToIntersection<ClientsPayloads<Impls, "getFinalGiveAmount", GiveEngine>>): Promise<bigint>;
    getFinalTakeAmount<TakeEngine extends ChainEngine>(params: Parameters<ClientImplementation["getFinalTakeAmount"]>[0], payload: UnionToIntersection<ClientsPayloads<Impls, "getFinalTakeAmount", TakeEngine>>): Promise<bigint>;
    parseAddress(chain: ChainId, address: string): Address;
    getForwarderAddress(chain: ChainId): Address | undefined;
    getTokenInfo(chain: ChainId, address: Address): Promise<TokenMetadata>;
    getOrderFromTransaction<GiveEngine extends ChainEngine>(params: {
        giveChain: ChainId;
        txHash: string;
        loggerInstance?: Logger;
    }, payload: UnionToIntersection<ClientsPayloads<Impls, "getOrderFromTransaction", GiveEngine>>): Promise<(OrderDataWithId & OrderMeta) | null>;
};
export declare class CommonDlnClient<T extends ClientImplementation> implements ICommonDlnClient<T> {
    private clients;
    constructor(...clients: T[]);
    getClient(chain: ChainId): ClientImplementation;
    setClient(client: ClientImplementation): void;
    getConnection<ActionChain extends ChainId>(chain: ChainId): EngineSpecific<ClientsResults<T, "getConnection">, ChainIdMap[ActionChain]>;
    getDecimals(chain: ChainId, tokenAddress: Address): Promise<number>;
    getTokenInfo(chain: ChainId, tokenAddress: Address): Promise<TokenMetadata>;
    /**
     * Get decimals of native token for requested chain
     * @param chain
     * @returns
     */
    getNativeCurrencyDecimals(chain: ChainId): number;
    /**
     * Get length of address for requested chain (addr len are same across engine)
     * @param chain
     * @returns
     */
    getAddressLength(chain: ChainId): number;
    /**
     * Parse address string (hex for evm, base58 for solana) into Address
     * @param chain
     * @param address string to parse
     * @returns
     */
    parseAddress(chain: ChainId, address: string): Address;
    /**
     * Build transaction to increase order give amount in give chain
     * @param params.order order to patch
     * @param params.amountToAdd amount to increase give offer by
     * @param payload chain-specific payload
     */
    patchOrderGive<GiveEngine extends ChainEngine>(params: {
        order: OrderDataWithId;
        amountToAdd: bigint;
        loggerInstance?: Logger;
    }, payload: UnionToIntersection<ClientsPayloads<T, "patchOrderGive", GiveEngine>>): EngineSpecific<ClientsResults<T, "patchOrderGive">, GiveEngine>;
    /**
     * Build transaction to decrease order take amount in take chain
     * @param params.order order to patch
     * @param params.amountToSub amount to decrease take offer by
     * @param payload chain-specific payload
     */
    patchOrderTake<TakeEngine extends ChainEngine>(params: {
        order: OrderDataWithId;
        amountToSub: bigint;
        loggerInstance?: Logger;
    }, payload: UnionToIntersection<ClientsPayloads<T, "patchOrderTake", TakeEngine>>): EngineSpecific<ClientsResults<T, "patchOrderTake">, TakeEngine>;
    /**
     * Get final order.give amount including give patches
     * @param params arguments shared between all clients
     * @param params.order order to retrieve final give amount for
     * @param payload chain-specific payload
     */
    getFinalGiveAmount<GiveEngine extends ChainEngine>(params: {
        order: OrderDataWithId;
        loggerInstance?: Logger;
    }, payload: UnionToIntersection<ClientsPayloads<T, "getFinalGiveAmount", GiveEngine>>): Promise<bigint>;
    /**
     * Get final order.take amount including take patches
     * @param params.order order to retrieve final take amount for
     * @param payload chain-specific payload
     */
    getFinalTakeAmount<TakeEngine extends ChainEngine>(params: {
        order: OrderDataWithId;
        loggerInstance?: Logger;
    }, payload: UnionToIntersection<ClientsPayloads<T, "getFinalTakeAmount", TakeEngine>>): Promise<bigint>;
    /**
     * Get DLN fees from chain
     * @param chain chain to get DLN fees for
     * @param amount amount to calculate transfer fee amount
     */
    getFees(chain: ChainId, amount?: bigint): Promise<FeeInfo>;
    /**
     * Get execution fee info for requested action
     * @param params.action action to estimate
     * @param params.takeNativePrice price of take native token in intermediary token
     * @param params.giveNativePrice price of give native token in intermediary token
     * @param params.batchSize count of orders in batch. Will fail if action is "ClaimBatchUnlock" and batchSize is undefined
     * @param payload chain-specific payload
     */
    getClaimExecutionFee<GiveEngine extends ChainEngine>(params: {
        giveChain: ChainId;
        takeChain: ChainId;
        takeNativePrice: number;
        giveNativePrice: number;
        batchSize?: number;
        action: "ClaimUnlock" | "ClaimCancel" | "ClaimBatchUnlock";
        loggerInstance?: Logger;
    }, payload: UnionToIntersection<ClientsPayloads<T, "getClaimExecutionFee", GiveEngine>>): Promise<ExecutionFeeInfo>;
    getClaimBatchUnlockCostForSingleOrder<GiveEngine extends ChainEngine>(params: {
        giveChain: ChainId;
        takeChain: ChainId;
        giveNativePrice: number;
        takeNativePrice: number;
        batchUnlockCoverage: number;
        loggerInstance?: Logger;
    }, payload: UnionToIntersection<ClientsPayloads<T, "getClaimBatchUnlockCostForSingleOrder", GiveEngine>>): Promise<bigint>;
    /**
     * Get cost of createOrder action in give chain
     * @param params arguments shared between all clients
     * @param payload chain-specific payload
     */
    getCreateCost<GiveEngine extends ChainEngine>(params: {
        giveChain: ChainId;
        inToken: Address;
        outToken: Address;
        loggerInstance?: Logger;
    }, payload: UnionToIntersection<ClientsPayloads<T, "getCreateCost", GiveEngine>>): Promise<TransactionCostInNative>;
    /**
     * Get cost of fulfill action in take chain
     * @param params arguments shared between all clients
     * @param payload chain-specific payload
     */
    getFulfillCost<GiveEngine extends ChainEngine>(params: {
        takeChain: ChainId;
        equivalentToken: Address;
        orderTakeToken?: Address;
        loggerInstance?: Logger;
    }, payload: UnionToIntersection<ClientsPayloads<T, "getFulfillCost", GiveEngine>>): Promise<TransactionCostInNative>;
    /**
     * get an estimated cost of fulfill + send_unlock + claim_unlock for a single order in the native
     * currency of the take chain. This method takes shared unlock batches into consideration, so order's cost would be ≈Nth
     * of {send,claim}UnlockCost (where N is the size of the batch).
     */
    getTakerFlowCostForSingleOrder<GiveEngine extends ChainEngine, TakeEngine extends ChainEngine>(params: {
        giveChain: ChainId;
        takeChain: ChainId;
        giveNativePrice: number;
        takeNativePrice: number;
        equivalentToken: Address;
        orderTakeToken?: Address;
        batchUnlockCoverage: number;
        discountPercents: DiscountPercents;
        loggerInstance?: Logger;
    }, payload: UnionToIntersection<ClientsPayloads<T, "getSendUnlockCost", TakeEngine>> & UnionToIntersection<ClientsPayloads<T, "getFulfillCost", TakeEngine>> & UnionToIntersection<ClientsPayloads<T, "getClaimExecutionFee", GiveEngine>>): Promise<bigint>;
    /**
     * Get on-chain order status in give chain
     * @param params arguments shared between all clients
     * @param payload chain-specific payload
     */
    getGiveOrderState<GiveEngine extends ChainEngine>(params: {
        orderId: string | Uint8Array;
        giveChain: ChainId;
        loggerInstance?: Logger;
    }, payload: UnionToIntersection<ClientsPayloads<T, "getGiveOrderState", GiveEngine>>): EngineSpecific<ClientsResults<T, "getGiveOrderState">, GiveEngine>;
    /**
     * Get on-chain order status in take chain
     * @param params arguments shared between all clients
     * @param payload chain-specific payload
     */
    getTakeOrderState<TakeEngine extends ChainEngine>(params: {
        orderId: string | Uint8Array;
        takeChain: ChainId;
        loggerInstance?: Logger;
    }, payload: UnionToIntersection<ClientsPayloads<T, "getTakeOrderState", TakeEngine>>): EngineSpecific<ClientsResults<T, "getTakeOrderState">, TakeEngine>;
    /**
     * Build transaction for order creation in `order.give.chainId` chain
     * @param params arguments shared between all clients
     * @param params.order order data without nonce
     * @param params.referralCode ref code
     * @param params.affiliateFee affiliate fee
     * @param payload chain-specific payload
     */
    createOrder<GiveEngine extends ChainEngine>(params: {
        order: OrderWithoutNonce | OrderData;
        referralCode: number;
        affiliateFee?: AbsoluteAffiliateFee;
        loggerInstance?: Logger;
        metadata?: Buffer;
    }, payload: UnionToIntersection<ClientsPayloads<T, "createOrder", GiveEngine>>): EngineSpecific<ClientsResults<T, "createOrder">, GiveEngine>;
    /**
     * Build transaction for order fulfillment
     * @param params.order order to fulfill
     * @param payload chain-specific payload
     */
    fulfillOrder<TakeEngine extends ChainEngine>(params: {
        order: OrderDataWithId;
        loggerInstance?: Logger;
    }, payload: UnionToIntersection<ClientsPayloads<T, "fulfillOrder", TakeEngine>>): EngineSpecific<ClientsResults<T, "fulfillOrder">, TakeEngine>;
    /**
     * @internal
     * @param chain
     * @returns
     */
    getForwarderAddress(chain: ChainId): Address | undefined;
    /**
     * @internal
     * Build atomic transaction to perform swap using swapResult and fulfill order
     * @param params.order order to fulfill
     * @param params.taker fulfiller/taker address
     * @param params.swapResult information about swap: token in/out with amount, routes, chain-specific swap info
     * @param payload chain-specific payload
     */
    preswapAndFulfillOrder<TakeEngine extends ChainEngine>(params: {
        order: OrderDataWithId;
        taker: Address;
        swapResult: SwapConnectorResult;
        loggerInstance?: Logger;
    }, payload: UnionToIntersection<ClientsPayloads<T, "preswapAndFulfillOrder", TakeEngine>>): EngineSpecific<ClientsResults<T, "preswapAndFulfillOrder">, TakeEngine>;
    /**
     * @internal
     * Build atomic transaction to perform swap using SwapResult and create order
     * @param params.order order to create. Order give offer should be in swap result tokenOut token
     * @param params.affiliateFee affiliate fee to take after swap/before order creation from swapped amount
     * @param params.swapResult information about swap: token in/out with amount, routes, chain-specific swap info
     * @param payload chain-specific payload
     */
    preswapAndCreateOrder<GiveEngine extends ChainEngine>(params: {
        order: OrderWithoutNonce | OrderData;
        affiliateFee?: AbsoluteAffiliateFee;
        referralCode?: number;
        swapResult: SwapConnectorResult;
        loggerInstance?: Logger;
        metadata?: Buffer;
    }, payload: UnionToIntersection<ClientsPayloads<T, "preswapAndCreateOrder", GiveEngine>>): EngineSpecific<ClientsResults<T, "preswapAndCreateOrder">, GiveEngine>;
    /**
     * Build sendBatchUnlock transaction to send unlock message for multiple orders via deBridge protocol
     * @param params.orders list of orders to batch unlock. Give & take chains must be equal
     * @param params.beneficiary receiver of give part in give chain
     * @param params.executionFee execution fee amount in take chain native token
     * @param payload chain-specific payload
     */
    sendBatchUnlock<TakeEngine extends ChainEngine>(params: {
        orders: OrderDataWithId[];
        beneficiary: Address;
        executionFee: bigint;
        loggerInstance?: Logger;
    }, payload: UnionToIntersection<ClientsPayloads<T, "sendBatchUnlock", TakeEngine>>): EngineSpecific<ClientsResults<T, "sendBatchUnlock">, TakeEngine>;
    /**
     * Build sendCancel transaction to send cancel message for single order via deBridge protocol
     * @param params.order order to cancel
     * @param params.executionFee execution fee amount in take chain native token
     * @param params.cancelBeneficiary beneficiary of cancel in give chain
     * @param payload chain-specific payload
     */
    sendCancelOrder<TakeEngine extends ChainEngine>(params: {
        order: OrderDataWithId;
        executionFee: bigint;
        cancelBeneficiary: Address;
        loggerInstance?: Logger;
    }, payload: UnionToIntersection<ClientsPayloads<T, "sendCancelOrder", TakeEngine>>): EngineSpecific<ClientsResults<T, "sendCancelOrder">, TakeEngine>;
    /**
     * Build sendUnlock transaction to send unlock message for single order via deBridge protocol
     * @param params.order order to unlock
     * @param params.beneficiary receiver of give part in give chain
     * @param params.executionFee execution fee amount in take chain native token
     * @param payload chain-specific payload
     */
    sendUnlockOrder<TakeEngine extends ChainEngine>(params: {
        order: OrderDataWithId;
        beneficiary: Address;
        executionFee: bigint;
        loggerInstance?: Logger;
    }, payload: UnionToIntersection<ClientsPayloads<T, "sendUnlockOrder", TakeEngine>>): EngineSpecific<ClientsResults<T, "sendUnlockOrder">, TakeEngine>;
    /**
     * Extract order from create order transaction in give chain
     * @param params.giveChain order creation chain
     * @param params.txHash order creation transaction
     * @param payload chain-specific payload
     */
    getOrderFromTransaction<GiveEngine extends ChainEngine>(params: {
        giveChain: ChainId;
        txHash: string;
        loggerInstance?: Logger;
    }, payload: UnionToIntersection<ClientsPayloads<T, "getOrderFromTransaction", GiveEngine>>): Promise<(OrderDataWithId & OrderMeta & {
        affiliateInfo: AbsoluteAffiliateFee | undefined;
    }) | null>;
}
export {};
//# sourceMappingURL=client.d.ts.map
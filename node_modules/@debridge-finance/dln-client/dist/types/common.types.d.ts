import * as undici_types from "undici";
declare global {
    export const fetch: typeof undici_types.fetch, FormData: typeof undici_types.FormData, Headers: typeof undici_types.Headers, Request: typeof undici_types.Request, Response: typeof undici_types.Response;
    type FormData = undici_types.FormData;
    type Headers = undici_types.Headers;
    type HeadersInit = undici_types.HeadersInit;
    type BodyInit = undici_types.BodyInit;
    type Request = undici_types.Request;
    type RequestInit = undici_types.RequestInit;
    type RequestInfo = undici_types.RequestInfo;
    type RequestMode = undici_types.RequestMode;
    type RequestRedirect = undici_types.RequestRedirect;
    type RequestCredentials = undici_types.RequestCredentials;
    type RequestDestination = undici_types.RequestDestination;
    type ReferrerPolicy = undici_types.ReferrerPolicy;
    type Response = undici_types.Response;
    type ResponseInit = undici_types.ResponseInit;
    type ResponseType = undici_types.ResponseType;
}
/**
 * @internal
 */
export declare const ZERO_EVM_ADDRESS = "0x0000000000000000000000000000000000000000";
/**
 * @internal
 */
export declare const ZERO_SOLANA_ADDRESS = "0x0000000000000000000000000000000000000000000000000000000000000000";
/**
 * @internal
 */
export declare const BPS_DENOMINATOR: bigint;
/**
 * to prevent addresses formats zoo, all addresses passed to client should be of `Address` type
 */
export type Address = Uint8Array;
export type OrderMeta = {
    transferFee: bigint;
    fixFee: bigint;
    referralCode?: number;
    createTimestamp: number | undefined;
};
export interface TokenMetadata {
    chainId: ChainId;
    address: string;
    symbol: string;
    name: string;
    decimals: number;
}
export type TokenInfo = {
    tokenAddress: Address;
    decimals: number;
    chainId: ChainId;
};
export type TokenInfoWithAmount = TokenInfo & {
    amount: bigint;
};
/**
 * Indicates a stage of order estimation.
 * This is crucial for EVMs: during the order creation the gas price must be
 * set pessimistically (with large multiplier) while during the order fulfillment
 * we may pick the current gas price
 */
export declare enum OrderEstimationStage {
    OrderCreation = 0,
    OrderFulfillment = 1
}
export type TransactionCostInNative = {
    chainId: ChainId;
    /**
     * Price of gas in chainId
     */
    gasPrice: bigint;
    /**
     * Maximum amount of gas that can be consumed during tx execution
     */
    gasLimit: bigint;
    /**
     * gasPrice*gasLimit
     */
    totalCost: bigint;
};
export type ExecutionFeeInfo = {
    claimCost: bigint;
    rewards: bigint[];
    total: bigint;
};
export type DebridgeTransactionCost = {
    /**
     * Cost of debridge send tx
     */
    transactionCost: TransactionCostInNative;
    /**
     * Execution fee amount accounting deBridge transfer fee
     */
    accountedExecutionFee: bigint;
    /**
     * deBridge fix fee
     */
    fixFee: bigint;
    /**
     * Sum of accountedExecutionFee, fixFee, transactionCost.total
     */
    totalCost: bigint;
};
export interface AbsoluteAffiliateFee {
    beneficiary: Address;
    amount: bigint;
}
export interface RelativeAffiliateFee {
    beneficiary: Address;
    bps: number;
}
export declare enum ChainEngine {
    EVM = 0,
    Solana = 1
}
export declare enum ChainId {
    Ethereum = 1,
    BSC = 56,
    Heco = 128,
    Polygon = 137,
    Arbitrum = 42161,
    Avalanche = 43114,
    AvalancheTest = 43113,
    Kovan = 42,
    BSCTest = 97,
    HecoTest = 256,
    PolygonTest = 80001,
    ArbitrumTest = 421611,
    Solana = 7565164,
    Fantom = 250,
    Linea = 59144,
    Base = 8453,
    Optimism = 10,
    Neon = 100000001,
    Gnosis = 100000002,
    LightLink = 100000003,
    Metis = 100000004,
    Bitrock = 100000005
}
export declare enum IaaSChainId {
    Neon = 100000001,
    Gnosis = 100000002,
    LightLink = 100000003,
    Metis = 100000004,
    Bitrock = 100000005
}
export declare const IaaSOriginChainId: {
    [key in IaaSChainId]: number;
};
export declare function getEngineByChainId(chainId: ChainId): ChainEngine;
export type EvmChains = ChainId.Arbitrum | ChainId.Avalanche | ChainId.BSC | ChainId.Ethereum | ChainId.Fantom | ChainId.Heco | ChainId.Polygon | ChainId.Linea | ChainId.Optimism | ChainId.Base | ChainId.Neon | ChainId.Gnosis | ChainId.LightLink | ChainId.Metis | ChainId.Bitrock;
export type OpStackBasedEvmChains = ChainId.Base | ChainId.Optimism;
export declare const OpStackBasedEVMChains: Readonly<Array<OpStackBasedEvmChains>>;
export declare const enum OrderState {
    NotSet = 0,
    Created = 1,
    Fulfilled = 2,
    SentUnlock = 3,
    Canceled = 4,
    ClaimedUnlock = 6,
    SentCancel = 5,
    ClaimedCancel = 7
}
export type TakeOrderStatus = {
    status: OrderState;
    takerAddress: Address;
    giveChainId: ChainId;
    orderId?: Uint8Array;
};
export type GiveOrderStatus = {
    status: OrderState;
    takeChainId?: ChainId;
    giveAmount?: bigint;
};
export type GetTokenBalanceLambda = (chainId: ChainId, tokenAddress: Address | string, accountAddress: Address | string) => Promise<bigint>;
export type DiscountPercents = {
    batchUnlockFixFee: bigint;
};
export type FetchReqContext = {
    url: string;
    pathname: string;
    host: string;
    context?: string;
    request?: RequestInit;
    type: "external_request";
};
export type FetchResContext = FetchReqContext & {
    response: unknown;
    duration: number;
};
export type FetchErrorContext = FetchReqContext & {
    error: Error;
    duration: number;
};
export type GetDecimalsLambda = (chain: number, address: Address) => Promise<number>;
export type GetGasPriceLambda = (chain: number) => Promise<string>;
export type GetNativeLambda = (chain: number) => Address;
export { EvmInstruction } from "./evm/core/types/common.type";
//# sourceMappingURL=common.types.d.ts.map
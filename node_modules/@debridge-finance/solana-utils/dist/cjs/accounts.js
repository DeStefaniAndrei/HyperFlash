"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.dlnDstResolver = exports.dlnSrcResolver = exports.DeBridgeResolver = exports.WRAPPED_SOL_MINT = exports.ASSOCIATED_TOKEN_PROGRAM_ID = exports.TOKEN_PROGRAM_ID = exports.TOKEN_METADATA_PROGRAM_ID = exports.TOKEN_2022_PROGRAM_ID = void 0;
exports.findAssociatedTokenAddress = findAssociatedTokenAddress;
exports.findAssociatedTokenAddressSync = findAssociatedTokenAddressSync;
exports.getTokenMetadataAddress = getTokenMetadataAddress;
const tslib_1 = require("tslib");
const buffer_1 = require("buffer");
const web3_js_1 = require("@solana/web3.js");
const constants = tslib_1.__importStar(require("./constants"));
const crypto_1 = require("./crypto");
const interfaces_1 = require("./interfaces");
const micro_memoize_1 = tslib_1.__importDefault(require("micro-memoize"));
exports.TOKEN_2022_PROGRAM_ID = new web3_js_1.PublicKey("TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb");
exports.TOKEN_METADATA_PROGRAM_ID = new web3_js_1.PublicKey("metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s");
exports.TOKEN_PROGRAM_ID = new web3_js_1.PublicKey("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA");
exports.ASSOCIATED_TOKEN_PROGRAM_ID = new web3_js_1.PublicKey("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL");
exports.WRAPPED_SOL_MINT = new web3_js_1.PublicKey("So11111111111111111111111111111111111111112");
function findAssociatedTokenAddress(wallet, tokenMint, tokenProgramId = exports.TOKEN_PROGRAM_ID, associatedTokenProramId = exports.ASSOCIATED_TOKEN_PROGRAM_ID) {
    return web3_js_1.PublicKey.findProgramAddressSync([wallet.toBytes(), tokenProgramId.toBytes(), tokenMint.toBytes()], associatedTokenProramId);
}
/**
 * @deprecated same as findAssociatedTokenAddress
 */
function findAssociatedTokenAddressSync(wallet, tokenMint, tokenProgramId = exports.TOKEN_PROGRAM_ID, associatedTokenProramId = exports.ASSOCIATED_TOKEN_PROGRAM_ID) {
    return web3_js_1.PublicKey.findProgramAddressSync([wallet.toBytes(), tokenProgramId.toBytes(), tokenMint.toBytes()], associatedTokenProramId);
}
function getTokenMetadataAddress(tokenMint, tokenMetedataProgramId) {
    return web3_js_1.PublicKey.findProgramAddressSync([
        buffer_1.Buffer.from("metadata"),
        tokenMetedataProgramId.toBytes(),
        tokenMint.toBytes(),
    ], tokenMetedataProgramId);
}
const deBridge = {
    getClaimMarkerAddress: (DEBRIDGE_PROGRAM_ID) => web3_js_1.PublicKey.findProgramAddressSync([buffer_1.Buffer.from(constants.deBridge.Seeds.CLAIM_MARKER)], DEBRIDGE_PROGRAM_ID),
    getExternalCallStorageAddress: (submissionId, executorPubkey, sourceChainId, DEBRIDGE_PROGRAM_ID) => web3_js_1.PublicKey.findProgramAddressSync([
        buffer_1.Buffer.from(constants.deBridge.Seeds.EXTERNAL_CALL_STORAGE),
        submissionId,
        new web3_js_1.PublicKey(executorPubkey).toBytes(),
        (0, crypto_1.normalizeChainId)(sourceChainId),
    ], DEBRIDGE_PROGRAM_ID),
    getExternalCallMetaAddress: (externalCallStorage, DEBRIDGE_PROGRAM_ID) => web3_js_1.PublicKey.findProgramAddressSync([
        buffer_1.Buffer.from(constants.deBridge.Seeds.EXTERNAL_CALL_META),
        new web3_js_1.PublicKey(externalCallStorage).toBytes(),
    ], DEBRIDGE_PROGRAM_ID),
    getNonceAddress: (DEBRIDGE_PROGRAM_ID) => web3_js_1.PublicKey.findProgramAddressSync([buffer_1.Buffer.from(constants.deBridge.Seeds.NONCE)], DEBRIDGE_PROGRAM_ID),
    getSubmissionAddress: (submissionId, DEBRIDGE_PROGRAM_ID) => web3_js_1.PublicKey.findProgramAddressSync([buffer_1.Buffer.from(constants.deBridge.Seeds.SUBMISSION), submissionId], DEBRIDGE_PROGRAM_ID),
    getSubmissionAuthAddress: (submissionAddress, DEBRIDGE_PROGRAM_ID) => web3_js_1.PublicKey.findProgramAddressSync([
        buffer_1.Buffer.from(constants.deBridge.Seeds.SUBMISSION_AUTH),
        new web3_js_1.PublicKey(submissionAddress).toBytes(),
    ], DEBRIDGE_PROGRAM_ID),
    getMintAuthorityAddress: (bridge, DEBRIDGE_PROGRAM_ID) => web3_js_1.PublicKey.findProgramAddressSync([
        buffer_1.Buffer.from(constants.deBridge.Seeds.BRIDGE_MINTER),
        new web3_js_1.PublicKey(bridge).toBytes(),
    ], DEBRIDGE_PROGRAM_ID),
};
const deBridgeSettings = {
    getTokenMetadataMasterAddress: (SETTINGS_PROGRAM_ID) => web3_js_1.PublicKey.findProgramAddressSync([buffer_1.Buffer.from(constants.deBridgeSettings.Seeds.TOKEN_METADATA)], SETTINGS_PROGRAM_ID),
    getTokenMintAddress: (debridgeId, SETTINGS_PROGRAM_ID) => web3_js_1.PublicKey.findProgramAddressSync([buffer_1.Buffer.from(constants.deBridgeSettings.Seeds.WRAPPER_TOKEN), debridgeId], SETTINGS_PROGRAM_ID),
    getStateAddress: (SETTINGS_PROGRAM_ID) => web3_js_1.PublicKey.findProgramAddressSync([buffer_1.Buffer.from(constants.deBridgeSettings.Seeds.STATE)], SETTINGS_PROGRAM_ID),
    getConfirmationsStorageAddress: (message, SETTINGS_PROGRAM_ID) => web3_js_1.PublicKey.findProgramAddressSync([
        buffer_1.Buffer.from(constants.deBridgeSettings.Seeds.CONFIRMATION_STORAGE),
        message,
    ], SETTINGS_PROGRAM_ID),
    getBridgeFeeAddress: (bridge, chainId, SETTINGS_PROGRAM_ID) => web3_js_1.PublicKey.findProgramAddressSync([
        buffer_1.Buffer.from(constants.deBridgeSettings.Seeds.BRIDGE_FEE_INFO),
        bridge.toBytes(),
        (0, crypto_1.normalizeChainId)(chainId),
    ], SETTINGS_PROGRAM_ID),
    getChainSupportInfoAddress: (chainId, SETTINGS_PROGRAM_ID) => web3_js_1.PublicKey.findProgramAddressSync([
        buffer_1.Buffer.from(constants.deBridgeSettings.Seeds.CHAIN_SUPPORT_INFO),
        (0, crypto_1.normalizeChainId)(chainId),
    ], SETTINGS_PROGRAM_ID),
    getDiscountInfoAddress: (user, SETTINGS_PROGRAM_ID) => web3_js_1.PublicKey.findProgramAddressSync([
        buffer_1.Buffer.from(constants.deBridgeSettings.Seeds.DISCOUNT_INFO),
        user.toBytes(),
    ], SETTINGS_PROGRAM_ID),
    getBridgeAddress: (tokenMint, SETTINGS_PROGRAM_ID) => web3_js_1.PublicKey.findProgramAddressSync([
        buffer_1.Buffer.from(constants.deBridgeSettings.Seeds.BRIDGE),
        tokenMint.toBytes(),
    ], SETTINGS_PROGRAM_ID),
    getBridgeMapAddress: (bridgeId, SETTINGS_PROGRAM_ID) => web3_js_1.PublicKey.findProgramAddressSync([buffer_1.Buffer.from(constants.deBridgeSettings.Seeds.SEND_BRIDGE_MAP), bridgeId], SETTINGS_PROGRAM_ID),
    getNoDiscountAddress: (SETTINGS_PROGRAM_ID) => web3_js_1.PublicKey.findProgramAddressSync([buffer_1.Buffer.from(constants.deBridgeSettings.Seeds.NO_DISCOUNT)], SETTINGS_PROGRAM_ID),
    getNoBridgeFeeAddress: (SETTINGS_PROGRAM_ID) => web3_js_1.PublicKey.findProgramAddressSync([buffer_1.Buffer.from(constants.deBridgeSettings.Seeds.NO_BRIDGE_FEE_INFO)], SETTINGS_PROGRAM_ID),
};
const DlnSrc = {
    getStateAccount: (DLN_SRC_PROGRAM_ID) => web3_js_1.PublicKey.findProgramAddressSync([buffer_1.Buffer.from(constants.dlnSrc.Seeds.STATE)], DLN_SRC_PROGRAM_ID),
    getNonceAccount: (maker, DLN_SRC_PROGRAM_ID) => web3_js_1.PublicKey.findProgramAddressSync([
        buffer_1.Buffer.from(constants.dlnSrc.Seeds.NONCE),
        (0, interfaces_1.isBuffer)(maker) ? maker : maker.toBuffer(),
    ], DLN_SRC_PROGRAM_ID),
    getGiveOrderStateAccount: (orderId, DLN_SRC_PROGRAM_ID) => web3_js_1.PublicKey.findProgramAddressSync([buffer_1.Buffer.from(constants.dlnSrc.Seeds.ORDER_STATE), orderId], DLN_SRC_PROGRAM_ID),
    getAuthorizedNativeSenderAddress: (chainId, DLN_SRC_PROGRAM_ID) => web3_js_1.PublicKey.findProgramAddressSync([buffer_1.Buffer.from(constants.dlnSrc.Seeds.AUTHORIZED_NATIVE_SENDER), chainId], DLN_SRC_PROGRAM_ID),
    getGiveOrderWalletAddress: (orderId, DLN_SRC_PROGRAM_ID) => web3_js_1.PublicKey.findProgramAddressSync([buffer_1.Buffer.from(constants.dlnSrc.Seeds.GIVE_ORDER_WALLET), orderId], DLN_SRC_PROGRAM_ID),
    getFeeLedgerWalletAddress: (tokenMint, DLN_SRC_PROGRAM_ID) => web3_js_1.PublicKey.findProgramAddressSync([
        buffer_1.Buffer.from(constants.dlnSrc.Seeds.FEE_LEDGER_WALLET),
        tokenMint.toBuffer(),
    ], DLN_SRC_PROGRAM_ID),
    getFeeLedgerAddress: (DLN_SRC_PROGRAM_ID) => web3_js_1.PublicKey.findProgramAddressSync([buffer_1.Buffer.from(constants.dlnSrc.Seeds.FEE_LEDGER)], DLN_SRC_PROGRAM_ID),
};
const DlnDst = {
    getStateAddress: (DLN_DST_PROGRAM_ID) => web3_js_1.PublicKey.findProgramAddressSync([buffer_1.Buffer.from(constants.dlnDst.Seeds.STATE)], DLN_DST_PROGRAM_ID),
    getAuthorizedSrcContractAddress: (chainId, DLN_DST_PROGRAM_ID) => web3_js_1.PublicKey.findProgramAddressSync([buffer_1.Buffer.from(constants.dlnDst.Seeds.AUTHORIZED_SRC_CONTRACT), chainId], DLN_DST_PROGRAM_ID),
    getAuthorizedDstNativeSenderAddress: (DLN_DST_PROGRAM_ID) => web3_js_1.PublicKey.findProgramAddressSync([buffer_1.Buffer.from(constants.dlnDst.Seeds.AUTHORIZED_DST_NATIVE_SENDER)], DLN_DST_PROGRAM_ID),
    getTakeOrderStateAddress: (orderId, DLN_DST_PROGRAM_ID) => web3_js_1.PublicKey.findProgramAddressSync([buffer_1.Buffer.from(constants.dlnDst.Seeds.ORDER_STATE), orderId], DLN_DST_PROGRAM_ID),
    getTakePatchAddress: (orderId, DLN_DST_PROGRAM_ID) => web3_js_1.PublicKey.findProgramAddressSync([buffer_1.Buffer.from(constants.dlnDst.Seeds.TAKE_PATCH), orderId], DLN_DST_PROGRAM_ID),
};
function wrapFn(fn, arg) {
    return (...args) => fn(...args, arg);
}
class Resolver {
    constructor(programId, obj, memoizeList) {
        this.programId = new web3_js_1.PublicKey(programId);
        const transformKey = (args) => {
            if (args.length <= 1) {
                return [];
            }
            else {
                return args.slice(0, -1).map((a) => JSON.stringify(a));
            }
        };
        let methods = {};
        for (let [fnName, fn] of Object.entries(obj)) {
            if (fnName in memoizeList) {
                methods[fnName] = (0, micro_memoize_1.default)(wrapFn(fn, this.programId), {
                    ...memoizeList[fnName], //transformKey
                });
            }
            else {
                methods[fnName] = wrapFn(fn, this.programId);
            }
        }
        this.methods = methods;
    }
}
class ResolverContainer2 {
    constructor(resolver1, resolver2) {
        let methods = {};
        for (let resolver of [resolver1, resolver2]) {
            for (let [fnName, fn] of Object.entries(resolver.methods)) {
                methods[fnName] = fn;
            }
        }
        this.methods = methods;
    }
}
const DeBridgeResolver = (programId, settingsProgramId) => {
    const deBridgeMemoizeList = {
        getClaimMarkerAddress: {},
        getNonceAddress: {},
        getMintAuthorityAddress: { maxSize: 20 },
    };
    const settingsMemoizeList = {
        getTokenMetadataMasterAddress: {},
        getTokenMintAddress: { maxSize: 5 },
        getStateAddress: {},
        getBridgeFeeAddress: { maxSize: 40 },
        getChainSupportInfoAddress: { maxSize: 10 },
        getBridgeAddress: { maxSize: 10 },
        getBridgeMapAddress: { maxSize: 10 },
        getNoBridgeFeeAddress: {},
        getNoDiscountAddress: {},
    };
    return new ResolverContainer2(new Resolver(programId, deBridge, deBridgeMemoizeList), new Resolver(settingsProgramId, deBridgeSettings, settingsMemoizeList));
};
exports.DeBridgeResolver = DeBridgeResolver;
const dlnSrcResolver = (programId) => {
    const dlnMemoizeList = {
        getStateAccount: {},
        getAuthorizedNativeSenderAddress: { maxSize: 10 },
        getFeeLedgerAddress: {},
        getFeeLedgerWalletAddress: { maxSize: 10 },
    };
    return new Resolver(programId, DlnSrc, dlnMemoizeList);
};
exports.dlnSrcResolver = dlnSrcResolver;
const dlnDstResolver = (programId) => {
    const dstMemoizeList = {
        getAuthorizedSrcContractAddress: { maxSize: 10 },
        getAuthorizedDstNativeSenderAddress: {},
        getStateAddress: {},
    };
    return new Resolver(programId, DlnDst, dstMemoizeList);
};
exports.dlnDstResolver = dlnDstResolver;
//# sourceMappingURL=accounts.js.map
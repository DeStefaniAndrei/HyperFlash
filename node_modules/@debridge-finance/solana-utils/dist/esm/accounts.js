import { Buffer } from "buffer";
import { PublicKey } from "@solana/web3.js";
import * as constants from "./constants";
import { normalizeChainId } from "./crypto";
import { isBuffer } from "./interfaces";
import memoize from "micro-memoize";
export const TOKEN_2022_PROGRAM_ID = new PublicKey("TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb");
export const TOKEN_METADATA_PROGRAM_ID = new PublicKey("metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s");
export const TOKEN_PROGRAM_ID = new PublicKey("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA");
export const ASSOCIATED_TOKEN_PROGRAM_ID = new PublicKey("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL");
export const WRAPPED_SOL_MINT = new PublicKey("So11111111111111111111111111111111111111112");
export function findAssociatedTokenAddress(wallet, tokenMint, tokenProgramId = TOKEN_PROGRAM_ID, associatedTokenProramId = ASSOCIATED_TOKEN_PROGRAM_ID) {
    return PublicKey.findProgramAddressSync([wallet.toBytes(), tokenProgramId.toBytes(), tokenMint.toBytes()], associatedTokenProramId);
}
/**
 * @deprecated same as findAssociatedTokenAddress
 */
export function findAssociatedTokenAddressSync(wallet, tokenMint, tokenProgramId = TOKEN_PROGRAM_ID, associatedTokenProramId = ASSOCIATED_TOKEN_PROGRAM_ID) {
    return PublicKey.findProgramAddressSync([wallet.toBytes(), tokenProgramId.toBytes(), tokenMint.toBytes()], associatedTokenProramId);
}
export function getTokenMetadataAddress(tokenMint, tokenMetedataProgramId) {
    return PublicKey.findProgramAddressSync([
        Buffer.from("metadata"),
        tokenMetedataProgramId.toBytes(),
        tokenMint.toBytes(),
    ], tokenMetedataProgramId);
}
const deBridge = {
    getClaimMarkerAddress: (DEBRIDGE_PROGRAM_ID) => PublicKey.findProgramAddressSync([Buffer.from(constants.deBridge.Seeds.CLAIM_MARKER)], DEBRIDGE_PROGRAM_ID),
    getExternalCallStorageAddress: (submissionId, executorPubkey, sourceChainId, DEBRIDGE_PROGRAM_ID) => PublicKey.findProgramAddressSync([
        Buffer.from(constants.deBridge.Seeds.EXTERNAL_CALL_STORAGE),
        submissionId,
        new PublicKey(executorPubkey).toBytes(),
        normalizeChainId(sourceChainId),
    ], DEBRIDGE_PROGRAM_ID),
    getExternalCallMetaAddress: (externalCallStorage, DEBRIDGE_PROGRAM_ID) => PublicKey.findProgramAddressSync([
        Buffer.from(constants.deBridge.Seeds.EXTERNAL_CALL_META),
        new PublicKey(externalCallStorage).toBytes(),
    ], DEBRIDGE_PROGRAM_ID),
    getNonceAddress: (DEBRIDGE_PROGRAM_ID) => PublicKey.findProgramAddressSync([Buffer.from(constants.deBridge.Seeds.NONCE)], DEBRIDGE_PROGRAM_ID),
    getSubmissionAddress: (submissionId, DEBRIDGE_PROGRAM_ID) => PublicKey.findProgramAddressSync([Buffer.from(constants.deBridge.Seeds.SUBMISSION), submissionId], DEBRIDGE_PROGRAM_ID),
    getSubmissionAuthAddress: (submissionAddress, DEBRIDGE_PROGRAM_ID) => PublicKey.findProgramAddressSync([
        Buffer.from(constants.deBridge.Seeds.SUBMISSION_AUTH),
        new PublicKey(submissionAddress).toBytes(),
    ], DEBRIDGE_PROGRAM_ID),
    getMintAuthorityAddress: (bridge, DEBRIDGE_PROGRAM_ID) => PublicKey.findProgramAddressSync([
        Buffer.from(constants.deBridge.Seeds.BRIDGE_MINTER),
        new PublicKey(bridge).toBytes(),
    ], DEBRIDGE_PROGRAM_ID),
};
const deBridgeSettings = {
    getTokenMetadataMasterAddress: (SETTINGS_PROGRAM_ID) => PublicKey.findProgramAddressSync([Buffer.from(constants.deBridgeSettings.Seeds.TOKEN_METADATA)], SETTINGS_PROGRAM_ID),
    getTokenMintAddress: (debridgeId, SETTINGS_PROGRAM_ID) => PublicKey.findProgramAddressSync([Buffer.from(constants.deBridgeSettings.Seeds.WRAPPER_TOKEN), debridgeId], SETTINGS_PROGRAM_ID),
    getStateAddress: (SETTINGS_PROGRAM_ID) => PublicKey.findProgramAddressSync([Buffer.from(constants.deBridgeSettings.Seeds.STATE)], SETTINGS_PROGRAM_ID),
    getConfirmationsStorageAddress: (message, SETTINGS_PROGRAM_ID) => PublicKey.findProgramAddressSync([
        Buffer.from(constants.deBridgeSettings.Seeds.CONFIRMATION_STORAGE),
        message,
    ], SETTINGS_PROGRAM_ID),
    getBridgeFeeAddress: (bridge, chainId, SETTINGS_PROGRAM_ID) => PublicKey.findProgramAddressSync([
        Buffer.from(constants.deBridgeSettings.Seeds.BRIDGE_FEE_INFO),
        bridge.toBytes(),
        normalizeChainId(chainId),
    ], SETTINGS_PROGRAM_ID),
    getChainSupportInfoAddress: (chainId, SETTINGS_PROGRAM_ID) => PublicKey.findProgramAddressSync([
        Buffer.from(constants.deBridgeSettings.Seeds.CHAIN_SUPPORT_INFO),
        normalizeChainId(chainId),
    ], SETTINGS_PROGRAM_ID),
    getDiscountInfoAddress: (user, SETTINGS_PROGRAM_ID) => PublicKey.findProgramAddressSync([
        Buffer.from(constants.deBridgeSettings.Seeds.DISCOUNT_INFO),
        user.toBytes(),
    ], SETTINGS_PROGRAM_ID),
    getBridgeAddress: (tokenMint, SETTINGS_PROGRAM_ID) => PublicKey.findProgramAddressSync([
        Buffer.from(constants.deBridgeSettings.Seeds.BRIDGE),
        tokenMint.toBytes(),
    ], SETTINGS_PROGRAM_ID),
    getBridgeMapAddress: (bridgeId, SETTINGS_PROGRAM_ID) => PublicKey.findProgramAddressSync([Buffer.from(constants.deBridgeSettings.Seeds.SEND_BRIDGE_MAP), bridgeId], SETTINGS_PROGRAM_ID),
    getNoDiscountAddress: (SETTINGS_PROGRAM_ID) => PublicKey.findProgramAddressSync([Buffer.from(constants.deBridgeSettings.Seeds.NO_DISCOUNT)], SETTINGS_PROGRAM_ID),
    getNoBridgeFeeAddress: (SETTINGS_PROGRAM_ID) => PublicKey.findProgramAddressSync([Buffer.from(constants.deBridgeSettings.Seeds.NO_BRIDGE_FEE_INFO)], SETTINGS_PROGRAM_ID),
};
const DlnSrc = {
    getStateAccount: (DLN_SRC_PROGRAM_ID) => PublicKey.findProgramAddressSync([Buffer.from(constants.dlnSrc.Seeds.STATE)], DLN_SRC_PROGRAM_ID),
    getNonceAccount: (maker, DLN_SRC_PROGRAM_ID) => PublicKey.findProgramAddressSync([
        Buffer.from(constants.dlnSrc.Seeds.NONCE),
        isBuffer(maker) ? maker : maker.toBuffer(),
    ], DLN_SRC_PROGRAM_ID),
    getGiveOrderStateAccount: (orderId, DLN_SRC_PROGRAM_ID) => PublicKey.findProgramAddressSync([Buffer.from(constants.dlnSrc.Seeds.ORDER_STATE), orderId], DLN_SRC_PROGRAM_ID),
    getAuthorizedNativeSenderAddress: (chainId, DLN_SRC_PROGRAM_ID) => PublicKey.findProgramAddressSync([Buffer.from(constants.dlnSrc.Seeds.AUTHORIZED_NATIVE_SENDER), chainId], DLN_SRC_PROGRAM_ID),
    getGiveOrderWalletAddress: (orderId, DLN_SRC_PROGRAM_ID) => PublicKey.findProgramAddressSync([Buffer.from(constants.dlnSrc.Seeds.GIVE_ORDER_WALLET), orderId], DLN_SRC_PROGRAM_ID),
    getFeeLedgerWalletAddress: (tokenMint, DLN_SRC_PROGRAM_ID) => PublicKey.findProgramAddressSync([
        Buffer.from(constants.dlnSrc.Seeds.FEE_LEDGER_WALLET),
        tokenMint.toBuffer(),
    ], DLN_SRC_PROGRAM_ID),
    getFeeLedgerAddress: (DLN_SRC_PROGRAM_ID) => PublicKey.findProgramAddressSync([Buffer.from(constants.dlnSrc.Seeds.FEE_LEDGER)], DLN_SRC_PROGRAM_ID),
};
const DlnDst = {
    getStateAddress: (DLN_DST_PROGRAM_ID) => PublicKey.findProgramAddressSync([Buffer.from(constants.dlnDst.Seeds.STATE)], DLN_DST_PROGRAM_ID),
    getAuthorizedSrcContractAddress: (chainId, DLN_DST_PROGRAM_ID) => PublicKey.findProgramAddressSync([Buffer.from(constants.dlnDst.Seeds.AUTHORIZED_SRC_CONTRACT), chainId], DLN_DST_PROGRAM_ID),
    getAuthorizedDstNativeSenderAddress: (DLN_DST_PROGRAM_ID) => PublicKey.findProgramAddressSync([Buffer.from(constants.dlnDst.Seeds.AUTHORIZED_DST_NATIVE_SENDER)], DLN_DST_PROGRAM_ID),
    getTakeOrderStateAddress: (orderId, DLN_DST_PROGRAM_ID) => PublicKey.findProgramAddressSync([Buffer.from(constants.dlnDst.Seeds.ORDER_STATE), orderId], DLN_DST_PROGRAM_ID),
    getTakePatchAddress: (orderId, DLN_DST_PROGRAM_ID) => PublicKey.findProgramAddressSync([Buffer.from(constants.dlnDst.Seeds.TAKE_PATCH), orderId], DLN_DST_PROGRAM_ID),
};
function wrapFn(fn, arg) {
    return (...args) => fn(...args, arg);
}
class Resolver {
    constructor(programId, obj, memoizeList) {
        this.programId = new PublicKey(programId);
        const transformKey = (args) => {
            if (args.length <= 1) {
                return [];
            }
            else {
                return args.slice(0, -1).map((a) => JSON.stringify(a));
            }
        };
        let methods = {};
        for (let [fnName, fn] of Object.entries(obj)) {
            if (fnName in memoizeList) {
                methods[fnName] = memoize(wrapFn(fn, this.programId), Object.assign({}, memoizeList[fnName]));
            }
            else {
                methods[fnName] = wrapFn(fn, this.programId);
            }
        }
        this.methods = methods;
    }
}
class ResolverContainer2 {
    constructor(resolver1, resolver2) {
        let methods = {};
        for (let resolver of [resolver1, resolver2]) {
            for (let [fnName, fn] of Object.entries(resolver.methods)) {
                methods[fnName] = fn;
            }
        }
        this.methods = methods;
    }
}
export const DeBridgeResolver = (programId, settingsProgramId) => {
    const deBridgeMemoizeList = {
        getClaimMarkerAddress: {},
        getNonceAddress: {},
        getMintAuthorityAddress: { maxSize: 20 },
    };
    const settingsMemoizeList = {
        getTokenMetadataMasterAddress: {},
        getTokenMintAddress: { maxSize: 5 },
        getStateAddress: {},
        getBridgeFeeAddress: { maxSize: 40 },
        getChainSupportInfoAddress: { maxSize: 10 },
        getBridgeAddress: { maxSize: 10 },
        getBridgeMapAddress: { maxSize: 10 },
        getNoBridgeFeeAddress: {},
        getNoDiscountAddress: {},
    };
    return new ResolverContainer2(new Resolver(programId, deBridge, deBridgeMemoizeList), new Resolver(settingsProgramId, deBridgeSettings, settingsMemoizeList));
};
export const dlnSrcResolver = (programId) => {
    const dlnMemoizeList = {
        getStateAccount: {},
        getAuthorizedNativeSenderAddress: { maxSize: 10 },
        getFeeLedgerAddress: {},
        getFeeLedgerWalletAddress: { maxSize: 10 },
    };
    return new Resolver(programId, DlnSrc, dlnMemoizeList);
};
export const dlnDstResolver = (programId) => {
    const dstMemoizeList = {
        getAuthorizedSrcContractAddress: { maxSize: 10 },
        getAuthorizedDstNativeSenderAddress: {},
        getStateAddress: {},
    };
    return new Resolver(programId, DlnDst, dstMemoizeList);
};
//# sourceMappingURL=accounts.js.map